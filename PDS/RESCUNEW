./ ADD NAME=$$$DOC   0102-02207-03007-1037-00278-00249-00000-ITSCXB
This utility was originally written by John C. Miller
(http://www.jmit.com/ john@jmit.com) who is due most of the thanks.

Additional enhancements and corrections were made by Chris Buckley
(chris_buckley@mandg.co.uk). The changes were:

* The JES2PARM member in the original got built with both the spooldef
  and ckptdef statements pointing to sys1.haspckpt.
* There were originally several rexx execs that all used slightly
  different versions of the same subroutines, some of them containing
  errors. I've tidied all this up and there is now only one procedurised
  rexx exec with one set of subroutines.
* The 13 or so jobs that the rexx exec generates to build the one pack
  system had to be submitted individually. Each job now submits the next
  given RC=0.
* The build now cleans up the one pack system specific alias and export
  disconnects the one pack system master catalog.
* SYS1.SDWWDLPA needs to be in the LPA as the result of recent service.
* SYS1.SHASPARM has been added to the PARMLIB concatenation for JES2
  debugging with IPCS.
* ISR@PRIM has been tailored to include a number of additional options
  (SDSF, SMPE etc.).
* Support for a second volume to handle large HFS files didn't work very
  well. I've tidied this up.
* Improved the building of certain parmlib members (things like COFVLF00
  although I'm not sure exactly which ones I changed).
* Added support for European/US dates in generated comments.
* Added support for selecting the EDT to use in the generated system
  instead of defaulting to 00.
* Dataset copies with DSS are all batched together and processed in a
  single step which speeds things up significantly.

---------------------------------------------------------------------
Rescue System Execs
---------------------------------------------------------------------
NOTE: See the $$$QUIK member to get started with minimum verbiage.

The Long Version:
This set of Rexx execs is used to build a single-volume (3390-3), self
contained OS/390 rescue system.  These exec are a replacement for the
older rescue assembler macros for building a rescue system based on
OS/390 version 1.3.  These exec are much better in my opinion. The
execs are smarter, and dynamically build lots of parmlib members,
PROCs, etc.  This version was developed based on OS/390 version 2.10,
and supports OMVS.  I've included TCP/IP libraries in this build.

Read the $$$ members - They contain useful information, especially if
you are having problems.  See the $$$MAINT member for maintenance issues
related to HFS and PDS-E support.  See the $$$RACF member for info on
RACF authority that you'll need to run the jobs that build the RESCUE
system.

You don't have to be an OS/390 guru to successfully use this set of
tools to build an OS/390 rescue system.  You do however need to have a
fairly solid grounding in OS/390 (MVS) in order to know what the various
jobs and piece parts do, and how to get past inevitable glitches.
Liberal use of the IBM manuals will be of help.  (See the web site below
for some handy IBM web manuals)

DISCLAIMER: You alone are responsible for any success that you have with
this software tool, as well as any damage done to your system, losses
incurred, etc.

I would greatly appreciate any bug reports, and will answer questions
via email, time permitting.

Good Luck, and remember to RTFM (Read The Fine Manuals)

---------------------------------------------------------------------
            VERY, VERY, EXTRAORDINARILY IMPORTANT NOTES:
      READ THESE NOW, OR BE TRULY AND PROFOUNDLY SORRY LATER:
---------------------------------------------------------------------
* Look at the generated jobs *before* running them, especially JOBA,
  the first job.  It is *incredibly* easy to wipe out an existing
  PRODUCTION disk volume with JOBA if you are not careful.  JOBA
  automatically varies a volume offline, and runs ICKDSF to
  initialize it.  You will need to reply to an MVS console prompt
  when JOBA runs. BEFORE replying to this message to continue, DOUBLE
  CHECK the unit address in the message, and be sure it's the disk
  pack that you want to wipe clean and use to build your rescue
  system.  Most of the remaining jobs are not as dangerous, but you
  should still review the JCL, and understand what each job is doing.
  (This is good for the soul anyway!)

* I'm making the significant assumption that you know what you're doing.

  IN SHORT: If you don't know what a job is going to do, you have
  absolutely no business running it !!!

---------------------------------------------------------------------
                       IMPORTANT NOTES:
            READ THESE NOW TO AVOID FRUSTRATION LATER
---------------------------------------------------------------------
* The good news, now that I've scared you into being careful, is that
  these execs can take some of the drudgery, tedium, and trial and error
  out of the process of building an OS/390 system from scratch.

* OS/390 is not a turnkey system, and these rescue execs are NOT, repeat
  NOT completely automatic.  They are simply a tool that can be used to
  greatly assist in building a single volume rescue system.  However:
  the parameters as delivered are what I used to build a fully
  functioning OS/390 rescue system, and so they may be pretty close to
  what you need, or at least a good start!

* So take some time to carefully review the @PARMS and @DATASET members.
  Don't rush through this part.  Expect to do some tweaking, and expect
  to have to do several system builds before you get a system that IPLs
  and works as expected.

  Once you get the @PARMS and @DATASET members set up the way you
  like, it's very easy to generate a fresh set of jobs, and then run
  the jobs to build a new system.  You'll may even learn something
  about OS/390 by studying the generated jobs.

* RACF Authorities:  See the $$$RACF member of this PDS for RACF
  privileges that are required.

* COMMAND and WAIT programs:  These programs enable the disk unit to be
  varied online and offline by a batch job. If you want this capability
  but don't have these programs on your system already, you can use the
  source in the RESCUE PDS to assemble them.  Assemble these modules to
  a linklisted APF authorized library.

  The COMMAND program is one that I pulled of a CBT tape.  I added code
  to do a RACHECK against the COMMAND profile in the APPL class looking
  for at least READ access.  This prevents undesirable miscreants and
  other unauthorized individuals from issuing MVS commands using this
  program.

  If you don't want to use the COMMAND and WAIT programs, code a null
  value for COMMANDPGM and WAITPGM in the @PARMS member, or just take
  these parms out altogether.  The JCL generated will no longer use
  these programs.

---------------------------------------------------------------------
                  Modifying the RESCUE execs:
---------------------------------------------------------------------
If you want to tweak, hack, or otherwise modify these execs, by all
means be my guest - but you're on your own.  I've tried to comment
the code sufficiently to give a saavy rexx coder the basic idea of
what's going on. I try to avoid truly ugly, oblique, obscure, or
overly terse ways of doing things in rexx when there's a simpler
way, but I don't shy away from "off the wall" techniques when they
work best (or when I can't figure out a simpler way of doing a
task!)

I've made the execs essentially modular, in that the main exec
RESCUE calls external subroutines that are named starting with '#'.
Each subroutine generally builds one job, or does one task.  To add
some new functionality of your own design, make a copy of one of the
subroutines like #initvol, for example, and make it do what you
want.

---------------------------------------------------------------------
Here's how to use these execs to build a one-pack rescue system:
---------------------------------------------------------------------
1)  There used to be a ##PDS member than specified the name of this
    data set. It is no longer required.

2)  Edit the @DATASET member to include all the datasets needed to
    build a single volume OS/390 system.  The @DATASET members is
    delivered with the list of datasets that I used to create a
    OS/390 2.10 rescue system.  Your mileage may vary, and you
    will need to be sure that all needed datasets are included.

3)  Edit the @PARMS member with the values that you want.  The @PARMS
    member is delivered with an example set of parms that were
    actually used to successfully build a rescue system. You will want
    to change some of the parameters.

4a) Use the $BUILD job to run the rescue build execs under batch TSO.
    Fix the jobcard and PDS name (SYSPROC DD stmt) first.

4b) If desired you can place the PDS containing the rescue execs in your
    SYSPROC concatenation, and from TSO READY enter: %RESCUE. You may
    have to log off to let some of the jobs run, however, so this method
    may be a pain at times.

    Regardless of which option you choose, the necessary jobs and
    members will now be built, and named sequentially JOBA..JOBn, where
    n is howver many jobs end up getting generated.

  *******************************************************************
  *******************************************************************
  *** NOTE: Up until this point, nothing has been been changed on ***
  **  either the driving system or the new rescue system.  The     **
  **  steps below this box will start tweaking and building.       **
  **  If all goes as expected, the only changes made to the        **
  **  driving system are:                                          **
  **  a. The driving system mastercat will have an alias defined   **
  **     pointing to the rescue system mastercat.                  **
  **  b. RACF Profile TSORESC in TSOPROC class will be defined.    **
  **  c. RACF ID $RESCUE and group $STC will be defined.           **
  **                                                               **
  **     THAT SHOULD BE IT.  ANYTHING ELSE WAS NOT INTENDED,       **
  **     AND SHOULD BE DONE AT YOUR OWN RISK!!!                    **
  **     (Did I mention that you should review each job            **
  ***    before it is run?  Well, please do.)                     ***
  *******************************************************************
  *******************************************************************

5)  Run all the jobs (JOBA - JOBx).  Again -- reviewing and
    understanding the jobs *before* you run them would be, as they
    say, "a good thing."

    Investigate any job steps that complete with return code 8 or
    greater.

  *******************************************************************
  *******************************************************************
  ***  If everything was defined right, you should now have an    ***
  **   IPL'able OS/390 rescue system.  The steps below are some    **
  **   areas to check before trying to IPL.  You don't have to     **
  **   do these things now, but you'll probably save yourself      **
  ***  some IPLs if you do check them first.                      ***
  *******************************************************************
  *******************************************************************

6)  You will need to fix the ATCCON and ATCSTR members of VTAMLST, and
    also be sure that the necessary VTAMLST members are available on
    your rescue system.  Use COPY statements in the @DATASET member to
    specify members to copy.  You may want to code a special set of
    trimmed down VTAM parms in a private PDS, and copy them into VTAMLST
    and VTAMLIB using COPY statements.

7)  Review PARMLIB.  SYS1.RESCUE.PARMLIB is first in the PARMLIB concat,
    followed by whatever other PARMLIBS are coded in @DATASET with the
    'PARMLIB' attribute: ,,(PARMLIB).  Parmlib members are built for you
    and copied to SYS1.RESCUE.PARMLIB as follows:

    PROGA0   - APF authorized libraries (Coded in @DATASET with APF)
    PROGL0   - Linklist libraries (Coded in @DATASET with LNK)
    MSTJCL01 - Master JCL.  Includes all PROCLIBS coded in @DATASET with
               the "JES2" attribute.
    JES2PARM - JES2 parms. Member ZJES2PARM is combined with dynamically
               built SPOOLDEF and CKPTDEF statements, and then copied to
               the JES2PARM member in SYS1.RESCUE.PARMLIB.  Review
               ZJES2PRM for any changes you want to make *before*
               building the rescue jobs.  The SPOOLDEF and CKPTDEF are
               already coded for you, but you may want to change some of
               the other parameters, or replace the entire ZJES2PRM
               member with your own JES2 parms.  If you do this, be sure
               to remove the SPOOLDEF and CKPTDEF statements from the
               source that you place in ZJES2PARM, since these two
               statements are coded for you automatically.
    IGDSMS00 - SMS parms built from ZIGDSMS and ACDS/COMMDS statements
               built dynamically.

    NOTE: You'll need to be sure that one of the PARMLIB's that you're
    copying to the RESCUE system has the remainder of the members needed
    as coded in SYS1.RESCUE.PARMLIB(IEASYS00)'. Your production PARMLIB
    dataset will probably work fine.

8)  Review PROCLIB.  SYS1.RESCUE.PROCLIB is first in the PROCLIB
    concat, followed by whatever other PROCLIBs are coded in
    @DATASET with the "JES2" attribute: ,,(JES2).  Started procedures
    (PROCS) are built for you and copied to SYS1.RESCUE.PROCLIB as
    follows:
    TSO      - TSO started PROC.
    VTAM     - VTAM started PROC.  Includes libraries in the VTAMLST and
               VTAMLIB concatenation that you coded in @DATASET with the
               'VTAMLST' and 'VTAMLIB' attribute respectively.
    JES2     - JES2 Startup PROC.  Includes libraries in the PROC00
               concatenation that you coded in @DATASET with the 'JES2'
               attribute.
    TSORESC  - TSO LOGON PROC.  Includes libraries defined in @DATASET
               with attributes:  ISPPLIB, ISPMLIB, ISPSLIB, ISPTLIB,
               ISPLLIB, SYSPROC, SYSUADS.

9)  Review IPLPARM.  SYS1.IPLPARM on the RESCUE volume has member LOAD00
    built from the parameters you specified.  PARMLIB statements are
    included for libraries in the @DATASET member coded with the
    'PARMLIB' attribute.

10) IPL the new rescue volume, and see what happens.  Hopefully
    you'll be close to having a working system.  If it works the
    first time--you rock!

./ ADD NAME=$$$IDX   0102-02207-03007-1044-00041-00053-00000-ITSCXB
Index of members:

Members starting with "#" are rexx subroutines.
Members starting with "Z" are input of some kind for the rescue execs.
"Z" members may need some modification based on local requirements.
Members starting with "@" are input parms that you need to code.

$$$DOC   - The documentation for the RESCUE execs, such as it is.
$$$IDX   - This member.
$$$MAINT - Info regarding OS/390 maintenance and non-SMS managed HFS.
$$$MISC  - Miscellaneous explanations, etc.
$$$QUIK  - Quickstart for the impatient - Better know what you're doin.
$$$RACF  - Info on RACF authority that you'll need to run the jobs.
$$$SARES - Info on building standalone restore tapes.  Important!
$BUILD   - Batch job to run RESCUE system build.
$SAREST  - Job to build a standalone RESCUE system restore tape.
@DATASET - Place where all the RESCUE system datasets are defined.
@PARMS   - Main setup member that defines how system will be built.
COMMAND  - "COMMAND" src - Issues MVS console commands, RACF secured.
RESCUE   - The main exec that is run to build all the JCL and members.
ZBPXPRM  - OMVS PARMLIB member.  MOUNT statments are added to this mem.
ZIEALPA  - IEALPA00 PARMLIB member source.  Updated by execs.
ZIEASYS  - IEASYS00 PARMLIB member.
ZJES2PRM - Partial JES2PARM member.  Modifiy if desired.
ZJOBNUM  - Work member - Last job number used.  Leave this alone.

Members that get built when the RESCUE exec is run:

BPXPRM00 - OMVS parms.
IGDSMS00 - SMS parms.
JES2     - JES2 started procedure.
JES2PARM - JES2 parameter deck.
JOBx     - Jobs that do the actual build of the RESCUE system.
LOAD00   - IPLPARM LOAD00 member.
MSTJCL01 - Master JCL PARMLIB member.
PROGA0   - PROG PARMLIB member with APF statements.
PROGL0   - PROG PARMLIB member with LNKLST statements.
TSORESC  - TSO LOGON procedure.
VTAM     - VTAM started procedure.
ZBPXPRM  - Entries are added to this member for OMVS datasets.
ZIEALPA  - Entries are added to this member for ICHRIN03 and ICHRDSNT
./ ADD NAME=$$$MAINT 0101-02207-03007-1044-00019-00019-00000-ITSCXB
Note:

The RESCUE execs were coded on an OS/390 2.10 system with the required
PTFs applied for the support of non-SMS managed HFS and PDS-E files.
The jobs generated by these exec assume such support, and may have
problems if your driving system does not contain the necessary PTFs from
HFS/PDSE support on non-SMS volumes.  If this occurs, you will need to
apply the PTFs needed for your release, or settle for a two volume
rescue system:  One volume for the main OS/390 system, and a second, SMS
managed volume for the OMVS HFS files needed to bring up OMVS and
TCP/IP.

Before I could get DFDSS to copy HFS and PDS-E datasets to non-SMS
volumes, I had to apply the following PTFs to OS/390 2.10.  You may
need these and/or others, so check IBMLink for the particulars.

UW75133 UW73273 UW74319 UW75737 UW72235 UW75748 UW71231
UW71404 UW75737 UW76206 UW74319 UW75133 UW75690 UW75748

./ ADD NAME=$$$MISC  0100-02207-02207-1614-00070-00070-00000-*BASE*
---------------------------------------------------------------------
Rescue System Execs - Notes, explanations, etc.
---------------------------------------------------------------------

---------------------------------------------------------------------
SSA
---------------------------------------------------------------------
Explanation:
System Specific Aliases is a technique that has been used for many
moons by the IBM MVS software delivery groups.  An alias is defined in
the driving system master catalog that points to the new system
mastercat.  Any dataset names that might conflict with live datasets
are defined with an extra prefix (the "SSA") not found on the driving
system.  This accomplishes 2 desirable outcomes:

1) All catalog entries for RESCUE system datasets are created in the
RESCUE system master catalog, where we want them. This avoids junk in
the driving system master catalog or user catalogs.

2) RESCUE system datasets remain cataloged to the driving system until
the jobs are done manipulating them. This approach avoids the use of
STEPCAT DD statements, which according to IBM developers, will be
dropped completely at some point.

---------------------------------------------------------------------
RACF Started Task Table
---------------------------------------------------------------------
Explanation:  I use a RACF started task module ICHRIN03 instead of
using profiles in the RACF STARTED class, which would probably be much
more cool.  I take this approach to minimize changes to the driving

1) The RACF DS on the rescue system is a copy of the one on the driving
   system.  Therefore, before copying the RACFDS from the driving
   system, any needed RACF tweaking has to be done to the driving
   system's RACF environment. I prefer to minimize any changes to the
   driving systems RACF environment.  I basically add a RACF ID and a
   RACF group, and don't activate any classes, etc.  You just need to
   pick a USERID and GROUP name that don't already exist.  If you pick
   a USERID or GROUP that do already exist on the driving system, the
   generated jobs will contain whining messages to this effect.

2) Messing with the STARTED class on the driving system (Which you may
   or may not even be using) can have some dire consequences, and may
   result in the driving system becoming non-IPLable.  I prefer to not
   go there.

---------------------------------------------------------------------
TCP/IP
---------------------------------------------------------------------
TCP/IP will probably need some work by you before you can telnet in
and log on to your new rescue system.

The RESCUE execs handle some of the required TCP/IP setup like the
started task table entry for TCPIP, a RACF ID defined with a UID0 OMVS
segment, OMVS datasets being defined in the BPXPRM00 parmlib member,
and maybe some other stuff that I've programmed in but forgotten.

You'll need to be sure that the necessary PROCS and parameteter
members are set up right for your shop.  This is a non-trivial task,
and I have not yet risen to the task of automating this part.  It
should be a fairly simple task to copy over these elements as-is from
your production system, and make a few changes for things like the IP
address and domain name, and the hardware interface.

---------------------------------------------------------------------
MSTJCL01
---------------------------------------------------------------------
I name the master JCL member with the "01" suffix to prevent the master
scheduler from starting using any JCL found in SYS1.LINKLIB(MSTJCL00)
This way I can be absolutely sure that my master JCL member is used.
./ ADD NAME=$$$QUIK  0101-02207-02289-1101-00041-00042-00000-ITSCXB
---------------------------------------------------------------------
Rescue System Execs - Quick Start
---------------------------------------------------------------------
Ok, so you're like me -- impatient, and don't want to read through all
the dumb comments, disclaimers, etc.  Here's the quick version of how
to use the RESCUE execs:

1)  There used to be a ##PDS member than specified the name of this
    data set. It is no longer required.

2)  Edit the @DATASET member to include all the datasets needed to
    build a single volume OS/390 system.  The @DATASET members is
    delivered with the list of datasets that I used to create a
    OS/390 2.10 rescue system.  Your mileage may vary, and you
    will need to be sure that all needed datasets are included.

3)  Edit the @PARMS member with the values that you want.  The @PARMS
    member is delivered with an example set of parms that were actually
    used to successfully build a rescue system. You will probably want
    to change most if not all of them.

4)  Use the $BUILD job to run the rescue build execs under batch TSO.
    Fix the jobcard and PDS name (SYSPROC DD stmt) first.

5)  Run all the jobs (JOBA - JOBx).  Again, reviewing and understanding
    the jobs before you run them would be, as they say, "good."
    Investigate any steps that are return code 8 or greater.

    If you're really hot, you now have an IPL'able rescue system.

    If on the other hand you're like me, you'll have a few dozen little
    gotchas to fix, pieces that fell through the cracks.  Things like:

    a. VTAMLST members that reflect your local config.  Tweak the
    @DATASET member to auto copy members like these over.

    b. Assorted PARMLIB members missing.
    c. Some off the wall linklib that was missed somehow.
    d. You name it.

    Have Fun!
./ ADD NAME=$$$RACF  0101-02207-03007-1044-00037-00037-00000-ITSCXB
---------------------------------------------------------------------
RACF authority needed:
---------------------------------------------------------------------
Below are some requirements for RACF authority that you'll need
to run the jobs generated by the RESCUE exec.  You don't need
these permissions to runs the execs which generate the JCL and
other members for the RESCUE system, but you will need them to actually
run some of the jobs.

I've probably missed some--if so, please drop me a note so I can add
them to the list for others who use this thing.  My email is in the
$$$DOC member - Thanks.

---------------------------------------------------------------------
RACF privileges needed:
---------------------------------------------------------------------
RACF SPECIAL is needed to run the IRRUT400 job, which locks the
production RACF dataset, and creates a copy.  If your ID does not have
the RACF SPECIAL attribute, extra warning notes will be included in the
jobs that are generated, indicating that RACF SPECIAL is needed to run
those jobs.

---------------------------------------------------------------------
RACF Facility profiles to which you will need at least ALTER access:
---------------------------------------------------------------------
STGADMIN.ADR.COPY.BYPASSACS
STGADMIN.ADR.COPY.PROCESS.SYS
STGADMIN.ADR.DUMP.TOLERATE.ENQF
STGADMIN.ADR.RESTORE.BYPASSACS
STGADMIN.ADR.RESTORE.TOLERATE.ENQF

I suggest defining a generic FACILITY profile such as would be defined
by the commands below, and getting ALTER access to it.

   RDEFINE FACILITY STGADMIN.ADR.** UACC(NONE)
   PERMIT  STGADMIN.ADR.** CLASS(FACILITY) ID(yourid) ACCESS(ALTER)
   SETROPTS RACLIST(FACILITY) REFRESH
./ ADD NAME=$$$SARES 0100-02207-02207-1614-00055-00055-00000-*BASE*
------------------------------------------------------------------*
Standalone Rescue Tapes ($SAREST)
------------------------------------------------------------------*
Run this job after you have a working RESCUE system built, and to
which you can log on to TSO and do useful tasks.  It will create a
set of tapes that you can use if you ever get completely hosed--i.e.
your system is flat on its back, and you have no system that you can
bring up to make repairs. I have been in this very situation, and I
can tell you that it is *immensely* satisfying to be able to resort
to the procedure described herein, and pull a rabbit out of a hat,
so to speak.

I suggest that you call the tapes created by this job RESCU1 -
RESCUn, and put a stick on label on each tape with the volser
written on it.  Since these tapes are non-labelled, the system
will not keep them straight for you!

Another very important suggestion: Before creating these tapes,
change the RACF password for the TSO ID you will be using to some
new value, and PHYSICALLY WRITE THIS DOWN on the first of the
tapes.  The RACF password that you were using when you created
the RESCUE system dump tapes will likely be long forgotten by the
time you get around to using them.  If you can't log on to TSO,
your RESCUE system will be worthless.  Some sysprogs will copy
the production RACF dataset to their RESCUE packs as part of a
weekly maintenance job.  DON'T DO THIS!  If your RACF dataset
happens to get damaged, then your RESCUE system gets damaged too.
Get the RESCUE system up and working, and then leave it alone.
It should not be touched unless you really need to, such as if
the IO configuration changes, and you need to update the IODF
file to reflect the new devices.

------------------------------------------------------------------*
Example of using the stand alone RESCUE restore tape. You would
only use this in the event that you could not IPL a workable
OS390 system, and had to restore the rescue system. If you have
a working OS/390 system, you can log on and do a normal DFDSS batch
RESTORE job using these tapes.
(In this example, the disk drive is unit 120, the tape is 380)
------------------------------------------------------------------*
 1) Mount the first tape written on the tape drive (380)
 2) At the HMC set the IPL address to 380.  If you don't have an
    HMC, then set the IPL address according to your particular CPU.
 3) Perform an IPL (LOAD CLEAR)
 4) From any attached local terminal hit the Enter key. You should be
    prompted to hit CLEAR when the program is ready to go. Do so.
 5) Specify CONSOLE for the input device.
 6) Specify CONSOLE for the output device.
 7) Enter the restore command:
       RESTORE FROMDEV(3400) FROMADDR(380) TOADDR(120) NOVFY
 8) Reply Y when prompted to restore the volume.  Make sure it's the
    right disk unit, or you may destroy some live data.
 9) Keep mounting tapes until they have all been read.
10) Change the IPL address to 120, and IPL again. You're (hopefully) up.
11) Log on to TSO, and save the day.
./ ADD NAME=$BUILD   0105-02207-02289-1102-00026-00027-00000-ITSCXB
//$BUILD   JOB ZZTS0000Z,'CHRIS BUCKLEY',CLASS=S,MSGCLASS=X,REGION=8M,
// NOTIFY=&SYSUID,COND=(0,NE)
/*JOBPARM LINES=900000
//*---------------------------------------------------------------*
//* Execute TSO in batch to run RESCUE execs.                     *
//*---------------------------------------------------------------*
//* Before running this job, The name of the PDS containing the   *
//* RESCUE execs and members MUST be coded in the SYSPROC         *
//* statement below.                                              *
//*---------------------------------------------------------------*
//TSO      EXEC PGM=IKJEFT01,REGION=4M,PARM='RESCUE'
//SYSPRINT DD SYSOUT=*
//SYSIN    DD DUMMY
//SYSTSPRT DD SYSOUT=*
//SYSPROC  DD DISP=SHR,DSN=TSOUSER1.RESCUE.CNTL
//SYSTSIN  DD DUMMY
//*-------------------------------------------------------------------*
//COMPRESS EXEC PGM=IEFBR14 IEBCOPY
//SYSUT3   DD  UNIT=VIO,SPACE=(CYL,(5,5))
//SYSUT4   DD  UNIT=VIO,SPACE=(CYL,(5,5))
//I        DD  DISP=SHR,DSN=TSOUSER1.RESCUE.CNTL
//SYSPRINT DD  DUMMY SYSOUT=*
//* COPY INDD=((INDD,R)),OUTDD=OUTDD
//* COPY INDD=INDD,OUTDD=OUTDD
//SYSIN DD  *
 COPY INDD=I,OUTDD=I
./ ADD NAME=$SAREST  0101-02207-03007-1045-00035-00035-00000-ITSCXB
//$SAREST  JOB ZZTS0000Z,'CHRIS BUCKLEY',CLASS=S,MSGCLASS=X,REGION=8M,
// NOTIFY=&SYSUID,TYPRUN=HOLD
//*------------------------------------------------------------------*
//* $SAREST - Build an IPL'able, stand alone restore tape for the
//* RESCUE system.
//*------------------------------------------------------------------*
//* IMPORTANT: See member $$$SARES notes and discussion.
//*------------------------------------------------------------------*
//*************************************************
//* Write standalone DFDSS image in file 1        *
//*************************************************
//SADSS   EXEC PGM=ADRDSSU,PARM='UTILMSG=YES'
//SAMODS    DD DSN=SYS1.SADRYLIB,DISP=SHR
//TAPE      DD UNIT=CART,DISP=(NEW,PASS),
//          DCB=(RECFM=FB,LRECL=80,BLKSIZE=80),
//          LABEL=(1,NL,EXPDT=98000),
//          VOL=(,RETAIN,SER=RESCU1)
//SYSPRINT  DD SYSOUT=*
//SYSIN     DD *
   BUILDSA -
       INDD(SAMODS) -
       OUTDD(TAPE)  -
       ADMINISTRATOR -
       IPL(CARD) -
       OPERCNSL(001F)
//*************************************************
//* Write volume dump image in file 2             *
//*************************************************
//DUMP     EXEC PGM=ADRDSSU,REGION=4M
//SYSPRINT  DD SYSOUT=*
//TAPE      DD UNIT=CART,DISP=(NEW,PASS),
//          LABEL=(2,NL,EXPDT=98000),
//          VOL=REF=*.SADSS.TAPE
//SYSIN     DD *
  DUMP INDYNAM(RESCUE) OUTDD(TAPE)
./ ADD NAME=@DATASET 0147-02207-03008-1743-00294-00256-00000-ITSCXB
*--------------------------------------------------------------------*
*  Dataset Definitions:                                              *
*--------------------------------------------------------------------*
*  Parms for dataset entries are as follows:                         *
*  uuu,pppp,sss,ddd,m,dsn1,dsn2,(parms)                              *
*  ------------------------------                                    *
*  uuu   - Allocation unit, such as CYL,TRK, etc. (copy mode C,G,N)  *
*  pppp  - Primary allocation (copy mode C,G,N)                      *
*  sss   - Secondary allocation (copy mode C,G,N)                    *
*  dir   - Directory blocks (copy mode C,G,N)                        *
*  m     - Method of copy:                                           *
*          C - IEBCOPY                                               *
*          D - DFDSS                                                 *
*          G - IEBGENER                                              *
*          H - HFS file copy via DFDSS DUMP & RESTORE (See notes in  *
*              $$$MAINT member about maintenance needed for this.)   *
*          N - No copy, allocate only                                *
*          X - Do nothing, used as a flag for internal processing.   *
*  dsn1  - Name of dataset to be copied or defined.  If copy mode    *
*          "N" is specified, this dataset is not copied, but used    *
*          only as a model for allocating the dataset.               *
*  dsn2  - Name of dataset on the target system, if it is to be      *
*          different from dsn1.  If this parameter is omitted, the   *
*          the dataset will be named to the value specified in dsn1. *
*  parms - Flags to indicate special handling:                       *
*          OMVSxxxx  - BPXPRMxx member will mount this file at mount *
*                    - point xxxx. e.g. OMVS/etc.  OMVS/ will define *
*                    - the ROOT filesystem, and generate a ROOT stmt.*
*          APF       - Added to PROGA0 for APF authorization.        *
*          LNK       - Added to PROGL0 for linklst.                  *
*          LPA       - Added to LPALST00 PARMLIB member.             *
*          RLSE      - Excess space released after copy.  This helps *
*                      fit the system into minimum space.            *
*          ISPxLIB   - Lib added to ISPxLIB DD in TSO PROC.          *
*          SYSPROC   - Lib added to SYSPROC DD in TSO PROC.          *
*          SYSHELP   - Lib added to SYSHELP DD in TSO PROC.          *
*          SYSLBC    - Lib added to SYSLBC DD in TSO PROC.           *
*          JES2      - Lib added to PROC00 DD in JES2 PROC.          *
*          VTAMLST   - Lib added to VTAMLST DD in VTAM PROC.         *
*          VTAMLIB   - Lib added to VTAMLIB DD in VTAM PROC.         *
*          IPLPARM   - Lib where LOAD00 member will be created.      *
*          PARMLIB   - PARMLIB to be added to SYS1.IPLAPRM(LOAD00).  *
*--------------------------------------------------------------------*
*  Parms for member COPY operations are as follows:                  *
*  The source and target PDS libraries must be specified before any  *
*  member copy statements are coded.  First code a COPY with IN=     *
*                                                                    *
*  First code a COPY with IN= and OUT= parms:                        *
*  and OUT= parms:                                                   *
*     COPY IN=<source PDS>,OUT=<Target PDS>                          *
*  Then code one or more COPY member statments, as below:            *
*     COPY M=memname                                                 *
*     COPY M=(memname)                                               *
*     COPY M=(memname,newmemname)                                    *
*                                                                    *
*  Each COPY member statement uses the IN= and OUT= libraries set in *
*  the preceeding COPY IN=,OUT= statement.                           *
*                                                                    *
*  An IEBCOPY job will be created that copies the members defined in *
*  all the COPY statements.                                          *
*--------------------------------------------------------------------*
*--------------------------------------------------------------------*
*  REQUIRED - DON'T ALTER THE NEXT SET OF ENTRIES FROM HERE UNTIL    *
*     |       THE NEXT COMMENT BLOCK. THESE ARE BASIC PARTS OF THE   *
*     |       RESCUE SYSTEM BUILD PROCESS, AND THE EXEC MAY BREAK IF *
*     V       THESE STATEMENTS ARE ALTERED.                          *
*--------------------------------------------------------------------*
 CYL,0001,000,015,N,SYS1.IPLPARM,,(IPLPARM)
 CYL,0001,001,015,N,SYS1.PARMLIB,SYS1.RESCUE.CLIST,(SYSPROC)
 CYL,0001,001,015,N,SYS1.PARMLIB,SYS1.RESCUE.ISPPLIB,(ISPPLIB)
 CYL,0001,001,015,N,SYS1.PARMLIB,SYS1.RESCUE.PARMLIB,(PARMLIB)
 CYL,0001,001,025,N,SYS1.LINKLIB,SYS1.RESCUE.LINKLIB,(APF,LNK)
 CYL,0001,001,015,N,SYS1.PROCLIB,SYS1.RESCUE.PROCLIB,(JES2)
 COPY IN=&RESCUE,OUT=SYS1.RESCUE.CLIST
    COPY M=(ZISPALOC,ISPALLOC)
 COPY IN=&RESCUE,OUT=SYS1.RESCUE.ISPPLIB
    COPY M=(ZISRPRIM,ISR@PRIM)
 COPY IN=&RESCUE,OUT=SYS1.RESCUE.PARMLIB
    COPY M=(BPXPRM00)
    COPY M=(COFVLF00)
    COPY M=(ZCOMMND,COMMND00)
    COPY M=(ZIEALPA,IEALPA00)
    COPY M=(ZIEAPAK,IEAPAK00)
    COPY M=(ZIEASVC,IEASVC00)
    COPY M=(ZIEASYS,IEASYS00)
    COPY M=(ZIEFSSN,IEFSSN00)
    COPY M=(IGDSMS00)
    COPY M=(JES2PARM)
    COPY M=(LPALST00)
    COPY M=(ZMPFLST,MPFLST00)
    COPY M=(MSTJCL01)
    COPY M=(PROGA0)
    COPY M=(PROGL0)
    COPY M=(SMFPRM00)
    COPY M=(ZTSOKEY,TSOKEY00)
    COPY M=(ZVATLST,VATLST00)
 COPY IN=&RESCUE,OUT=SYS1.RESCUE.PROCLIB
    COPY M=(ZTSO,TSO)
    COPY M=(VTAM)
    COPY M=(JES2)
    COPY M=(&TSOPROC)
 COPY IN=&RESCUE,OUT=SYS1.IPLPARM
    COPY M=LOAD00
*--------------------------------------------------------------------*
*  END OF REQUIRED STATEMENTS.                                       *
*--------------------------------------------------------------------*
*--------------------------------------------------------------------*
*  OMVS Datasets:                                                    *
*--------------------------------------------------------------------*
 OMVS,,,,H,OMVS.ROOT.ZOSRAA,OMVS.ROOT,(OMVS/)
 OMVS,,,,H,OMVS.ETC.ZOSRAA,OMVS.ETC,(OMVS/etc)
*--------------------------------------------------------------------*
*  Our system definition data sets:                                  *
*--------------------------------------------------------------------*
 CYL,0000,000,000,D,SYS1.IODF00.CLUSTER
 CYL,0000,000,000,D,SYS1.IODF01.CLUSTER
 CYL,0001,001,000,X,SYS9.SMS.RESC.COMMDS,,(COMMDS)
 CYL,0000,000,000,D,SYS9.SMS.IPO2.ACDS,SYS9.SMS.RESC.ACDS,(ACDS)
 CYL,0000,000,000,D,SYS9.SMS.IPO2.SCDS,SYS9.SMS.RESC.SCDS
 CYL,0000,000,000,D,SYS9.ACS.CNTL
*--------------------------------------------------------------------*
*  Our system datasets that go before the SYS1 ones                  *
*--------------------------------------------------------------------*
 CYL,0010,005,200,D,SYS2.XXXXXXXX.PARMLIB,,(PARMLIB)
 CYL,0030,010,250,D,SYS2.XXXXXXXX.PROCLIB,,(JES2)
 CYL,0160,0025,100,D,SYS2.XXXXXXXX.VTAMLST,,(VTAMLST)
 CYL,0010,0002,125,D,SYS2.XXXXXXXX.VTAMLIB,,(RLSE,VTAMLIB,APF)
*--------------------------------------------------------------------*
*  MVS Datasets:                                                     *
*--------------------------------------------------------------------*
 CYL,0000,000,000,D,SYS1.LINKLIB,,(RLSE,APF,LNK)
 CYL,0010,001,025,D,SYS1.SHASLINK,,(RLSE,LNK,APF)
 CYL,0010,001,025,D,SYS1.SHASMIG,,(RLSE,LNK,APF)
 CYL,0090,000,550,D,SYS1.LPALIB,,(RLSE)
 CYL,0140,005,350,D,SYS1.MACLIB,,(RLSE)
 CYL,0020,001,250,D,SYS1.MIGLIB,,(RLSE,APF)
 CYL,0050,000,250,D,SYS1.NUCLEUS
 CYL,0002,000,050,D,SYS1.PARMLIB,,(PARMLIB)
 CYL,0002,000,050,D,SYS1.IBM.PARMLIB,,(PARMLIB)
 CYL,0002,001,150,D,SYS1.PROCLIB,,(JES2)
 CYL,0002,001,150,D,CPAC.PROCLIB,,(JES2)
 CYL,0002,001,150,D,SYS1.IBM.PROCLIB,,(JES2)
 CYL,0050,001,250,D,SYS1.SAMPLIB,,(RLSE)
 CYL,0002,001,150,D,SYS1.SVCLIB,,(RLSE)
 CYL,0002,001,150,D,SYS1.UADS,,(SYSUADS)
 CYL,0003,000,000,D,SYS1.BRODCAST,,(SYSLBC)
 CYL,0010,000,000,N,SYS1.HASPCKPT
 CYL,0100,000,000,N,SYS1.HASPACE
 CYL,0010,000,000,N,SYS1.LOGREC,,(LOGREC)
 CYL,0020,000,000,X,SYS1.MANX,,(SMF)
 CYL,0010,000,000,X,SYS1.MANY,,(SMF)
 CYL,0010,000,000,X,SYS1.MANZ,,(SMF)
 CYL,0060,000,000,N,SYS1.DUMP00,,(DUMP)
 CYL,0060,000,000,N,SYS1.DUMP01,,(DUMP)
 CYL,0005,001,150,D,SYS1.CSSLIB,,(RLSE,LNK)
 CYL,0000,000,000,D,EOY.SEOYLOAD,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,EOX.SEPHLOD1,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,GIM.SGIMLMD0,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,CEE.SCEERUN,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,CEE.SCEERUN2,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,IMO.SIMOMOD1,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,ISP.SISPSASC,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,FFST.SEPWMOD2,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,FFST.SEPWMOD4,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,SYS1.SICELINK,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,SYS1.SORTLIB,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,IOE.SIOELMOD,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,SYS1.SIOALMOD,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,CBC.SCLBDLL,,(RLSE,LNK,APF)
 CYL,0030,000,050,D,SYS1.SERBLINK,,(RLSE,LNK,APF)
 CYL,0010,000,010,D,CEE.SCEELPA,,(RLSE,LNK,APF,LPA)
 CYL,0001,000,005,D,SYS1.SERBLPA,,(RLSE,APF,LPA)
 CYL,0005,000,150,D,SYS1.CMDLIB,,(RLSE,LNK)
 CYL,0001,000,000,D,SYS1.DAE
 CYL,0008,001,150,D,SYS1.HELP,,(RLSE,SYSHELP)
 CYL,0002,000,150,D,SYS1.IMAGELIB,,(RLSE)
 CYL,0001,000,005,D,SYS1.SDWWDLPA,,(RLSE,APF,LPA)
*--------------------------------------------------------------------*
* HCD ISPF libraries                                                 *
*--------------------------------------------------------------------*
 CYL,0000,000,000,D,SYS1.SCBDHENU,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,SYS1.SCBDCLST,,(RLSE,SYSPROC)
 CYL,0000,000,000,D,SYS1.SCBDMENU,,(RLSE,ISPMLIB)
 CYL,0000,000,000,D,SYS1.SCBDPENU,,(RLSE,ISPPLIB)
 CYL,0000,000,000,D,SYS1.SCBDTENU,,(RLSE,ISPTLIB)
*--------------------------------------------------------------------*
* ISPF Libraries                                                     *
*--------------------------------------------------------------------*
 CYL,0001,0001,125,D,ISP.SISPTENU,,(RLSE,ISPTLIB)
 CYL,0002,0001,125,D,ISP.SISPSLIB,,(RLSE,ISPSLIB)
 CYL,0003,0001,150,D,ISP.SISPMENU,,(RLSE,ISPMLIB)
 CYL,0006,0001,125,D,ISP.SISPSENU,,(RLSE,ISPSLIB)
 CYL,0008,0001,075,D,ISP.SISPLOAD,,(RLSE,LNK,ISPLLIB)
 CYL,0025,0001,200,D,ISP.SISPPENU,,(RLSE,ISPPLIB)
 CYL,0025,0001,200,D,ISP.SISPCLIB,,(RLSE,SYSPROC)
 CYL,0035,0001,075,D,ISP.SISPLPA,,(RLSE,APF,LPA)
 CYL,0025,0001,200,D,CPAC.ISPPLIB,,(RLSE,ISPPLIB)
*--------------------------------------------------------------------*
* TCPIP datasets                                                     *
*--------------------------------------------------------------------*
 CYL,0030,000,010,D,TCPIP.SEZALPA,,(RLSE,APF,LPA)
 CYL,0005,001,040,D,TCPIP.SEZAMIG,,(RLSE,APF,LNK)
 CYL,0110,010,075,D,TCPIP.SEZALINK,,(RLSE,APF,LNK)
 CYL,0060,005,010,D,SYS1.TCPPARMS
 CYL,0060,005,010,D,TCPIP.SEZATCP,,(RLSE)
 CYL,0060,005,010,D,TCPIP.SEZAINST,,(RLSE,LNK)
 CYL,0001,001,010,D,TCPIP.SEZAHELP,,(SYSHELP)
 CYL,0001,001,000,D,TCPIP.ETC.RPC
 CYL,0001,001,000,D,TCPIP.ETC.SERVICES
 CYL,0001,001,000,D,TCPIP.HOSTS.ADDRINFO
 CYL,0001,001,000,D,TCPIP.HOSTS.LOCAL.RESCUE,TCPIP.HOSTS.LOCAL
 CYL,0001,001,000,D,TCPIP.HOSTS.SITEINFO
 CYL,0001,001,000,D,TCPIP.SMTPNJE.HOSTINFO
 CYL,0001,001,000,D,TCPIP.STANDARD.TCPXLBIN
 CYL,0001,001,000,D,TCPIP.TELNET.TCPXLBIN
 CYL,0001,001,000,D,TCPIP.TELNETSE.TCPXLBIN
 CYL,0001,001,000,D,TCPIP.UKD.TCPXLBIN
 CYL,0001,001,000,D,TCPIP.UKW.TCPXLBIN
*CYL,0060,005,010,D,TCPIP.SECTABLE
*--------------------------------------------------------------------*
* RACF DATASET AND ISPF LIBRARIES                                    *
*--------------------------------------------------------------------*
*  The RACF dataset is copied automatically.  Don't specify it here. *
 CYL,0002,001,150,D,SYS1.HRFCLST,,(RLSE,SYSPROC)
 CYL,0002,001,150,D,SYS1.HRFMSG,,(RLSE,ISPMLIB)
 CYL,0002,001,150,D,SYS1.HRFPANL,,(RLSE,ISPPLIB)
 CYL,0002,001,150,D,SYS1.HRFSKEL,,(RLSE,ISPSLIB)
*--------------------------------------------------------------------*
* ISMF ISPF libraries                                                *
*--------------------------------------------------------------------*
 CYL,0001,001,095,D,SYS1.DGTCLIB,,(RLSE,SYSPROC)
 CYL,0010,001,095,D,SYS1.DGTLLIB,,(RLSE,ISPLLIB)
 CYL,0002,001,095,D,SYS1.DGTMLIB,,(RLSE,ISPMLIB)
 CYL,0033,001,350,D,SYS1.DGTPLIB,,(RLSE,ISPPLIB)
 CYL,0002,001,095,D,SYS1.DGTSLIB,,(RLSE,ISPSLIB)
 CYL,0001,001,095,D,SYS1.DGTTLIB,,(RLSE,ISPTLIB)
*--------------------------------------------------------------------*
* SDSF Datasets                                                      *
*--------------------------------------------------------------------*
 CYL,0001,000,000,N,ISF.HASPINDX
 CYL,0001,001,150,D,ISF.SISFLINK,,(RLSE,LNK)
 CYL,0005,001,050,D,ISF.SISFLOAD,,(RLSE,LNK)
 CYL,0001,001,025,D,ISF.SISFLPA,,(RLSE,APF,LPA)
 CYL,0001,001,150,D,ISF.SISFMLIB,,(RLSE,ISPMLIB)
 CYL,0002,001,150,D,ISF.SISFPLIB,,(RLSE,ISPPLIB)
 CYL,0001,001,150,D,ISF.SISFTLIB,,(RLSE,ISPTLIB)
 CYL,0001,001,150,D,ISF.SISFSLIB,,(RLSE,ISPSLIB)
 CYL,0015,001,150,D,ISF.SISFSRC,,(RLSE)
*--------------------------------------------------------------------*
* JES2 IPCS data sets                                                *
*--------------------------------------------------------------------*
 CYL,0001,001,010,D,SYS1.SHASPARM,,(RLSE,PARMLIB)
 CYL,0001,001,010,D,SYS1.SHASPNL0,,(RLSE,ISPPLIB)
*--------------------------------------------------------------------*
* VTAM / NCP DATASETS                                                *
*--------------------------------------------------------------------*
 CYL,0005,0001,125,D,SYS1.VTAMLST,,(VTAMLST)
 CYL,0005,0001,125,D,SYS1.VTAMLIB,,(RLSE,VTAMLIB,APF)
 CYL,0050,0001,125,D,SYS1.SISTCLIB,,(RLSE,APF)
*--------------------------------------------------------------------*
* Local datasets - FDR
*--------------------------------------------------------------------*
 CYL,0010,002,040,D,SYS2.FDR.MODFDR53,,(RLSE,APF,LNK)
 CYL,0010,002,040,D,SYS3.FDR.MODFDR53,,(RLSE,APF)
 CYL,0001,001,010,D,SYS3.FDR.DIALOG.CLIST
 CYL,0001,001,010,D,SYS3.FDR.DIALOG.MESSAGES
 CYL,0001,001,010,D,SYS3.FDR.DIALOG.PANELS
 CYL,0001,001,010,D,SYS3.FDR.DIALOG.SKELETON
 CYL,0001,001,010,D,SYS3.FDR.ICLFDR53
 CYL,0001,001,010,D,SYS3.FDR.JCLFDR53
*--------------------------------------------------------------------*
* Local datasets - Assorted PDS's that you want on your rescue sys.  *
*--------------------------------------------------------------------*
 CYL,0003,001,050,D,SYS2.XXXXXXXX.LINKLIB,,(APF,LNK)
*
 CYL,0003,0001,015,D,SYS2.XXXXXXXX.LOADLIB,,(APF)
 CYL,0015,0005,100,D,SYS2.XXXXXXXX.CLIST,,(SYSPROC)
 CYL,0015,0005,100,D,SYS2.XXXXXXXX.ISPPLIB,,(ISPPLIB)
 CYL,0010,0005,050,D,SYS2.PARMLIB
*
 CYL,0015,0005,100,D,XXXXXXXX.CLIST,,(SYSPROC)
 CYL,0015,0005,100,D,XXXXXXXX.ISPPLIB,,(ISPPLIB)
 CYL,0015,0005,100,D,XXXXXXXX.ISPMLIB,,(ISPMLIB)
 CYL,0005,0005,100,D,TSOUSER1.ISPTABLE,TSOUSER1.ISPF.ISPPROF
 CYL,0005,0005,250,D,TSOUSER1.SYSPROG.CNTL
 CYL,0005,0005,050,D,TSOUSER1.RESCUE.CNTL
 CYL,0005,0005,100,D,TSOUSER1.DISK.CNTL
 CYL,0010,0010,250,D,TSOUSER1.SYSPROG.REXX
 CYL,0005,0005,100,D,TSOUSER2.ISPTABLE,TSOUSER2.ISPF.ISPPROF
 CYL,0005,0005,100,D,TSOUSER2.JCL.CNTL
 CYL,0005,0005,100,D,TSOUSER3.ISPTABLE,TSOUSER3.ISPF.ISPPROF
 CYL,0005,0005,100,D,PROD.STORAGE.RUNDECKS
 CYL,0005,0005,100,D,SYS3.DASD.UTILS
*CYL,0005,0005,100,D,SYS9.DISASTER.RECOVERY.?
./ ADD NAME=@PARMS   0124-02207-03007-1043-00093-00092-00000-ITSCXB
/*-------------------------------------------------------------------*
/* Jobcard info.  "COMMENT" is placed in each job.                   *
/* Jobname must be 7 chars or less to allow job char to be added.    *
/*-------------------------------------------------------------------*
 JOBCARD1   = //RESCUE   JOB ZZTS0000Z,DR,CLASS=X,MSGCLASS=X,
 JOBCARD2   = // NOTIFY=&SYSUID,REGION=8M,COND=(0,NE)
 COMMENT    = Chris Buckley

/*-------------------------------------------------------------------*
/* Date format - specify E for European or U for USA.                *
/*-------------------------------------------------------------------*
 DATEFMT    = E

/*-------------------------------------------------------------------*
/* TSO PROC and Userids to be created on the new system.             *
/* TSOPROC should NOT exist on the driving system.                   *
/*-------------------------------------------------------------------*
 TSOPROC    = IKJACCNT                /* TSOPROC to be built.
 TSOID1     = TSOUSER1                /* TSO IDs to be defined on the
 TSOID2     = TSOUSER2                /* rescue system.
 TSOID3     = TSOUSER3

/*-------------------------------------------------------------------*
/* Assorted other parms.                                             *
/* 2nd volume is only built if ADDR not = ADDR2                      *
/*-------------------------------------------------------------------*
 ADDR       = 187F                    /* Unit addr of RESCUE volume.
 DEVTYPE    = 3390                    /* Unit of RESCUE volume.
 VOLSER     = RESCUE                  /* VOLSER of RESCUE volume.
 ADDR2      = 187F                    /* Unit addr of RESCUE HFS volume.
 VOLSER2    = RESCUE                  /* Volser for HFS files.

 SSA        = SYSR.                   /* Temp. dsn prefix used to
                                      /* avoid ENQ problems.

/*-------------------------------------------------------------------*
/* IOCONFIGID - Use HCD to be sure this value is defined as a valid  *
/* IOCONFIG ID in the IODF dataset that you specify.                 *
/*-------------------------------------------------------------------*
 IODF       = SYS1.IODF01.CLUSTER     /* IODF dataset name.
 IOCONFIGID = MVS1                    /* 8 char IO config ID for LOADxx
 EDTID      = 00                      /* 2 char EDT ID for LOADxx

 SMFID      = RESC                    /* 4 char SMF id for new system.
 NEWMCAT    = CATALOG.RESCUE          /* Rescue sys. mastercat name.
 OLDMCAT    = CATALOG.OS390R9.MASTER  /* Driving sys master cat.
 SYSRES     = ZOSRAA                  /* Driving sys sysres volume.
 COMMANDPGM = RESCCMD                 /* "COMMAND" pgm is available.
 WAITPGM    = RESCWAIT                /* "WAIT" pgm is available.

/*-------------------------------------------------------------------*
/* JES2 Parms.  A SPOOLDEF and CKPTDEF entry will be added to the    *
/* ZJES2PRM member to create a final JES2PARM member.                *
/*-------------------------------------------------------------------*
 SPOOLVOL   = RESC                    /* SPOOLDEF prefix.
 CHKPOINT   = SYS1.HASPCKPT           /* JES2 Ckpt dataset name.
 SPOOL      = SYS1.HASPACE            /* JES2 spool ds name.

/*-------------------------------------------------------------------*
/* RACF Parms.                                                       *
/* Note: Some of the RACF actions require RACF SPECIAL to perform.   *
/* Any TSO ID can run the RESCUE execs, but the RACF ID used to run  *
/* the resulting jobs will need RACF SPECIAL, or specific privileges *
/* for various RACF operations (CLAUTH, etc.)                        *
/*-------------------------------------------------------------------*
/*-------------------------------------------------------------------*
/* RFSTCx: Defines STCs for ICHRIN03 started task table.             *
/* p1 = Task name, p2 = RACF ID, p3 = RACF group.                    *
/* Each task defined will have privileged bit set on, so these tasks *
/* should be able to bypass most RACF Access checking.  Commands     *
/* for creating the specified IDs and Groups will be generated only  *
/* if the IDs/groups DO NOT already exist.                           *
/*-------------------------------------------------------------------*
 RACFDS     = SYS1.RACF.OS390R9       /* Driving system RF ds and vol.
 RACFVOL    =                         /* "
 RFDSNT     = YES                     /* Create RACF ICHRDSNT
 RFSTC      = YES                     /* Create RACF ICHRIN03
 RFTSOPROC  = YES                     /* Define TSOPROC to TSOPROC class
/*-------------------------------------------------------------------*
/* Started task support:                                             *
/* If entries are defined below, then an ICHRIN03 module will be     *
/* built with these entries.  An MLPA entry for this ICHRIN03        *
/* will be placed in IEALPA00.  Format of RFSTCx is:                 *
/* RFSTCx = stcname, racfid, racfgrp                                 *
/* All three parameters are required.                                *
/*-------------------------------------------------------------------*
/* RFSTC1     = RACF,    $RESCUE, $RESCGRP
/* RFSTC2     = JES2,    $RESCUE, $RESCGRP
/* RFSTC3     = JES2BACK,$RESCUE, $RESCGRP
/* RFSTC4     = VTAM,    $RESCUE, $RESCGRP
/* RFSTC5     = TSO,     $RESCUE, $RESCGRP
/* RFSTC6     = TCPIP,   $RESCUE, $RESCGRP
/* RFSTC7     = OMVS,    $RESCUE, $RESCGRP
./ ADD NAME=BPXPRM00
/*-------------------------------------------------------*/
/* OMVS parameters.                                      */
/* Built dynamically by RESCUE exec, 19/09/2002 12:09            */
/*-------------------------------------------------------*/
FILESYSTYPE TYPE(HFS)
            ENTRYPOINT(GFUAINIT)
            PARM(' ')

FILESYSTYPE TYPE(TFS)
            ENTRYPOINT(BPXTFS)

   MAXPROCSYS(900)
   MAXPROCUSER(100)
   MAXUIDS(200)
   MAXFILEPROC(2000)
   MAXPTYS(800)
   CTRACE(CTIBPX00)
   FILESYSTYPE TYPE(UDS) ENTRYPOINT(BPXTUINT)
   NETWORK DOMAINNAME(AF_UNIX)
           DOMAINNUMBER(1)
           MAXSOCKETS(2000)
           TYPE(UDS)
   FILESYSTYPE TYPE(INET) ENTRYPOINT(EZBPFINI)
   NETWORK DOMAINNAME(AF_INET)
           DOMAINNUMBER(2)
           MAXSOCKETS(64000)
           TYPE(INET)
   MAXTHREADTASKS(1000)
   MAXTHREADS(500)
   IPCMSGNIDS    (500)
   IPCMSGQBYTES  (2147483647)
   IPCMSGQMNUM   (10000)
   IPCSHMNIDS    (500)
   IPCSHMSPAGES  (262144)
   IPCSHMMPAGES  (25600)
   IPCSHMNSEGS   (500)
   IPCSEMNIDS    (500)
   IPCSEMNSEMS   (1000)
   IPCSEMNOPS    (25)
   MAXMMAPAREA(40960)
   MAXCORESIZE(4194304)
   MAXASSIZE(209715200)
   MAXCPUTIME(1000)
   MAXSHAREPAGES(131072)
   FORKCOPY(COW)
   SUPERUSER(BPXROOT)
   TTYGROUP(TTY)
   STARTUP_PROC(OMVS)
   SYSCALL_COUNTS(NO)
   MAXQUEUEDSIGS(1000)
   SYSPLEX(NO)
   SHRLIBRGNSIZE(67108864)
   SHRLIBMAXPAGES(4096)

ROOT     FILESYSTEM('OMVS.ROOT')
         TYPE(HFS)
         MODE(RDWR)

MOUNT    FILESYSTEM('OMVS.ETC')
         MOUNTPOINT('/etc')
         TYPE(HFS)
         MODE(RDWR)

./ ADD NAME=COFVLF00
/*-------------------------------------------------------*/
/* VLF parameters.                                       */
/* Built dynamically by RESCUE exec, 19/09/2002 12:09            */
/*-------------------------------------------------------*/
CLASS NAME(CSVLLA)
      EMAJ(LLA)
      MAXVIRT(4096)
CLASS NAME(IRRGTS)
      EMAJ(GTS)
      MAXVIRT(256)
CLASS NAME(IRRACEE)
      EMAJ(ACEE)
CLASS NAME(IKJEXEC)
      EDSN(SYS1.RESCUE.CLIST)
      EDSN(SYS1.SCBDCLST)
      EDSN(ISP.SISPCLIB)
      EDSN(SYS1.HRFCLST)
      EDSN(SYS1.DGTCLIB)
      EDSN(SYS2.XXXXXXXX.CLIST)
      EDSN(XXXXXXXX.CLIST)
      MAXVIRT(256)
CLASS NAME(IRRGMAP)
      EMAJ(GMAP)
CLASS NAME(IRRUMAP)
      EMAJ(UMAP)
CLASS NAME(IRRSMAP)
      EMAJ(SMAP)
./ ADD NAME=COMMAND  0103-02207-02207-1614-00400-00400-00000-*BASE*
//COMMAND  JOB ZZTS0000Z,'CHRIS BUCKLEY',CLASS=S,MSGCLASS=X,REGION=4M
//ASMHCL   EXEC  ASMACL,PARM.L='MAP,LET,LIST,NCAL,AC=1'
//C.SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//           DD  DSN=SYS1.AMODGEN,DISP=SHR
//C.SYSIN    DD  *
COMMAND  TITLE 'C O M M A N D  --  ISSUE SYSTEM OPERATOR COMMANDS V2.0'
***********************************************************************
*                                                                     *
*                           C O M M A N D                             *
*                                                                     *
*                   ISSUE SYSTEM OPERATOR COMMANDS                    *
*                                                                     *
***********************************************************************
*                                                                     *
* NOTE: This version has RACHECK code added to be sure that the       *
* caller has at least READ access to the COMMAND profile of the       *
* APPL RACF class.  To permit use of the COMMAND command:             *
*                                                                     *
*    RDEFINE APPL COMMAND UACC(NONE)                                  *
*    PERMIT  COMMAND CLASS(APPL) ID(userid)                           *
*                                                                     *
***********************************************************************
*                                                                     *
*     THIS PROGRAM ACCEPTS SYSTEM OR JES OPERATOR COMMANDS AS         *
*     INPUT AND EXECUTES THEM USING SVC 34. IT MUST BE APF            *
*     AUTHORIZED.                                                     *
*                                                                     *
*     COMMAND CAN OPERATE IN ONE OF THREE MODES:                      *
*                                                                     *
*     1) BATCH OR CALLED PROGRAM                                      *
*        IN THIS MODE COMMAND ACCEPTS INPUT AS EITHER 80-BYTE         *
*        CARD IMAGES FROM SYSIN OR A SINGLE COMMAND FROM THE PARM     *
*        FIELD. THE RESPONSE TO THE OPERATOR COMMAND WILL             *
*        APPEAR ON ALL OPERATOR CONSOLES. FOR EXAMPLE:                *
*                                                                     *
*           //STEP1    EXEC PGM=COMMAND,PARM='VARY 017,ONLINE'        *
*                                                                     *
*           - OR -                                                    *
*                                                                     *
*           //STEP1    EXEC PGM=COMMAND                               *
*           //SYSIN    DD *                                           *
*           VARY 017,ONLINE                                           *
*           /*                                                        *
*                                                                     *
*        IF COMMANDS ARE FETCHED FROM SYSIN, A DELAY OF 2 SECONDS     *
*        WILL BE ADDED BETWEEN COMMANDS.                              *
*                                                                     *
*     2) TSO COMMAND PROCESSOR                                        *
*        IN THIS MODE COMMAND EXPECTS TO FIND THE OPERATOR COMMAND    *
*        DIRECTLY FOLLOWING ON THE TSO INPUT LINE. THE RESPONSE TO    *
*        OS COMMANDS WILL THEN BE DISPLAYED ON THE TSO TERMINAL.      *
*        RESPONSE TO JES COMMANDS WILL APPEAR ON YOUR TERMINAL        *
*        PROVIDED A LOCAL MODIFICATION IS MADE TO JES2 TO ALLOW       *
*        IT TO INTERCEPT THE COMMAND AND SET THE RESPONSE TO TSO.     *
*        OTHERWISE, JES2 COMMANDS WILL APPEAR ON ALL CONSOLES.        *
*        FOR EXAMPLE:                                                 *
*                                                                     *
*           COMMAND D T         <--- (RESPONSE WILL APPEAR ON CRT)    *
*                                                                     *
*     3) CALLABLE SUBROUTINE                                          *
*        IN THIS MODE COMMAND ACCEPTS INPUT ACCORDING TO STANDARD     *
*        OS LINKAGE CONVENTIONS. IN ADDITION TO THE COMMAND ITSELF,   *
*        A SECOND PARAMETER MAY BE PASSED WHICH CONTAINS THE          *
*        CONSOLE NUMBER WHERE YOU WISH THE RESPONSE TO APPEAR.        *
*        (THE SVC 34 WILL ALSO ASSUME THE AUTHORITY OF THAT           *
*        CONSOLE.) FOR EXAMPLE:                                       *
*                                                                     *
*           LA       R1,CMDADDR                                       *
*           LA       R15,=V(COMMAND)                                  *
*           BALR     R14,R15                                          *
*                                                                     *
*           CMDADDR  DC    A(OPERCMD)                                 *
*           CNSADDR  DC    XL1'80',AL3(CONSOLE)                       *
*           OPERCMD  DC    H(3),CL3'D T'                              *
*           CONSOLE  DC    F'5'                                       *
*                                                                     *
*        THIS WOULD MAKE IT APPEAR AS IF 'D T' WERE ISSUED FROM       *
*        CONSOLE 5. (THIS METHOD IS USED BY PROGRAM 'SPY')            *
*                                                                     *
*        COMMAND MAY BE USED TO ISSUE REPLIES TO WTORS.               *
*                                                                     *
*     AUTHOR:                                                         *
*       THE ORIGINAL VERSION OF COMMAND WAS WRITTEN BY MARK SORKIN.   *
*       THE CURRENT VERSION HAS BEEN HEAVILY MODIFIED AT SCE.         *
*       QUESTIONS AND COMMENTS MAY BE SENT TO                         *
*                                                                     *
*          STEVE LANGLEY                                              *
*          SOUTHERN CALIFORNIA EDISON                                 *
*          P.O. BOX 800                                               *
*          ROSEMEAD, CALIF. 91770                                     *
*          1-213-572-3435                                             *
*                                                                     *
*     IMPLEMENTOR:                                          *HMD 07/81*
*       THIS PROGRAM HAS BEEN REVISED AND IMPLEMENTED AT    *HMD 07/81*
*       GTE DATA SERVICES, MARINA DEL REY, CA BY:           *HMD 07/81*
*                                                           *HMD 07/81*
*          HOWARD M. DEAN                                   *HMD 07/81*
*          GTE DATA SERVICES                                *HMD 07/81*
*          4750 LINCOLN BLVD.                               *HMD 07/81*
*          MARINA DEL REY, CALIF. 90291                     *HMD 07/81*
*          PHONE - (213) - 821-0511                         *HMD 07/81*
*                                                           *HMD 07/81*
*       CHANGES MADE BY THE ABOVE ARE MARKED WITH           *HMD 07/81*
*       '*HMD XX/XX*' IN COL 61-71. XX/XX IS THE            *HMD 07/81*
*       CHANGE DATE (MONTH AND YEAR).                       *HMD 07/81*
***********************************************************************
         EJECT
COMMAND  CSECT
         SPACE 3
R0       EQU   0                  REGISTER 0
R1       EQU   1                  REGISTER 1
R2       EQU   2                  WORK REGISTER
R3       EQU   3                  WORK REGISTER
R4       EQU   4                  WORK REGISTER
R5       EQU   5                  WORK REGISTER
R6       EQU   6                  WORK REGISTER             *HMD 07/81*
R7       EQU   7                  WORK REGISTER             *HMD 07/81*
R8       EQU   8                  WORK REGISTER             *HMD 07/81*
R9       EQU   9                  WORK REGISTER             *HMD 07/81*
R10      EQU   10                 PARAMETER LIST ADDRESS REGISTER
R11      EQU   11                 SUBROUTINE LINKAGE REGISTER
R12      EQU   12                 BASE REGISTER
R13      EQU   13                 SAVE AREA ADDRESS REGISTER
R14      EQU   14                 REGISTER 14
R15      EQU   15                 REGISTER 15
         EJECT
         SAVE  (14,12)            SAVE CALLER'S REGISTERS
         LR    R12,R15            ESTABLISH
         USING COMMAND,R12        ADDRESSABILITY
         LA    R3,SAVEAREA        GET OUR SAVEAREA ADDRESS
         ST    R13,SAVEAREA+4     ESTABLISH BACK
         ST    R3,8(R13)          AND FORWARD SAVEAREA POINTERS
         LR    R13,R3             ESTABLISH OUR SAVEAREA ADDRESS
         LR    R10,R1             SAVE PARAMETER REGISTER
         SPACE 2
*********************************************************** *CKO 07/92*
* Determine whether user is authorized to the application   *CKO 07/92*
*********************************************************** *CKO 07/92*
*ACHK    EQU  *                                             *CKO 07/92*
*        RACHECK ENTITY=(CMDENT),CLASS=CMDCLS,ATTR=READ     *CKO 07/92*
*        LTR  R15,R15             Authorized to this prog?  *CKO 07/92*
*        BNZ  NOTAUTH             Nope.                     *CKO 07/92*
         SPACE 2                                            *CKO 07/92*
         L     R2,CVTPTR          R2 = ADDR OF CVT
         USING CVT,R2
         L     R3,CVTTCBP         R3 = ADDR OF MAGIC QUADWORD
         L     R4,12(R3)          R4 = ADDR OF OUR ASCB
         USING ASCB,R4
         MVC   ASID,ASCBASID      SAVE OUR ASID
         DROP  R4
         L     R4,CVTCUCB         ADDR OF 'CUCB' (UCM BASE) *HMD 07/81*
         DROP  R2                 NO NEED FOR CVT BASE NOW  *HMD 07/81*
         USING UCM,R4             ADDRESS THE UCM           *HMD 07/81*
         LR    R2,R4              R2 = R4                   *HMD 07/81*
         S     R2,=F'4'           R2 = ADDR OF ADDR OF UCMP *HMD 07/81*
         L     R2,0(R2)           R2 = ADDR OF UCM PREFIX   *HMD 07/81*
         USING UCMPRFX,R2         ADDRESS THE PREFIX        *HMD 07/81*
         L     R5,UCMVEA          R5 = ADDR OF 1ST UCM ENTRY*HMD 07/81*
         L     R6,UCMVEZ          R6 = LNGTH OF EACH ENTRY  *HMD 07/81*
         L     R7,UCMVEL          R7 = ADDR OF LAST UCM ENT.*HMD 07/81*
         SLR   R8,R8              R8 = CONSOLE COUNTER      *HMD 07/81*
UCMLOOP  LA    R8,1(R8)           R8 = CONSOLE NUMBER       *HMD 07/81*
         C     R5,UCMMCENT        IS THIS THE MASTER CON    *HMD 07/81*
         BNE   UCMNEXT            NO, CONTINUE LOOKING      *HMD 07/81*
         ST    R8,R0MASK          SAVE MSTR CONSOLE NUMBER  *HMD 07/81*
         B     INITDONE           DONE WITH THIS NOW        *HMD 07/81*
UCMNEXT  AR    R5,R6              BUMP TO NEXT UCM ENTRY    *HMD 07/81*
         CR    R5,R7              END OF UCM'S?             *HMD 07/81*
         BL    UCMLOOP            NO, CONTINUE              *HMD 07/81*
         DROP  R2,R4              GET RID OF BASES          *HMD 07/81*
         SPACE 3
INITDONE DS    0H                 CHECK OUT INPUT PARM
         MVI   CARD,C' '          CLEAR OUT COMMAND AREA    *HMD 07/81*
         MVC   CARD+1(L'CARD-1),CARD                        *HMD 07/81*
         TM    0(R10),X'80'       IS FIRST THE ONLY PARM?
         BO    ONEPARM            YES; ONLY PARM
         TM    4(R10),X'80'       IS SECOND THE LAST PARM?
         BO    TWOPARMS           YES; TWO PARMS (CALLED WITH CNXX)
***********************************************************************
*                                                                     *
*     A X'80' WAS NOT FOUND IN THE HIGH ORDER BYTE OF THE FIRST       *
*     TWO PARMS, SO WE CAN ASSUME COMMAND IS BEING CALLED AS A CP.    *
*     PLACE OUR ASID IN THE R0 MASK AND CONTINUE.                     *
*                                                                     *
***********************************************************************
         XR    R2,R2              CLEAR R2
         ICM   R2,B'0011',ASID    R2 = ASID OF CALLER
         O     R2,=XL4'00008000'  TELL SVC34 ITS AN ASID
         ST    R2,R0MASK          AND OVERRIDE THE R0 MASK
         L     R3,0(R10)          R3 = ADDR OF INPUT LINE
         LA    R4,4(R3)           R4 = ADDR OF FIRST CHAR OF INPUT
         AH    R4,2(R3)           R4 = ADDR OF FIRST CHAR PAST COMMAND
         LH    R2,0(R3)           R2 = TOTAL LENGTH OF STRING
         SH    R2,=H'4'           R2 = LENGTH MINUS HEADER  *HMD 07/81*
         SH    R2,2(R3)           R2 = LENGTH OF OPER CMD   *HMD 07/81*
         BNP   EOJ                IS NO COMMAND GOTO EOJ    *HMD 07/81*
         CH    R2,=H'100'         IS LENGTH TOO LONG?       *HMD 07/81*
         BNH   LENOK              LENGTH IS OK              *HMD 07/81*
         LA    R2,100             ONLY 1ST 100 BYTES        *HMD 07/81*
LENOK    BCTR  R2,0               R2 = R2 - 1 FOR EX MVC
         EX    R2,MOVE1           MOVE CMD INTO CARD
*************************************************************HMD 07/82*
** THE FOLLOWING CODE IS NECESSARY THE ENABLE THIS COMMAND  *HMD 07/82*
** TO WORK UNDER MVS/SP RELEASE 3. THIS IS DUE TO A CHANGE  *HMD 07/82*
** IN THE COMMAND SCHEDULER CSCB CREATION MODULE IEE0803D.  *HMD 07/82*
**                                                          *HMD 07/82*
** IN MVS/SP 3, IF AN ASID IS PRESENT IN THE XSA, THEN THE  *HMD 07/82*
** COMMAND SCHEDULER MOVES YOUR TSO USERID INTO THE NEWLY   *HMD 07/82*
** CREATED CSCB. WHY THIS IS DONE, WHO KNOWS. IT CAUSES,    *HMD 07/82*
** HOWEVER, THE STC INITIALIZATION ROUTINE IEEPRWI2 TO      *HMD 07/82*
** THINK THAT A 'SYSTEM' ADDRESS SPACE IS BEING CREATED     *HMD 07/82*
** DUE TO THE CHKEY FIELD OF THE CSCB CONTAINING YOUR       *HMD 07/82*
** USERID INSTEAD OF ZERO. BECAUSE THIS ADDRESS SPACE       *HMD 07/82*
** INITIALIZATION ROUTINE NAME FOR SYSTEM ADDRESS SPACES    *HMD 07/82*
** IS CONTAINED IN THE CHKEY FIELD, IEEPRWI2 ATTEMPT TO     *HMD 07/82*
** LINK TO YOUR TSO USERID TO INITIALIZE THE STARTED        *HMD 07/82*
** ADDRESS SPACE. THUS AN ABEND806-4 AND A RESULTING SVC    *HMD 07/82*
** DUMP.                                                    *HMD 07/82*
**                                                          *HMD 07/82*
** SINCE RESPONSE AT THE TERMINAL IS NOT REQUIRED FOR       *HMD 07/82*
** START AND MOUNT COMMANDS (AND THAT IS THE ONLY PLACE     *HMD 07/82*
** THIS CRAZY THING HAPPENS) WE WILL ISSUE THOSE COMMANDS   *HMD 07/82*
** WITH REGISTER ZERO EQUAL TO ZERO.                        *HMD 07/82*
*************************************************************HMD 07/82*
         CLC   =C'LOGON ',CARD    LOGON COMMAND?            *HMD 07/82*
         BE    EOJ                DON'T BE SILLY            *HMD 07/82*
         CLC   =C'logon ',CARD    LOGON COMMAND?            *HMD 07/82*
         BE    EOJ                DON'T BE SILLY            *HMD 07/82*
         CLC   =C'START ',CARD    IS IT A START COMMAND?    *HMD 07/82*
         BE    STARTM             YES..CLEAR R0MASK         *HMD 07/82*
         CLC   =C'S ',CARD        START COMMAND?            *HMD 07/82*
         BE    STARTM             YES, CLEAR R0MASK         *HMD 07/82*
         CLC   =C'MOUNT ',CARD    MOUNT COMMAND?            *HMD 07/82*
         BE    STARTM             YES, CLEAR R0MASK         *HMD 07/82*
         CLC   =C'M ',CARD        MOUNT COMMAND?            *HMD 07/82*
         BE    STARTM             NO COMTINUE WITH COMMANDS *HMD 07/82*
         CLC   =C'start ',CARD    L         C               *HMD 07/82*
         BE    STARTM               O          A            *HMD 07/82*
         CLC   =C's ',CARD            W            S        *HMD 07/82*
         BE    STARTM                   E             E     *HMD 07/82*
         CLC   =C'mount ',CARD            R                 *HMD 07/82*
         BE    STARTM                                       *HMD 07/82*
         CLC   =C'm ',CARD                                  *HMD 07/82*
         BNE   DOCMD              NO COMTINUE WITH COMMANDS *HMD 07/82*
STARTM   XC    R0MASK,R0MASK      CLEAR REGISTER 0 MASK     *HMD 07/82*
DOCMD    B     DOSVC34            GO DO THE COMMAND
***********************************************************************
*                                                                     *
*     X'80' WAS FOUND IN THE HIGH ORDER BYTE OF THE SECOND PARM,      *
*     SO WE HAVE BEEN CALLED AS A SUBROUTINE (MODE 3). THE SECOND     *
*     PARM CONTAINS THE CONSOLE ID WHERE THE COMMAND IS TO 'COME      *
*     FROM', SO USE THAT FOR THE R0 MASK.                             *
*                                                                     *
***********************************************************************
TWOPARMS L     R3,4(R10)          R3 = ADDR OF R0 MASK FOR SVC34
         MVC   R0MASK(4),0(R3)    SAVE R0 MASK FOR SVC34
***********************************************************************
*                                                                     *
*     ONLY ONE PARM WAS PASSED, SO WE ARE BEING CALLED IN MODE 1.     *
*     JUST ISSUE THE COMMAND FROM THE PARM STRING.                    *
*                                                                     *
***********************************************************************
ONEPARM  L     R10,0(R10)         GET PARAMETER ADDRESS
         SLR   R3,R3              CLEAR FOR ICM             *HMD 07/81*
         ICM   R3,B'0011',0(R10)  GET PARAMETER TEXT LENGTH
         BZ    USESYSIN           NO - GO GET COMMANDS FROM SYSIN
         CH    R3,=H'100'         COMMAND TOO LONG?         *HMD 07/81*
         BNH   CMDOK              NO, IS OK                 *HMD 07/81*
         LA    R3,100             ONLY DO 1ST 100 BYTES     *HMD 07/81*
CMDOK    BCTR  R3,R0              DECREMENT R3 FOR USE IN EXECUTE
         EX    R3,MOVE            EXECUTE MVC
DOSVC34  LA    R11,EOJ            GET ADDRESS FOR RETURN FROM SVC34
         B     SVC34              GO ISSUE COMMAND
         SPACE 3
***********************************************************************
*                                                                     *
*     NO PARM FIELD FOUND, SO LOOK AT SYSIN FOR INPUT                 *
*                                                                     *
***********************************************************************
USESYSIN OPEN  (SYSIN,INPUT)      OPEN SYSIN
         TM    SYSIN+DCBOFLGS-IHADCB,DCBOFOPN               *HMD 07/81*
         BZ    EOJ                IF BAD OPEN; END OF PGM   *HMD 07/81*
GETSYSIN GET   SYSIN,CARD         GET A SYSIN RECORD INTO SVC34 LIST
         MVC   CARD+72(8),CARD+80 BLANK OUT SEQUENCE FIELD IN 73-80
         CLI   CARD,C'*'          IS THIS A COMMENT?
         BE    GETSYSIN           YES;GO GET ANOTHER CARD
         LA    R11,GETSYSIN       GET ADDRESS FOR RETURN FROM SVC34
         B     SVC34              GO ISSUE COMMAND
         SPACE 3
EODSYSIN CLOSE (SYSIN)            CLOSE SYSIN
         SPACE 3
EOJ      L     R13,SAVEAREA+4     GET ADDRESS OF CALLER'S SAVEAREA
         RETURN (14,12),RC=0      RETURN TO CALLER
         SPACE 3                                            *CKO 07/92*
BADEOJ   L     R13,SAVEAREA+4     GET ADDRESS OF CALLER'S   *CKO 07/92*
         RETURN (14,12),RC=8      SAVE AREA & RETURN        *CKO 07/92*
         EJECT
***********************************************************************
*                                                                     *
*     THIS ROUTINE ACTUALLY ISSUES THE SVC 34. IT EITHER RETURNS      *
*     TO THE SYSIN-READ LOOP OR EOJ DEPENDING ON THE VALUE OF R11     *
*                                                                     *
***********************************************************************
SVC34    DS    0H
         LA    R3,CARD+L'CARD-1   POINT TO END OF TEXT      *HMD 07/81*
         LA    R4,CARD-1          POINT TO START OF TEXT    *HMD 07/81*
FINDTEXT DS    0H                 FIND LAST TEXT CHARACTER
         CR    R3,R4              ALL BLANK?
         BNH   SVC34END           YES - IGNORE IT
         CLI   0(R3),C' '         BLANK CHARACTER?
         BNE   GOTTEXT            NO - FOUND END OF TEXT
         BCT   R3,FINDTEXT        KEEP ON LOOKING
         SPACE
GOTTEXT  DS    0H                 BUILD PARAMETER LIST LENGTHS
         SR    R3,R4              COMPUTE LENGTH OF COMMAND *HMD 07/81*
         BNP   SVC34END           INVALID COMMAND           *HMD 07/81*
         LA    R3,5(R3)           TEXT AND LIST PREFIX
         STH   R3,CMDLIST         SET SVC 34 LIST LENGTH
         TESTAUTH FCTN=1          SEE IF WE ARE AUTHORIZED  *HMD 07/82*
         LTR   R15,R15            WELL, ARE WE?             *HMD 07/82*
         BZ    MODEOK             YES..JUST DO MODESET      *HMD 07/82*
         MVI   AUTHFLG,AUTHUS     INDICATE WE TURNED ON     *HMD 07/82*
* INSERT YOUR USER SVC HERE TO TURN ON APF AUTHORIZATION. A SAMPLE
* OF SUCH AN SVC IS ON THE LA MVS USER GROUP TAPE. THIS WILL ALLOW
* 'COMMAND' TO BE USED UNDER SPF OPTION 6 OR VIA THE 'CALL' COMMAND.
* ALSO, YOU WILL AVOID THE MESSY JOB OF UPDATING TABLES IN IKJEFT02.
         LTR   R15,R15            SYSTEM PROGRAMMER?        *HMD 07/82*
         BNZ   SVC34END           NOPE..DO NOT WASTE TIME   *HMD 07/82*
MODEOK   DS    0H                                           *HMD 07/82*
*        LA    R0,MSG1            ISSUE MESSAGE FOR COMMAND *BAC 05/90*
*        WTO   MF=(E,(R0))                                  *BAC 05/90*
         MVC   WTOCMD(101),CARD   MOVE IN COMMAND           *BAC 05/90*
         LA    R0,MSG2            ISSUE MESSAGE FOR COMMAND *BAC 05/90*
         WTO   MF=(E,(R0))                                  *BAC 05/90*
         MODESET KEY=ZERO         INDICATE KEY=ZERO
         SYSEVENT DONTSWAP        DONT GET SWAPPED          *HMD 07/81*
         L     R0,R0MASK          LOAD R0 FOR SVC34         *HMD 07/81*
         MGCR  CMDLIST            ISSUE OPERATOR COMMAND    *HMD 07/81*
         TM    SYSIN+DCBOFLGS-IHADCB,DCBOFOPN               *HMD 07/81*
*                                 ARE WE USING SYSIN?       *HMD 07/81*
         BZ    NOSTIMR            NO, DO NOT DELAY          *HMD 07/81*
         STIMER  WAIT,BINTVL=HOLD WAIT FOR A COMPLETION     *HMD 07/81*
NOSTIMR  SYSEVENT OKSWAP          OK TO GET SWAPPED NOW     *HMD 07/81*
         MODESET KEY=NZERO        GO BACK TO USER KEY
         CLI   AUTHFLG,AUTHUS     DID WE TURN ON AUTH?      *HMD 07/82*
         BNE   SVC34END           NO..JUST RETURN           *HMD 07/82*
* INSERT YOUR USER SVC HERE TO TURN OFF APF AUTHORIZATION, AS WE ARE
* DONE ISSUING COMMANDS.
         SPACE
SVC34END DS    0H                 END OF COMMAND ROUTINE
         BR    R11                RETURN TO MAINLINE
         SPACE 2                                            *CKO 07/92*
*OTAUTH  EQU  *                                             *CKO 07/92*
*        TPUT  =CL60'Authorization failed for executing COMMAND',60
*        B     BADEOJ                     Exit              *CKO 07/92*
         EJECT
SAVEAREA DC    18F'0'             OUR SAVEAREA
HOLD     DC    F'200'             WAIT FOR 2 SECONDS        *HMD 07/81*
R0MASK   DC    A(0)               R0 MASK FOR SVC34
AUTHFLG  DC    X'00'              AUTHORIZATION FLAG        *HMD 07/82*
AUTHUS   EQU   X'FF'              WE AUTHORIZED FOR SVC34   *HMD 07/82*
MOREFLG  DC    X'00'              EXTRA FILLER              *HMD 07/82*
ASID     DC    H'00'              OUR ASID
* Parms for RACHECK                                         *CKO 07/92*
*MDENT   DC    CL8'COMMAND'                                 *CKO 07/92*
*MDCLS   DC    AL1(4),C'APPL'                               *CKO 07/92*
*        SPACE
         CNOP  4,8                ALIGN TO MIDDLE OF DOUBLE WORD
CMDLIST  DC    AL2(*-*,0)         SVC 34 LIST
CARD     DC    CL101' '           COMMAND TEXT
         SPACE 3
MOVE     MVC   CARD(*-*),2(R10)   MOVE PARM TEXT INTO SVC 34 LIST
MOVE1    MVC   CARD(*-*),0(R4)    MOVE PARM TEXT INTO SVC 34 LIST
         EJECT
SYSIN    DCB   DDNAME=SYSIN,DSORG=PS,LRECL=80,MACRF=(GM),RECFM=FB,     *
               EODAD=EODSYSIN
MSG1     WTO 'SYSTEMS PROGRAMMER BRIAN COURT ISSUES THE FOLLOWING COMMAX
               ND:',MF=L
MSG2     WTO '                                                         X
                                                          ',MF=L
WTOCMD   EQU MSG2+4
         EJECT
         LTORG                    BEGIN LITERAL POOL
         EJECT
***********************************************************************
*                                                                     *
*                SYSTEM CONTROL BLOCK MAPPING DSECTS                  *
*                                                                     *
*      ALL THESE MACROS CAN BE FOUND IN THE 'SYS1.AMODGEN' MACLIB     *
*                                                                     *
***********************************************************************
         CVT   DSECT=YES,LIST=YES COMMUNICATIONS VECTOR TABLE
         EJECT
         IHAASCB                  ADDRESS SPACE CONTROL BLOCK
         EJECT
         IEECUCM  FORMAT=NEW      UNIT CONTROL MODULE       *HMD 07/81*
         EJECT                                              *HMD 07/81*
         DCBD  DSORG=PS,DEVD=DA   DCB SYMBOLIC DEFN         *HMD 07/81*
         END
//L.SYSLMOD DD  DSN=SYS2.XXXXXXXX.LINKLIB(RESCCMD),DISP=SHR,UNIT=
./ ADD NAME=IGDSMS00
SMS ACDS(SYS9.SMS.RESC.ACDS)
    COMMDS(SYS9.SMS.RESC.COMMDS)
    INTERVAL(15)
    DINTERVAL(150)
    REVERIFY(NO)
    ACSDEFAULTS(NO)
    TRACE(ON)
    SIZE(128K)
    TYPE(ALL)
    JOBNAME(*)
    ASID(*)
    SELECT(ALL)
./ ADD NAME=IKJACCNT
//*-----------------------------------------------------------------*
//* TSO LOGON PROCIKJACCNT.                                         *
//* Built dynamically by RESCUE exec, 19/09/2002 12:09              *
//*-----------------------------------------------------------------*
//IKJACCNT PROC
//IKJACCNT EXEC PGM=IKJEFT01,
//             DYNAMNBR=200,
//             TIME=1440,
//             PARM='%ISPALLOC'
//ISPPLIB  DD DISP=SHR,DSN=SYS1.RESCUE.ISPPLIB
//         DD DISP=SHR,DSN=SYS1.SCBDPENU
//         DD DISP=SHR,DSN=ISP.SISPPENU
//         DD DISP=SHR,DSN=CPAC.ISPPLIB
//         DD DISP=SHR,DSN=SYS1.HRFPANL
//         DD DISP=SHR,DSN=SYS1.DGTPLIB
//         DD DISP=SHR,DSN=ISF.SISFPLIB
//         DD DISP=SHR,DSN=SYS1.SHASPNL0
//         DD DISP=SHR,DSN=SYS2.XXXXXXXX.ISPPLIB
//         DD DISP=SHR,DSN=XXXXXXXX.ISPPLIB
//ISPMLIB  DD DISP=SHR,DSN=SYS1.SCBDMENU
//         DD DISP=SHR,DSN=ISP.SISPMENU
//         DD DISP=SHR,DSN=SYS1.HRFMSG
//         DD DISP=SHR,DSN=SYS1.DGTMLIB
//         DD DISP=SHR,DSN=ISF.SISFMLIB
//         DD DISP=SHR,DSN=XXXXXXXX.ISPMLIB
//ISPSLIB  DD DISP=SHR,DSN=ISP.SISPSLIB
//         DD DISP=SHR,DSN=ISP.SISPSENU
//         DD DISP=SHR,DSN=SYS1.HRFSKEL
//         DD DISP=SHR,DSN=SYS1.DGTSLIB
//         DD DISP=SHR,DSN=ISF.SISFSLIB
//ISPLLIB  DD DISP=SHR,DSN=ISP.SISPLOAD
//         DD DISP=SHR,DSN=SYS1.DGTLLIB
//ISPTLIB  DD DISP=SHR,DSN=SYS1.SCBDTENU
//         DD DISP=SHR,DSN=ISP.SISPTENU
//         DD DISP=SHR,DSN=SYS1.DGTTLIB
//         DD DISP=SHR,DSN=ISF.SISFTLIB
//SYSPROC  DD DISP=SHR,DSN=SYS1.RESCUE.CLIST
//         DD DISP=SHR,DSN=SYS1.SCBDCLST
//         DD DISP=SHR,DSN=ISP.SISPCLIB
//         DD DISP=SHR,DSN=SYS1.HRFCLST
//         DD DISP=SHR,DSN=SYS1.DGTCLIB
//         DD DISP=SHR,DSN=SYS2.XXXXXXXX.CLIST
//         DD DISP=SHR,DSN=XXXXXXXX.CLIST
//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP
//         DD DISP=SHR,DSN=TCPIP.SEZAHELP
//SYSLBC   DD DISP=SHR,DSN=SYS1.BRODCAST
//SYSPRINT DD TERM=TS,SYSOUT=Z
//SYSTERM  DD TERM=TS,SYSOUT=Z
//SYSIN    DD TERM=TS
./ ADD NAME=JES2
//*-----------------------------------------------------------------*
//* JES2 Startup PROC.                                              *
//* Built dynamically by RESCUE exec, 19/09/2002 12:09              *
//*-----------------------------------------------------------------*
//JES2     PROC JESPARM=JES2PARM
//IEFPROC  EXEC PGM=HASJES20,
//            DPRTY=(15,15),TIME=1440,PERFORM=9
//HASPPARM DD DISP=SHR,DSN=SYS1.RESCUE.PARMLIB(&JESPARM)
//PROC00   DD DISP=SHR,DSN=SYS1.RESCUE.PROCLIB
//         DD DISP=SHR,DSN=SYS2.XXXXXXXX.PROCLIB
//         DD DISP=SHR,DSN=SYS1.PROCLIB
//         DD DISP=SHR,DSN=CPAC.PROCLIB
//         DD DISP=SHR,DSN=SYS1.IBM.PROCLIB
//*
//IEFRDER  DD SYSOUT=*
//*
//HASPLIST DD DDNAME=IEFRDER
//*
//
./ ADD NAME=JES2PARM 0100-03007-03007-1045-00558-00558-00000-ITSCXB
/*-------------------------------------------------------*/
/* JES2 Parameter deck.                                  */
/* Built dynamically by RESCUE exec, 19/09/2002 12:09            */
/*-------------------------------------------------------*/
CKPTDEF  CKPT1=(DSNAME=SYS1.HASPCKPT,
         INUSE=YES,VOLSER=RESCUE),MODE=DUAL,DUPLEX=OFF
SPOOLDEF BUFSIZE=3992,
         DSNAME=SYS1.HASPACE,
         FENCE=NO,
         SPOOLNUM=32,
         TGBPERVL=5,
         TGSPACE=(MAX=16288,WARN=80),
         TGSIZE=36,
         TRKCELL=3,
         VOLUME=RESC
/*-------------------------------------------------------*/
/* The parms below were copied from ZJES2PRM in          */
/* the RESCUE build PDS. It is recommended that you not  */
/* modify these parameters directly, but rather make any */
/* changes to the ZJES2PRM source, and rebuild the       */
/* RESCUE members.                                       */
/*-------------------------------------------------------*/
LOGON(1) APPLID=JES2
BUFDEF   BELOWBUF=(LIMIT=114,WARN=80)
CONDEF   AUTOCMD=50,
         BUFNUM=950,
         BUFWARN=80,
         CONCHAR=$,
         DISPLEN=65,
         DISPMAX=100,
         MASMSG=200,
         RDRCHAR=$
DEBUG    =NO
ESTBYTE  NUM=99999,
         INT=99999,
         OPT=0
ESTIME   NUM=2,
         INT=1,
         OPT=NO
ESTLNCT  NUM=5,
         INT=6000,
         OPT=0
ESTPAGE  NUM=100,
         INT=10,
         OPT=0
ESTPUN   NUM=100,
         INT=2000,
         OPT=0
FSSDEF(PRINTOFF)
INITDEF  PARTNUM=16
INIT(1) NAME=01,CLASS=QS,START=YES
INIT(2) NAME=02,CLASS=QS,START=YES
INIT(3) NAME=03,CLASS=QX,START=YES
INIT(4) NAME=04,CLASS=QT,START=YES
INIT(5) NAME=05,CLASS=Q,START=YES
INIT(6) NAME=06,CLASS=Q,START=YES
INIT(7) NAME=07,CLASS=Q,START=YES
INIT(8) NAME=08,CLASS=Q,START=YES
INIT(9) NAME=09,CLASS=Q,START=NO
INIT(10) NAME=10,CLASS=Q,START=NO
INIT(11) NAME=11,CLASS=Q,START=NO
INIT(12) NAME=12,CLASS=Q,START=NO
INIT(13) NAME=13,CLASS=Q,START=NO
INIT(14) NAME=14,CLASS=Q,START=NO
INIT(15) NAME=15,CLASS=Q,START=NO
INIT(16) NAME=16,CLASS=Q,START=NO
INIT(17) NAME=17,CLASS=Q,START=NO
INIT(18) NAME=18,CLASS=Q,START=NO
INIT(19) NAME=19,CLASS=Q,START=NO
INIT(20) NAME=20,CLASS=Q,START=NO
INIT(21) NAME=21,CLASS=Q,START=NO
INIT(22) NAME=22,CLASS=Q,START=NO
INIT(23) NAME=23,CLASS=Q,START=NO
INIT(24) NAME=24,CLASS=Q,START=NO
/*                                                                  */
INTRDR   AUTH=(JOB=YES,DEVICE=NO,SYSTEM=YES),BATCH=YES,CLASS=A,
         HOLD=NO,PRTYINC=0,PRTYLIM=15,RDINUM=30
/*                                                                   */
JOBCLASS(A) ACCT=YES,         /* SHORT JOBS                 ACCT REQ*/
            AUTH=INFO,        /* ALLOW INFO COMMANDS                */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            SWA=ABOVE,        /* SWA ABOVE 16MB                     */
            TIME=(0,15)       /* JOB STEP TIME                      */
JOBCLASS(B-D) ACCT=YES,       /* NOT USED                   ACCT REQ*/
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=(30,0)       /* JOB STEP TIME                      */
JOBCLASS(E) ACCT=YES,         /* ENDEVOR JOBS               ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            SWA=ABOVE,        /* SWA ABOVE 16MB                     */
            TIME=1200         /* JOB STEP TIME                      */
JOBCLASS(F-J) ACCT=YES,       /* ACCT # ALWAYS REQUIRED             */
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440         /* JOB STEP TIME                      */
JOBCLASS(K) ACCT=YES,         /* ACCT # ALWAYS REQUIRED             */
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440,        /* JOB STEP TIME                      */
            SWA=ABOVE         /* SWA ABOVE 16MB                     */
JOBCLASS(L) ACCT=YES,         /* ENDEVOR LIST               ACCT REQ*/
            AUTH=INFO,        /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            SWA=ABOVE,        /* SWA ABOVE 16MB                     */
            TIME=90           /* JOB STEP TIME                      */
JOBCLASS(M) ACCT=YES,         /* MEDIUM DEV JOBS            ACCT REQ*/
            AUTH=INFO,        /* ALLOW INFO COMMANDS                */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            SWA=ABOVE,        /* SWA ABOVE 16MB                     */
            TIME=(5,0)        /* JOB STEP TIME                      */
JOBCLASS(N) ACCT=YES,         /* LONG DEV JOBS              ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440         /* JOB STEP TIME                      */
JOBCLASS(Q-R) ACCT=YES,       /* PROD + VALU                ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440         /* JOB STEP TIME                      */
JOBCLASS(S) ACCT=YES,         /* ACCT # ALWAYS REQUIRED             */
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440,        /* JOB STEP TIME                      */
            SWA=ABOVE         /* SWA ABOVE 16MB                     */
JOBCLASS(T) ACCT=YES,         /* ACCT # ALWAYS REQUIRED             */
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440         /* JOB STEP TIME                      */
JOBCLASS(U) ACCT=YES,         /* ACCT # ALWAYS REQUIRED             */
            AUTH=INFO,        /* ALLOW INFO COMMANDS                */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            SWA=ABOVE,        /* SWA ABOVE 16MB                     */
            TIME=(5,0)        /* JOB STEP TIME                      */
JOBCLASS(V) ACCT=YES,         /* FAST PROD - NOT USED       ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440         /* JOB STEP TIME                      */
JOBCLASS(W) ACCT=YES,         /* SAR RELOAD JOBS            ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            RESTART=NO,       /* DEFAULT RESTART                    */
            TIME=1440         /* JOB STEP TIME                      */
JOBCLASS(X) ACCT=YES,         /* TSD SMP/E JOBS             ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440,        /* JOB STEP TIME                      */
            SWA=ABOVE         /* SWA ABOVE 16MB                     */
JOBCLASS(Y-Z) ACCT=YES,       /*                            ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440,        /* JOB STEP TIME                      */
            SWA=ABOVE         /* SWA ABOVE 16MB                     */
JOBCLASS(1-9) ACCT=YES,       /* SINGLE-THREADS (DEV)       ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            SWA=ABOVE,        /* SWA ABOVE 16MB                     */
            TIME=1440         /* JOB STEP TIME                      */
/*                                                                   */
/*                                                                   */
JOBDEF   ACCTFLD=OPTIONAL,   /* ACCOUNTING FIELD OPTIONAL            */
         JCLERR=NO,          /* NO TERM. JOB W/JCL ERROR             */
     /*  JOBNUM=1000,  */    /* JOB QUEUE SIZE                       */
         JOBNUM=9999,        /* JOB QUEUE SIZE                       */
         JOBWARN=80,         /* WARNING THRESHOLD % FOR JQES         */
         NUMWARN=80,         /* WARN THRESHOLD % FOR JOB NUMB.       */
         PRTYHIGH=10,        /* UPPER LIMIT FOR AGING                */
         PRTYJECL=YES,       /*PRIORITY JECL SUPPORTED               */
         PRTYJOB=NO,         /* PRTY= ON JOB NOT SUP'D               */
         PRTYLOW=5,          /* LOWER LIMIT FOR AGING                */
         PRTYRATE=96,        /* PRTY AGING RATE X/DAY                */
         RANGE=(1-9999)      /* LOCAL JOB NUMBER RANGE               */
/*                                                                   */
JOBPRTY(1) PRIORITY=9,       /* JOB PRTY=9 IF                        */
          TIME=2             /*  < 2 MIN. EXEC. TIME                 */
                             /*                                      */
JOBPRTY(2) PRIORITY=8,       /* JOB PRTY=8 IF                        */
          TIME=5             /*  < 5 MIN. EXEC. TIME                 */
                             /*                                      */
JOBPRTY(3) PRIORITY=7,TIME=15 /*JOB PRTY=7 IF <15 MIN.  &RPRI2,...OC*/
                             /* ETC.                                 */
                             /*                                      */
JOBPRTY(4) PRIORITY=6,       /* JOB PRTY=6 IF NOLIM     &RPRI2,...OC*/
         TIME=1440           /* ETC.                                 */
                             /*                                      */
/*                            *--------------------------------------*
                              |    IDENTIFY JES2 APPLIDS TO VTAM     |
                              *--------------------------------------*
                                                                    */
MASDEF   SHARED=NOCHECK,     /* MULTI ACCESS SPOOL NOCHECK           */
         HOLD=100,           /* MINIMUM HOLD TIME                    */
         DORMANCY=(100,500), /* MINIMUM / MAXIMUM DORMANCY TIME      */
         LOCKOUT=1200        /* LOCK-OUT WARNING TIME                */
                             /*                                      */
/*                                                                  */
NJEDEF   DELAY=120,         /* MAX. MSG DELAY TIME                  */
         JRNUM=4,           /* NUM. OF JOB RECEIVERS                */
         JTNUM=4,           /* NUM. OF JOB XMITTERS                 */
         LINENUM=1,         /* NUM. OF LINES FOR NJE                */
         NODENUM=2000,      /* MAX. NUMBER OF NJE NODES             */
         OWNNODE=1,         /* THIS NODE'S NUMBER                   */
         PATH=1,            /* NUM. OF PATHS/ALT'NATE               */
         RESTMAX=8000000,   /* MAX. RESISTANCE TOLERANCE            */
         RESTNODE=100,      /* THIS NODE'S RESISTANCE               */
         RESTTOL=0,         /* ALT. RESISTANCE TOLERANCE            */
         SRNUM=4,           /* NUM. OF SYSOUT RECEIVERS             */
         STNUM=4            /* NUM. OF SYSOUT TRANSMITTERS          */
/*                                                                  */
/*OFFLOAD(1) DSN=SYS1.OFFLOAD  /* DATA SET NAME           DSN       */
/*                           /* NO. OF DEVICES (UNITS)  UNITCT      */
                             /*                                     */
OFFLOAD(1) DSN=SYS3.SPOOL.OFFLOAD,LABEL=SL,RETPD=7,UNIT=CART
OFF(1).JR CLASS=,           /* RELOAD ALL CLASSES                   */
         HOLD=,             /* RELOAD HELD - NON-HELD               */
         JOBNAME=,          /* RELOAD ANY JOB NAME                  */
                            /* MODIFY JOBS ON RELOAD                */
         MOD=(CLASS=,       /* - DON'T CHANGE CLASS                 */
              HOLD=,        /* - DON'T CHANGE HOLD                  */
              ROUTECDE=,    /* - DON'T CHANGE DEST'N                */
              SYSAFF=),     /* - DON'T CHANGE SYSAFF.               */
         NOTIFY=NO,         /* DON'T NOTIFY ON RELOAD               */
         RANGE=J1-32767,    /* RELOAD ALL JOB NUMBERS               */
         ROUTECDE=(),       /* RELOAD JOBS W/ANY DEST               */
         START=YES,         /* ABORTED WITH $S OFFLOAD              */
         SYSAFF=(),         /* RELOAD JOBS WITH ANY AFF             */
         WS=(/)             /* JOB SELECTION CRITERIA               */
/*                                                                  */
OFF(1).JT CLASS=,           /* SELECT NO CLASSES                    */
         DISP=DELETE,       /* PURGE AFTER OFFLOAD                  */
         HOLD=,             /* SELECT HELD - NON-HELD               */
         JOBNAME=,          /* SELECT ANY JOB NAME                  */
         NOTIFY=NO,         /* DON'T NOTIFY ON OFFLD.               */
         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS               */
         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST               */
         START=YES,         /* STARTED WITH $S OFFLOAD              */
         SYSAFF=(),         /* SELECT JOBS WITH ANY AFF             */
         VOLUME=(),         /* SELECT ANY SPOOL VOLUME              */
         WS=(/)             /* JOB SELECTION CRITERIA               */
/*                                                                  */
OFF(1).SR BURST=,         /* SELECT ANY BURST SETTING               */
         OUTDISP=(HOLD,KEEP,LEAVE,WRITE),
         FCB=,              /* SELECT ANY FCB                       */
         FLASH=,            /* SELECT ANY/NO FLASH                  */
         HOLD=,             /* SELCT HELD/NON-HLD JOBS              */
         JOBNAME=,          /* SELECT ANY JOB NAME                  */
                            /* MODIFY FOLLOWING ON RELOAD           */
         MOD=(BURST=,       /* - DON'T CHANGE BURST                 */
              OUTDISP=,     /* - DON'T CHANGE DSHOLD                */
              FCB=,         /* - DON'T CHANGE FCB                   */
              FLASH=,       /* - DON'T CHANGE FLASH                 */
              FORMS=,       /* - DON'T CHANGE FORMS                 */
              HOLD=,        /* - DON'T CHANGE HOLD                  */
              PRMODE=,      /* - DON'T CHANGE PRMODE                */
              QUEUE=,       /* - DON'T CHANGE CLASS                 */
              ROUTECDE=,    /* - DON'T CHANGE DESTN                 */
              UCS=,         /* - DON'T CHANGE UCS                   */
              WRITER=),     /* - DON'T CHANGE WRITER                */
         NOTIFY=NO,         /* DON'T NOTIFY ON RELOAD               */
         PRMODE=(),         /* SELECT ANY PRMODE                    */
         QUEUE=,            /* SELECT ANY SYSOUT CLASS              */
         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS               */
         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST               */
         START=YES,         /* STARTED WITH $S OFFLOAD              */
         UCS=,              /* SELECT ANY UCS                       */
         WRITER=,           /* SELECT ANY WRITER                    */
         WS=(/)             /* JOB SELECTION CRITERIA               */
                            /* - CLASS ONLY                         */
/*                                                                  */
OFF(1).ST BURST=,           /* SELECT ANY BURST SET'G               */
         DISP=DELETE,       /* PURGE AFTER OFFLOAD                  */
         OUTDISP=(HOLD,KEEP,LEAVE,WRITE),
         FCB=,              /* SELECT ANY FCB                       */
         FLASH=,            /* SELECT ANY/NO FLASH                  */
         HOLD=,             /* SELCT HELD-NON-HLD JOBS              */
         JOBNAME=,          /* SELECT ANY JOB NAME                  */
         LIMIT=(0-*),       /* SELECT ANY # LINES                   */
         NOTIFY=NO,         /* DON'T NOTIFY ON OFFLD.               */
         PLIM=(0-*),        /* SELECT ANY # PAGES                   */
         PRMODE=(),         /* SELECT ANY PRMODE                    */
         QUEUE=,            /* SELECT ANY SYSOUT CLASS              */
         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS               */
         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST               */
         START=YES,         /* STARTED WITH $S OFFLOAD              */
         UCS=,              /* SELECT ANY UCS                       */
         VOLUME=(),         /* SELECT ANY SPOOL VOLUME              */
         WRITER=,           /* SELECT ANY WRITER                    */
         WS=(/)             /* JOB SELECTION CRITERIA               */
                            /* - CLASS ONLY                         */
/*                                                                  */
/*********************************************************************/
                              /***** OUTPUT CLASS ATTRIBUTES ********/
OUTCLASS(A)   OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=PRINT,   /* PRINT CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
OUTCLASS(B)   OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=PUNCH,   /* PUNCH CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
OUTCLASS(C-I) OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=PRINT,   /* PRINT CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
OUTCLASS(J)   OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=PUNCH,   /* PRINT CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
OUTCLASS(K)   OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=PRINT,   /* PRINT CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
OUTCLASS(L)   OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=DUMMY,   /* PRINT CLASS                        */
              TRKCELL=NO      /* TRACK-CELL THIS CLASS              */
OUTCLASS(M-W) OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=PRINT,   /* PRINT CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
OUTCLASS(X)   OUTD=(HOLD,HOLD),  /* A HELD CLASS                    */
              OUTPUT=PRINT,   /* PRINT CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
OUTCLASS(Y-9) OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=PRINT,   /* PRINT CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
/*                                                                  */
OUTDEF   BRODCAST=NO,       /* WHETHER SHARED BROADCASTING          */
         COPIES=255,        /* MAX. # OF COPIES ALLOWED             */
         DMNDSET=NO,        /* NO DEMAND SETUP                  DWNC*/
         JOENUM=3000,       /* MAX. # OF JOES                   MAM2*/
         JOEWARN=80,        /* WARNING THRESHOLD %                  */
         PRTYHIGH=255,      /* CEILING FOR PRTY AGING               */
         PRTYLOW=0,         /* FLOOR FOR PRTY AGING                 */
         PRTYOUT=NO,        /* NO PRTY= ON // OUTPUT                */
         STDFORM=STD,       /* DEFAULT FORMS ID                 DWNC*/
         USERSET=NO         /* NO USER DEMAND-SETUP             DWNC*/
/*                                                                  */
OUTPRTY(1) PRIORITY=144,    /* OUTPUT PRTY IS 144 IF                */
         RECORD=2000,       /*  < 2000 RECORDS (LINE)               */
         PAGE=50            /*  OR < 50 PAGES (PAGE)                */
/*                                                                  */
OUTPRTY(2) PRIORITY=128,    /* OUTPUT PRTY IS 128 IF                */
         RECORD=5000,       /*  < 5000 RECORDS (LINE)               */
         PAGE=100           /*  OR < 100 PAGES (PAGE)               */
/*                                                                  */
OUTPRTY(3) PRIORITY=112,     /* OUTPUT PRTY IS 112 IF   &XPRI1    OC*/
           RECORD=15000,     /*  <15000 RECORDS (LINE)  &XLIN1    OC*/
           PAGE=300          /*  OR <300 PAGES (PAGE)   &XPAG1    OC*/
                             /* ETC.                               OC*/
OUTPRTY(4) PRIORITY=96,      /* OUTPUT PRTY IS  96 IF   &XPRI1    OC*/
           RECORD=16677215,  /*  < MAX  RECORDS (LINE)  &XLIN1    OC*/
           PAGE=16677215     /*  OR <MAX PAGES (PAGE)   &XPAG1    OC*/
                             /* ETC.                               OC*/
/*                                                                  */
PCEDEF   CNVTNUM=2,         /* NUMBER OF CONVERTER PCES             */
         OUTNUM=2,          /* NUMBER OF OUTPUT PCES                */
         PSONUM=2,          /* NUMBER OF PSO PCES                   */
         PURGENUM=2         /* NUMBER OF PURGE PCES                 */
/*                                                                   */
PRINTDEF CCWNUM=200,        /* # CCWS / PRINT BUFFER            DWNC*/
         DBLBUFR=YES,       /* DOUBLE BUFFER LCL PRTS           DWNC*/
         FCB=6,             /* INITIAL FCB LOADED               DWNC*/
         LINECT=61,         /* 61 LINES/PAGE                        */
/*       NIFCB=8X8,    */   /* NO 3800 FCB LOADED               DWNC*/
/*       NIFLASH=****, */    /* NO 3800 FLASH LOADED             DWNC*/
                             /* NOTE: THE VALUES FOR NIFCB= AND      */
                             /*       NIFLASH=  CANNOT BE NULL OR    */
                             /*       ASTERISKS (AS SHOWN HERE).     */
                             /*       IF THE STATEMENTS ARE NOT      */
                             /*       CODED AT ALL, THEN THE DEFAULT */
                             /*       WILL BE ASTERISKS. THE         */
                             /*       STATEMENTS ARE SHOWN THIS WAY  */
                             /*       ONLY TO INCLUDE THE DEFAULT    */
                             /*       VALUES HERE.                   */
         NIUCS=0,            /* WAS GT15                         DWNC*/
         RDBLBUFR=NO,        /* SINGLE BUFFER RMT PRTS           DWNC*/
         SEPPAGE=(REMOTE=HALF,LOCAL=FULL),
         TRANS=NO,           /* PN-XLATE FOR 1403/RM.PR          DWNC*/
         UCS=0               /* BYPASS UCS-LOADING               DWNC*/
/*                                                                   */
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    LOCAL PRINTERS                    |
                              *--------------------------------------*
                                                                     */
                             /* ALTERNATE NAME FOR PRTN:             */
                             /*   PRINTERN                           */
PRT(1)  CLASS=A,         /* JOB CLASS THAT CAN BE CHOSEN         */
        UNIT=FDF,
        CKPTLINE=60,     /*  MAX LINES IN A LOGICAL PAGE          */
        CKPTPAGE=100,    /*  MAX PAGES BEFORE A CKPT              */
        START=YES,       /*  PRT1 COMES UP STARTED                */
        WS=(W,R,Q,PRM,LIM,F,FCB/UCS,P),
        TRKCELL=NO       /*  RECORDS DESPOOLED 1 AT A TIME    HWNC*/
/*                                                                  */
/*                                                                   */
PUNCHDEF CCWNUM=200,         /* # CCWS / PUNCH BUFFER            DWNC*/
         DBLBUFR=YES,        /* SINGLE BUFFER LCL PUNS           DWNC*/
         RDBLBUFR=NO         /* SINGLE BUFFER RMT PUNS           DWNC*/
/*                                                                   */
PUN(1)  CKPTLINE=100,    /* NO. OF CARDS TO PUNCH PER PAGE       */
        CLASS=BK,    /*  OUTPUT CLASS PROCESSED BY PUN        */
       WS=(W,R,Q,PRM,LIM/F,P)  /* WORK SELECTION CRITERION          */
/*                                                                   */
PUN(2)  CKPTLINE=100,    /* NO. OF CARDS TO PUNCH PER PAGE       */
        CLASS=BK,    /*  OUTPUT CLASS PROCESSED BY PUN        */
       WS=(W,R,Q,PRM,LIM/F,P)  /* WORK SELECTION CRITERION          */
/*                                                                   */
RDR(1)  AUTO,            /* RDRNN COMES UP STARTED (DRAIN)       */
        CLASS=A,        /* DEFAULT JOB CLASS                    */
        NOHOLD,         /* JOBS NOT HELD AFTER CONV.(HOLD)      */
        MSGCLASS=A     /* DEFAULT MESSAGE CLASS                */
                             /* ERRORS ARE COUNTED                   */
                             /*                                      */
/*                                                                   */
SMFDEF   BUFNUM=20,          /* NUMBER OF SMF BUFFERS            DWNC*/
         BUFWARN=80          /* WARNING THRESHOLD %                  */
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    SSI DEFINITIONS                   |
                              |    ADDED IN SP311                    |
                              *--------------------------------------*
                                                                     */
SSI(1)  TRACE=NO            /* SPECIFY WHICH SUBSYSTEM FUNCT        */
                            /* WHETHER OR NOT TRACING IS            */
                            /*  ACTIVE FOR THIS SSI FUNCTION        */
/*                                                                   */
STCCLASS TIME=(1440,00),     /* JOB STEP TIME   ...MMMMSS........... */
         REGION=6M,          /* REGION SIZE     .........CCC........ */
         COMMAND=EXECUTE,    /* EXECUTE COMMANDS............R....... */
         BLP=YES,            /* IGNORE BLP PARM .............L...... */
         AUTH=ALL,           /* ALLOW ALL CMDS  ..............AAAA.. */
         MSGLEVEL=(1,1),     /* JOB, ALL MSGS   ..................EF */
         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT              */
         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT              */
         OUTDISP=(HOLD,HOLD),      /* PURGE,HOLD TO HOLD,HOLD        */
         LOG=YES,            /* PRINT JES2 JOB LOG                   */
         MSGCLASS=K,         /* DEFAULT MESSAGE CLASS                */
         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB               */
         PERFORM=000,        /* SRM PERFORMANCE GROUP 0              */
         PROCLIB=00,         /* USE //PROC00 DD                      */
         SWA=BELOW,          /* SWA CBS BELOW 16M LINE               */
                             /*     (ADDED BY APAR OY02574)          */
                             /*     (SUPERSEDED BY APAR OY03444)     */
         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS                */
         TYPE26=YES          /* PRODUCE SMF 26 RECORDS               */
/*                                                                   */
/*                             TP (NJE/RJE) CHARACTERISTICS          */
/*    TPDEF    BELOWBUF=(LIMIT=200,SIZE=1152,WARN=80),               */
TPDEF    BELOWBUF=(LIMIT=200,SIZE=3840,WARN=80),
         MBUFSIZE=3840,      /* MULTI-LEAVING BUFFER SIZE            */
         RMTMSG=100,         /* MAX. # MSGS QUEUED TO REMOTE         */
         SESSION=20,         /* MAX. # SNA SESSIONS                  */
         AUTOINTV=120
/*                                                                   */
/*********************************************************************/
TRACE(1)  START=NO           /* SPECIFY WHICH TRACE ID               */
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    $TRACE FACILITY                   |
                              *--------------------------------------*
                                                                     */
TRACEDEF TABLES=3,           /* NUMBER OF TRACE TABLES               */
         PAGES=2,            /* NUMBER OF 4K PAGES PER TABLE     DWNC*/
         TABWARN=80,         /* WARNING THRESHOLD %                  */
         ACTIVE=NO,          /* WHETHER OR NOT TO START HE           */
                             /*  TRACE FACILITY                      */
         LOG=(START=NO,      /* WHETHER OR NOT TO FORMAT AND         */
                             /*  ADD DATA TO TRACE LOG DATASET       */
              SIZE=500,      /* MAX SIZE OF TRACE LOG DATASET        */
              CLASS=A)       /* TRACE LOG DATASET OUTPUT CLASS       */
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    TSU DEFAULTS                      |
                              *--------------------------------------*
                                                                     */
TSUCLASS TIME=(1440,00),     /* JOB STEP TIME   ...MMMMSS..........  */
         REGION=6M,          /* REGION SIZE     .........CCC.......  */
         COMMAND=EXECUTE,    /* EXECUTE COMMANDS............R......  */
         BLP=NO,             /* IGNORE BLP PARM .............L.....  */
         AUTH=ALL,           /* ALLOW ALL CMDS  ..............AAAA.  */
         MSGLEVEL=(0,0),     /* JOB, ALL MSGS   ..................EF */
         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT              */
         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT              */
         OUTDISP=(PURGE,HOLD),     /* PURGE,HOLD                     */
         LOG=YES,            /* PRINT JES2 JOB LOG                   */
         MSGCLASS=X,         /* DEFAULT MESSAGE CLASS                */
         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB               */
         PERFORM=000,        /* SRM PERFORMANCE GROUP 0              */
         PROCLIB=00,         /* USE //PROC00 DD                      */
         SWA=BELOW,          /* SWA CBS BELOW 16M LINE               */
                             /*     (ADDED BY APAR OY02574)          */
                             /*     (SUPERSEDED BY APAR OY03444)     */
         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS                */
         TYPE26=YES          /* PRODUCE SMF 26 RECORDS               */
                             /*                                      */
./ ADD NAME=LOAD00
IODF     01 SYS1     MVS1     00
NUCLEUS  1
SYSCAT   RESCUE113CCATALOG.RESCUE
PARMLIB  SYS1.RESCUE.PARMLIB                          RESCUE
PARMLIB  SYS2.XXXXXXXX.PARMLIB                        RESCUE
PARMLIB  SYS1.PARMLIB                                 RESCUE
PARMLIB  SYS1.IBM.PARMLIB                             RESCUE
PARMLIB  SYS1.SHASPARM                                RESCUE
./ ADD NAME=LPALST00
CEE.SCEELPA,
SYS1.SERBLPA,
SYS1.SDWWDLPA,
ISP.SISPLPA,
TCPIP.SEZALPA,
ISF.SISFLPA,
SYS2.IMSPRPQ.LPALIB
./ ADD NAME=MINIREST 0100-02219-02219-1706-00017-00017-00000-ITSCXB
//MINIREST JOB (ZZOP0000Z),'DISASTER',CLASS=S,MSGCLASS=X,
//         NOTIFY=&SYSUID
//REST01   EXEC PGM=ADRDSSU,REGION=4M
//SYSPRINT DD SYSOUT=*
//INFILE1  DD DSN=PINST.RECOVERP.DUMP1.GnnnnV00, <=== Check Doc
//         DISP=SHR,UNIT=3590-1,
//         VOL=SER=vvvvvv                        <=== Check Doc
//OUTDD    DD VOL=SER=RESCUE,UNIT=3390,DISP=SHR
//SYSIN DD *
   RESTORE DATASET(INCLUDE(SYS9.DISASTER.RECOVERY.** -
                           SYS4.FDR.**               -
                           SYS3.FDR.**               -
                           SYS2.FDR.**))             -
    INDD(INFILE1) -
    OUTDD(OUTDD) -
    CATALOG NULLSTORCLAS NULLMGMTCLAS -
    REPLACE
./ ADD NAME=MSTJCL01
//MSTJCL01 JOB MSGLEVEL=(1,1),TIME=1440
//*-----------------------------------------------------------------*
//* Master JCL.                                                     *
//* Built dynamically by RESCUE exec, 19/09/2002 12:09              *
//*-----------------------------------------------------------------*
//         EXEC PGM=IEEMB860,DPRTY=(15,15)
//STCINRDR DD SYSOUT=(A,INTRDR)
//TSOINRDR DD SYSOUT=(A,INTRDR)
//IEFPDSI  DD DISP=SHR,DSN=SYS1.RESCUE.PROCLIB
//         DD DISP=SHR,DSN=SYS2.XXXXXXXX.PROCLIB
//         DD DISP=SHR,DSN=SYS1.PROCLIB
//         DD DISP=SHR,DSN=CPAC.PROCLIB
//         DD DISP=SHR,DSN=SYS1.IBM.PROCLIB
//SYSUADS  DD DISP=SHR,DSN=SYS1.UADS
//SYSLBC   DD DISP=SHR,DSN=SYS1.BRODCAST
./ ADD NAME=PROGA0
/*--------------------------------------------------*/
/* APF entries dynamically built by RESCUE exec.    */
/*--------------------------------------------------*/
APF FORMAT(DYNAMIC)
APF ADD DSNAME(SYS1.RESCUE.LINKLIB)                   VOLUME(RESCUE)
APF ADD DSNAME(SYS2.XXXXXXXX.VTAMLIB)                 VOLUME(RESCUE)
APF ADD DSNAME(SYS1.LINKLIB)                          VOLUME(RESCUE)
APF ADD DSNAME(SYS1.SHASLINK)                         VOLUME(RESCUE)
APF ADD DSNAME(SYS1.SHASMIG)                          VOLUME(RESCUE)
APF ADD DSNAME(SYS1.MIGLIB)                           VOLUME(RESCUE)
APF ADD DSNAME(EOY.SEOYLOAD)                          VOLUME(RESCUE)
APF ADD DSNAME(EOX.SEPHLOD1)                          VOLUME(RESCUE)
APF ADD DSNAME(GIM.SGIMLMD0)                          VOLUME(RESCUE)
APF ADD DSNAME(CEE.SCEERUN)                           VOLUME(RESCUE)
APF ADD DSNAME(CEE.SCEERUN2)                          VOLUME(RESCUE)
APF ADD DSNAME(IMO.SIMOMOD1)                          VOLUME(RESCUE)
APF ADD DSNAME(ISP.SISPSASC)                          VOLUME(RESCUE)
APF ADD DSNAME(FFST.SEPWMOD2)                         VOLUME(RESCUE)
APF ADD DSNAME(FFST.SEPWMOD4)                         VOLUME(RESCUE)
APF ADD DSNAME(SYS1.SICELINK)                         VOLUME(RESCUE)
APF ADD DSNAME(SYS1.SORTLIB)                          VOLUME(RESCUE)
APF ADD DSNAME(IOE.SIOELMOD)                          VOLUME(RESCUE)
APF ADD DSNAME(SYS1.SIOALMOD)                         VOLUME(RESCUE)
APF ADD DSNAME(CBC.SCLBDLL)                           VOLUME(RESCUE)
APF ADD DSNAME(SYS1.SERBLINK)                         VOLUME(RESCUE)
APF ADD DSNAME(CEE.SCEELPA)                           VOLUME(RESCUE)
APF ADD DSNAME(SYS1.SERBLPA)                          VOLUME(RESCUE)
APF ADD DSNAME(SYS1.SDWWDLPA)                         VOLUME(RESCUE)
APF ADD DSNAME(SYS1.SCBDHENU)                         VOLUME(RESCUE)
APF ADD DSNAME(ISP.SISPLPA)                           VOLUME(RESCUE)
APF ADD DSNAME(TCPIP.SEZALPA)                         VOLUME(RESCUE)
APF ADD DSNAME(TCPIP.SEZAMIG)                         VOLUME(RESCUE)
APF ADD DSNAME(TCPIP.SEZALINK)                        VOLUME(RESCUE)
APF ADD DSNAME(ISF.SISFLPA)                           VOLUME(RESCUE)
APF ADD DSNAME(SYS1.VTAMLIB)                          VOLUME(RESCUE)
APF ADD DSNAME(SYS1.SISTCLIB)                         VOLUME(RESCUE)
APF ADD DSNAME(SYS2.FDR.MODFDR53)                     VOLUME(RESCUE)
APF ADD DSNAME(SYS3.FDR.MODFDR53)                     VOLUME(RESCUE)
APF ADD DSNAME(SYS2.XXXXXXXX.LINKLIB)                 VOLUME(RESCUE)
APF ADD DSNAME(SYS2.IMSPRPQ.LPALIB)                   VOLUME(RESCUE)
APF ADD DSNAME(SYS2.XXXXXXXX.LOADLIB)                 VOLUME(RESCUE)
./ ADD NAME=PROGL0
/*--------------------------------------------------*/
/* LNKLST entries dynamically built by RESCUE exec. */
/*--------------------------------------------------*/
LNKLST DEFINE NAME(LNKLST00)
LNKLST ADD NAME(LNKLST00)
     DSNAME(SYS1.RESCUE.LINKLIB)                    VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(SYS1.LINKLIB)                           VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(SYS1.SHASLINK)                          VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(SYS1.SHASMIG)                           VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(SYS1.CSSLIB)                            VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(EOY.SEOYLOAD)                           VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(EOX.SEPHLOD1)                           VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(GIM.SGIMLMD0)                           VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(CEE.SCEERUN)                            VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(CEE.SCEERUN2)                           VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(IMO.SIMOMOD1)                           VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(ISP.SISPSASC)                           VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(FFST.SEPWMOD2)                          VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(FFST.SEPWMOD4)                          VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(SYS1.SICELINK)                          VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(SYS1.SORTLIB)                           VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(IOE.SIOELMOD)                           VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(SYS1.SIOALMOD)                          VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(CBC.SCLBDLL)                            VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(SYS1.SERBLINK)                          VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(CEE.SCEELPA)                            VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(SYS1.CMDLIB)                            VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(SYS1.SCBDHENU)                          VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(ISP.SISPLOAD)                           VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(TCPIP.SEZAMIG)                          VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(TCPIP.SEZALINK)                         VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(TCPIP.SEZAINST)                         VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(ISF.SISFLINK)                           VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(ISF.SISFLOAD)                           VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(SYS2.FDR.MODFDR53)                      VOLUME(RESCUE)
LNKLST ADD NAME(LNKLST00)
     DSNAME(SYS2.XXXXXXXX.LINKLIB)                  VOLUME(RESCUE)
LNKLST ACTIVATE NAME(LNKLST00)
./ ADD NAME=RESCUE   0163-02207-02262-1209-02651-00366-00000-ITSCXB
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* Read the $$$DOC member for more information on using    */
/* the RESCUE execs.                                       */
/*---------------------------------------------------------*/
$$debug=0
call initialise
/*---------------------------------------------------------*/
/* Call routines to build various JCL members.             */
/*---------------------------------------------------------*/
call #initvol         /* Init volume.                      */
call #defmcat         /* Define mastercat.                 */
call #defvsam         /* Define PAGE, MANx, etc.           */
call #defnvsm         /* Define NONVSAM catalog entries.   */
call #alcnvsm         /* Allocate non-VSAM datasets.       */
call #copyds          /* Copy datasets.                    */
call #altnvsm         /* Alter NONVSAM entries.            */
call #rfdsnt          /* Create RACF dataset name table.   */
call #rfstc           /* Create RACF started task table.   */
call #rfcopy          /* Create copy of RF dataset.        */

call iodf              /* LOAD00 for IODF.                 */
call apf               /* PROGA0 for APF.                  */
call lnklst            /* PROGL0 for LNKLST.               */
call lpa               /* LPALST00.                        */
call jes2              /* PROC for JES2.                   */
call jes2parm          /* Create JES2PARM.                 */
call tsoproc           /* TSO LOGON PROC.                  */
call cofvlf            /* COFVLF00                         */
call vtamproc          /* VTAM startup proc.               */
call mstrjcl           /* MSTRJCL00.                       */
call bpxprm            /* BPXPRM00 for OMVS.               */
call smfprm            /* SMFPRM00 for SMF.                */
call igdsms            /* IGDSMS00 member.                 */

call #copymem         /* Copy members.                     */
call #delssa          /* Delete the SSA and EXPORT catalog.*/
call #misc            /* Last minute assorted stuff.       */

call newjob "Final notification job"
call jcl "//TSOSTEP  EXEC PGM=IKJEFT01 "
call jcl "//SYSTSPRT DD  SYSOUT=* "
call jcl "//SYSTSIN  DD  * "
call jcl "SEND +"
call jcl " 'One pack RESCUE system build has completed successfully' +"
call jcl "  USER("userid()") LOGON "
call endjob
exit





/*=========================================================*/
/* Initialise - get the PDS name, read the parms and       */
/* data set members, initialise variable.                  */
/*=========================================================*/
initialise:
/*---------------------------------------------------------*/
/* MAKE SURE I CAN OBTAIN THE PDS NAME FROM SYSPROC        */
/*---------------------------------------------------------*/
pds  = listdsi("SYSPROC" "FILE")
select
  when pds=0 then
    pds=sysdsname
  otherwise
    do
      say " "
      say "*** Failed to obtain SYSPROC pds data set name"
      exit 12
    end
end

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
IF SYSDSN("'"pds"'") /= OK THEN DO
   say " "
   say "*** Error allocating '"pds"'."
   EXIT 12
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   INTERPRET q '= "'r'"'
END
/*-------------------------------------------*/
/* Deal with some of the parameters          */
/* and initialise other variables            */
/*-------------------------------------------*/
select
  when datefmt='E'|datefmt='e' then nop
  when datefmt='U'|datefmt='u' then nop
  otherwise datefmt='E'
end
mydate=substr(date(datefmt),1,6)||word(date('n'),3)' 'left(time(),5)

/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */

/*---------------------------------------------------------*/
/* Set up the Job Characters                               */
/*---------------------------------------------------------*/
do jobind=1 to 36
  jobchar.jobind=substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789",jobind,1)
end
jobind=0

/*---------------------------------------------------------*/
/* Check for presence of all datasets.  If copy mode is    */
/* "N" meaning the DS is not copied bu just created, then  */
/* assume it is ok.                                        */
/*---------------------------------------------------------*/
say "Checking datasets in @DATASET member."
##ok = 1
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   /*--------------------------------------------------*/
   /* If a model is specified, then check only for the */
   /* existence of the model ds.                       */
   /*--------------------------------------------------*/
   stat = SYSDSN("'"zzdsn1"'")
   IF stat /= 'OK' THEN DO
      if zzmode='X' then
    /*  say "    'Allocation-Only' dataset not found: "zzdsn1 */ nop
      else
        do
          say '*** Dataset not found: 'zzdsn1
          ##ok = 0
        end
   END
   /*--------------------------------------------------*/
   /* Make sure the mode is valid                      */
   /*--------------------------------------------------*/
   IF pos(zzmode,"CDSGNHX") = 0 THEN DO
      say "***" ,
          "Dataset mode must be C, D, S, G, N or H for" DSNS.##xxx
      ##ok = 0
   END
END
if  \##ok THEN DO
   say '*** One or more datasets missing.  Processing terminated.'
   exit 12
end
return





/*=========================================================*/
/* Initialize RESCUE volume, define VVDS, VTOC, etc.       */
/*=========================================================*/
#initvol:
/*---------------------------------------------------------*/
/* See if COMMANDPGM and WAITPGM are coded in parms.  If   */
/* not, then don't code the ONLINE and OFFLINE steps.      */
/*---------------------------------------------------------*/
IF VALUE("COMMANDPGM") = "COMMANDPGM" | commandpgm = "" THEN cmdpgm = 0
ELSE cmdpgm = 1
IF VALUE("WAITPGM") = "WAITPGM" | waitpgm = "" THEN waipgm = 0
ELSE waipgm = 1

call newjob "Initialise, define VVDS, VTOC"
call jcc "EXPORTD  - Export the new mcat for good measure."
IF cmdpgm THEN,
call jcc "OFFLINEx - Vary the target VOLSER offline."
call jcc "DSFINIT  - Initialize the volume with ICKDSF."
IF cmdpgm THEN,
call jcc "ONLINEx  - Vary the target VOLSER online."
call jcc "DEFVVDS  - Define VVDS on volume."
call jcd
call jcc "NOTE: You may need to reply to the ICKDSF message ICK003D"
call jcc "on the MVS console after submitting this job.BE SURE that"
call jcc "the address specified in this message is the correct disk"
call jcc "unit.  If the wrong address is specified, and this wrong"
call jcc "address is an offline disk unit, it will be completely wiped"
call jcc "out, and will have to be recovered from a backup."

/*---------------------------------------------------------*/
/* Can't automatically do V ONLINE etc., so place notes    */
/* in JCL to that effect.                                  */
/*---------------------------------------------------------*/
IF \cmdpgm THEN DO
   call jcd
   call jcc "NOTE: The 'COMMAND' and/or 'WAIT' programs were not coded "
   call jcc "in the @PARMS member.  You will need to manually vary the "
   call jcc "disk unit for the rescue system offline, and online.      "
   call jcc " "
   call jcc "Before running this job, vary the disk unit offline from  "
   call jcc "the MVS console using the command: "
   call jcc "   V "addr",OFFLINE"
   call jcc "After replying to the the ICKDSF message to confirm the"
   call jcc "initialization of the disk pack, you will need to reply"
   call jcc "to the MVS allocation message with the address of the  "
   call jcc "new rescue volume, "addr"."
END
call jcd
call jcl "//EXPORTD    EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN      DD * "
call jcl "     EXPORT "newmcat "-"
call jcl "            DISCONNECT    "
call jcl "     SET MAXCC=0  "
/*---------------------------------------------------------*/
/* If COMMAND cmd is available, us it to do the VARY.      */
/*---------------------------------------------------------*/
IF cmdpgm THEN DO
   call jcd
   call jcc   " OFFLINE"
   call jcd
   call jcl "//OFFLINE1   EXEC" ,
            "PGM="commandpgm",PARM='V "addr",OFFLINE'"
   if addr2\=addr then
     call jcl "//OFFLINE2   EXEC" ,
              "PGM="commandpgm",PARM='V "addr2",OFFLINE'"
   if waipgm then
     call jcl "//WAIT       EXEC PGM="waitpgm",PARM=2"
END
call jcd
call jcc   "DSFINIT - DSF Initialize"
call jcd
call jcl "//DSFINIT  EXEC PGM=ICKDSF,PARM=NOREPLYU"
call jcl "//IPLTEXT  DD DISP=SHR,VOL=SER="sysres",UNIT=SYSALLDA,"
call jcl "//         DSN=SYS1.SAMPLIB(IPLRECS)"
call jcl "//         DD DISP=SHR,VOL=SER="sysres",UNIT=SYSALLDA,"
call jcl "//         DSN=SYS1.SAMPLIB(IEAIPL00)"
call jcl "//SYSPRINT DD     SYSOUT=* "
call jcl "//SYSIN      DD   *        "
call jcl " INIT     UNIT("addr") -   "
call jcl "          VOLID("volser") -"
call jcl "          VERIFY("volser") -"
call jcl "          VTOC(0,1,14) -"
call jcl "          PURGE -"
call jcl "          IPLDD(IPLTEXT) -"
call jcl "          BOOTSTRAP"
if addr2\=addr then
  do
    call jcl " INIT     UNIT("addr2") -"
    call jcl "          VOLID("volser2") -"
    call jcl "          VERIFY("volser2") -"
    call jcl "          VTOC(0,1,14) -"
    call jcl "          PURGE"
  end
/*---------------------------------------------------------*/
/* If COMMAND cmd is available, us it to do the VARY.      */
/*---------------------------------------------------------*/
IF cmdpgm THEN DO
   call jcd
   call jcc   " ONLINE - Vary the disk unit back online."
   call jcd
   call jcl "//ONLINE1  EXEC" ,
            "PGM="commandpgm",PARM='V "addr",ONLINE'"
   if addr2\=addr then
     call jcl "//ONLINE2  EXEC" ,
              "PGM="commandpgm",PARM='V "addr",ONLINE'"
   if waipgm then
     call jcl "//WAIT     EXEC PGM="WAITPGM",PARM=2"
END
call jcd
call jcc   "DEFVVDS - Define VVDS."
call jcd
call jcl "//DEFVVDS  EXEC PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=*"
call jcl "//TARGET   DD DISP=SHR,UNIT=SYSALLDA,VOL=SER="volser
call jcl "//SYSIN    DD *"
call jcl " DELETE    SYS1.VVDS.V"volser" -"
call jcl "           FILE(TARGET) CLUSTER PURGE -"
call jcl "           CATALOG("oldmcat") "
call jcl " SET MAXCC=0"
call jcl " DEFINE CLUSTER ( -"
call jcl "             NAME(SYS1.VVDS.V"volser") -"
call jcl "             CYL(1,1) -"
call jcl "             VOL("volser") -"
call jcl "             FILE(TARGET) - "
call jcl "             NONINDEXED - "
call jcl "             OWNER(RESCUE) ) -"
call jcl "          CATALOG("oldmcat")"
call subnext
call endjob
RETURN





/*=========================================================*/
/* Define master catalog.                                  */
/*=========================================================*/
#defmcat:
call newjob "Define master catalog"
call jcc "DEFMCAT  - Define new master catalog."
call jcd
call jcl "//DEFMCAT  EXEC PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN    DD * "
call jcl "      DEFINE USERCATALOG     ( -"
call jcl "             NAME("newmcat") -"
call jcl "             CYL(5 2) - "
call jcl "             VOL("volser") -"
call jcl "             BUFFERSPACE(8192) -"
call jcl "             BUFND(10) -"
call jcl "             BUFNI(10) -"
call jcl "             ICFCATALOG -"
call jcl "             STRNO(9) ) -"
call jcl "             CATALOG("oldmcat")"
IF VALUE("ssa") /= "SSA" & ssa /= "" THEN DO
   zzssa = STRIP(ssa,"B",".")   /* Get rid of trailing "." */
   call jcl "      IF MAXCC = 0 THEN DO "
   call jcl "         DELETE "zzssa" ALIAS"
   call jcl "         SET MAXCC=0"
   call jcl "         DEFINE ALIAS(NAME("zzssa") -"
   call jcl "         RELATE("newmcat")) -"
   call jcl "         CATALOG("oldmcat")"
   call jcl "      END"
END
call subnext
call endjob
RETURN





/*=========================================================*/
/* Define VSAM files.                                      */
/*=========================================================*/
#defvsam:
call newjob "Define VSAM files"
call jcc "DEFVSAM   - Define MANx, PAGE, STGINDEX datasets."
call jcc "FMTSMF    - Format SMF datasets."
call jcc "RENSMF    - Rename SMF datasets."
call jcd
call jcc "Define the datasets with the SSA prefix: "ssa", so that the"
call jcc "catalog entries are defined in our new rescue master catalog,"
call jcc newmcat". After the define, perform an IDCAMS ALTER to remove "
call jcc "the SSA prefix, and restore the file back to it's final name."
call jcc "These gyrations avoid the use of the STEPCAT DD statement  "
call jcc "which may become unsupported in the future."
call jcd
call jcc "We check for the SSA being defined before doing any defines."
call jcc "This prevents us from inadvertently storing junk in the "
call jcc "mster catalog of the driving system.                       "
call jcd
call jcl "//DEFVSAM  EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//TARGET   DD DISP=SHR,UNIT=SYSALLDA,VOL=SER="volser
call jcl "//SYSIN    DD * "
call jcl " LISTCAT ALL ENTRY("strip(ssa,"B",".")") ALIAS"
call jcl " IF LASTCC = 0 THEN DO"
call jcl "      DEFINE CLUSTER ( -"
call jcl "                NAME( "ssa"SYS1.STGINDEX ) -"
call jcl "                CYL(5) - "
call jcl "                VOL("volser") -"
call jcl "                BUFFERSPACE(20480) - "
call jcl "                FILE(TARGET) -"
call jcl "                KEYS(12 8) - "
call jcl "                RECORDSIZE(2041,2041) -"
call jcl "                REUSE ) - "
call jcl "             DATA ( -"
call jcl "                NAME( "ssa"SYS1.STGINDEX.DATA ) -"
call jcl "                CISZ(2048) ) - "
call jcl "             INDEX ( - "
call jcl "                NAME( "ssa"SYS1.STGINDEX.INDEX ) -"
call jcl "                CISZ(1024) )"
call jcl "       IF LASTCC = 0 THEN DO "
call jcl "          ALTER "ssa"SYS1.STGINDEX -"
call jcl "             NEWNAME( SYS1.STGINDEX ) -"
call jcl "             CATALOG("newmcat")"
call jcl "          ALTER "ssa"SYS1.STGINDEX.DATA -"
call jcl "             NEWNAME( SYS1.STGINDEX.DATA ) -"
call jcl "             CATALOG("newmcat")"
call jcl "          ALTER "ssa"SYS1.STGINDEX.INDEX -"
call jcl "             NEWNAME( SYS1.STGINDEX.INDEX ) -"
call jcl "             CATALOG("newmcat")"
call jcl "       END "
call jcl "     DEFINE PAGESPACE ( -"
call jcl "                NAME( "ssa"PAGE.RESCUE.PLPA) -"
call jcl "                   CYL(160) - "
call jcl "                   VOL("volser") -"
call jcl "                   FILE(TARGET) - "
call jcl "                   NOSWAP - "
call jcl "                   UNIQUE )  "
call jcl "       IF LASTCC = 0 THEN DO "
call jcl "          ALTER "ssa"PAGE.RESCUE.PLPA -"
call jcl "             NEWNAME( PAGE.RESCUE.PLPA ) - "
call jcl "             CATALOG("newmcat")"
call jcl "          ALTER "ssa"PAGE.RESCUE.PLPA.DATA -"
call jcl "             NEWNAME( PAGE.RESCUE.PLPA.DATA ) -"
call jcl "             CATALOG("newmcat")"
call jcl "       END "
call jcl "     DEFINE PAGESPACE ( - "
call jcl "                NAME( "ssa"PAGE.RESCUE.COMMON) -"
call jcl "                   CYL(50) - "
call jcl "                   VOL("volser") -"
call jcl "                   FILE(TARGET) - "
call jcl "                   NOSWAP - "
call jcl "                   UNIQUE )"
call jcl "       IF LASTCC = 0 THEN DO "
call jcl "          ALTER "ssa"PAGE.RESCUE.COMMON -"
call jcl "             NEWNAME( PAGE.RESCUE.COMMON ) -"
call jcl "             CATALOG("newmcat")"
call jcl "          ALTER "ssa"PAGE.RESCUE.COMMON.DATA -"
call jcl "             NEWNAME( PAGE.RESCUE.COMMON.DATA ) -"
call jcl "             CATALOG("newmcat")"
call jcl "       END "
call jcl "     DEFINE PAGESPACE ( -"
call jcl "                NAME( "ssa"PAGE.RESCUE.LOCAL1) -"
call jcl "                   CYL(200) - "
call jcl "                   VOL("volser") -"
call jcl "                   FILE(TARGET) -"
call jcl "                   NOSWAP - "
call jcl "                   UNIQUE )  "
call jcl "       IF LASTCC = 0 THEN DO "
call jcl "          ALTER "ssa"PAGE.RESCUE.LOCAL1 -"
call jcl "             NEWNAME( PAGE.RESCUE.LOCAL1 ) -"
call jcl "             CATALOG("newmcat")"
call jcl "          ALTER "ssa"PAGE.RESCUE.LOCAL1.DATA -"
call jcl "             NEWNAME( PAGE.RESCUE.LOCAL1.DATA ) -"
call jcl "             CATALOG("newmcat")"
call jcl "       END "

/*---------------------------------------------------------*/
/* Build defines for each SMF ds as defined in @DATASET,   */
/* i.e. dsns that have the SMF parm coded.                 */
/*---------------------------------------------------------*/
call smflist   /* Make list of SMF datasets. */

DO xx = 1 TO SMF.0
   smfds  = SMF.xx.$ds
   smfpri = SMF.xx.$pri
   smfpri = strip(smfpri,'L','0')
   call jcl "     DEFINE CLUSTER ( - "
   call jcl "                NAME( "ssa""smfds" ) -"
   call jcl "                   CYL( "smfpri" ) -"
   call jcl "                   VOL("volser") -"
   call jcl "                   CISZ(26624) - "
   call jcl "                   FILE(TARGET) - "
   call jcl "                   NONINDEXED - "
   call jcl "                   RECORDSIZE(26614 32767) - "
   call jcl "                   REUSE   SHR(2 3) - "
   call jcl "                   SPANNED  SPEED ) - "
   call jcl "             DATA ( -  "
   call jcl "                     NAME( "ssa""smfds".DATA) ) "
END

/*----------------------------------------------------------*/
/* Build defines for each COMMDS ds as defined in @DATASET, */
/* i.e. dsns that have the COMMDS parm coded.               */
/*----------------------------------------------------------*/
call commdslist   /* Make list of COMMDS datasets. */

if COMMDS.0\=1 then do
   say "==>" ,
       "IGDSMS00 not built -- COMMDS must be defined once in @DATASET."
   RETURN
END
DO xx = 1 TO COMMDS.0
   commds = COMMDS.xx.$ds
   commpri = COMMDS.xx.$pri
   commsec = COMMDS.xx.$sec
   commpri = strip(commpri,'L','0')
   commsec = strip(commsec,'L','0')
   call jcl "     DEFINE CLUSTER ( - "
   call jcl "                NAME( "ssa""commds" ) -"
   call jcl "                   CYL( "commpri" "commsec" ) -"
   call jcl "                   VOL("volser") -"
   call jcl "                   LINEAR - "
   call jcl "                   FILE(TARGET) - "
   call jcl "                   SHR(3 3)) - "
   call jcl "             DATA ( -  "
   call jcl "                     NAME( "ssa""commds".DATA) ) "
   call jcl "       IF LASTCC = 0 THEN DO "
   call jcl "          ALTER "ssa||commds" -"
   call jcl "             NEWNAME("commds" ) -"
   call jcl "             CATALOG("newmcat")"
   call jcl "       END "
END

/* Closing END from highest level IF LASTCC (from alias).  */
call jcl " END "

/*---------------------------------------------------------*/
/* Format SMF datasets.  They still have the SSA on front. */
/*---------------------------------------------------------*/
call jcd
call jcl "//FMTSMF EXEC PGM=IFASMFDP"
call jcl "//SYSPRINT DD SYSOUT=*"
DO xx = 1 TO SMF.0
   smfds = SMF.xx.$ds
   smfds = ssa""smfds
   call jcl "//"substr(llq(smfds),1,8)" DD DSN="smfds",DISP=SHR,"
   call jcl "//         UNIT="devtype",VOL=SER="volser
END
call jcl "//SYSIN    DD *"
DO xx = 1 TO SMF.0
   smfds = SMF.xx.$ds
   call jcl "   INDD("llq(smfds)",OPTIONS(CLEAR))"
END

/*---------------------------------------------------------*/
/* Rename SMF datasets to final name (remove SSA).         */
/*---------------------------------------------------------*/
call jcd
call jcl "//RENSMF EXEC PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=*"
call jcl "//SYSIN    DD *"
call jcl " LISTCAT ALL ENTRY("strip(ssa,"B",".")") ALIAS"
call jcl " IF LASTCC = 0 THEN DO"
DO xx = 1 TO SMF.0
   smfds = SMF.xx.$ds
   call jcl "       ALTER "ssa""smfds" -"
   call jcl "          NEWNAME( "smfds" ) -"
   call jcl "          CATALOG("newmcat")"
   call jcl "       ALTER "ssa""smfds".DATA -"
   call jcl "          NEWNAME( "smfds".DATA ) -"
   call jcl "          CATALOG("newmcat")"
END
call jcl " END"
call subnext
call endjob
RETURN





/*=========================================================*/
/* Define NONVSAM catalog entries.                         */
/*=========================================================*/
#defnvsm:
call newjob "Define NONVSAM catalog entries."
call jcc "NONVSAM  - Define non-VSAM catalog entries for datasets      "
call jcc "           not copied by DFDSS.  We only define datasets that"
call jcc "           are not processed by DFDSS, because DFDSS catalogs"
call jcc "           as part of the COPY operation."
call jcd
call jcl "//DEFNVSAM EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN    DD * "
call jcl " LISTCAT ENT("strip(ssa,"B",".")") ALIAS"
call jcl " IF LASTCC = 0 THEN DO"


do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   /* Symbolic substitution in case &WHATVER was specified. */
   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)
   IF zzmode = "D" THEN ITERATE
   IF zzmode = "S" THEN call defnvs
   IF zzmode = "C" THEN call defnvs
   IF zzmode = "G" THEN call defnvs
   IF zzmode = "N" THEN call defnvs
end
call jcl " END"
call subnext
call endjob
RETURN

/* subr */
defnvs:
IF zzdsn2 /= "" THEN tgtdsn = zzdsn2
ELSE tgtdsn = zzdsn1
call jcl "    DEFINE NONVSAM ( -"
call jcl "       NAME("ssa""tgtdsn") -"
call jcl "       DEVT("devtype") VOL("volser")) "
RETURN





/*=========================================================*/
/* Allocate nonVSAM datasets.                              */
/*=========================================================*/
#alcnvsm:
call newjob "Allocate NONVSAM datasets"
call jcc "ALLOCNVS - Allocate nonVSAM datasets.                "
call jcd
call jcl "//DEFNVSAM EXEC  PGM=IEFBR14"

do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   zzunit = strip(zzunit,"B");zzpri = strip(zzpri,"B")
   zzsec  = strip(zzsec,"B"); zzdir = strip(zzdir,"B")
   IF zzdsn1 = "" THEN ITERATE
   /* Symbolic substitution in case &WHATVER was specified. */
   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)
   IF zzmode = "D" THEN ITERATE
   IF zzmode = "H" THEN ITERATE
   IF zzmode = "S" THEN call allocn
   IF zzmode = "C" THEN call allocn
   IF zzmode = "G" THEN call allocn
   IF zzmode = "N" THEN call allocn
end
call subnext
call endjob
RETURN

/* subr */
allocn:
IF zzdsn2 /= "" THEN tgtdsn = zzdsn2
ELSE tgtdsn = zzdsn1
ddname = LEFT(llq(tgtdsn),8)
call jcl "//"ddname" DD DISP=(NEW,KEEP),UNIT="devtype","
call jcl "//         VOL=SER="volser",DSN="ssa""tgtdsn","
select
  when tgtdsn='SYS1.HASPPACE'|,
       tgtdsn='SYS1.HASPCKPT' then
    space=zzunit",("zzpri","zzsec","zzdir")"
  otherwise
    space=zzunit",("zzpri","zzsec","zzdir"),,CONTIG"
end
call jcl "//         SPACE=("space"),"
call jcl "//         DCB=("zzdsn1")"
RETURN






/*=========================================================*/
/* Copy datasets.                                          */
/*=========================================================*/
#copyds:
call newjob "Copy datasets"
call jcc "various  - Copy the datasets defined in the DATASETS member."
call jcd

dsscopy=0
dsscopy1.=''
dsscopy2.=''
dsscopycompcnt=0
dsscopycomp.=0
dsscopyrlsecnt=0
dsscopyrlse.=0

dsctr = 0
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zzparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   /* Symbolic substitution in case &WHATVER was specified. */
   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)
   dsctr = dsctr + 1
   IF zzmode = "D" THEN call copydss
   IF zzmode = "S" THEN call copysnap
   IF zzmode = "C" THEN call copyieb
   IF zzmode = "G" THEN call copygen
   IF zzmode = "N" THEN call copynon
   IF zzmode = "H" THEN call copyhfs
end
if dsscopy>0 then call copydssbuild
call subnext
call endjob
RETURN

/* subr */
copydss:
dsscopy=dsscopy+1
dsscopy1.dsscopy=zzdsn1
dsscopy2.dsscopy=zzdsn2
IF attrib('COMP',zzparms) THEN
  do
    dsscopycompcnt=dsscopycompcnt+1
    dsscopycomp.dsscopy=1
  end
IF attrib('RLSE',zzparms) THEN
  do
    dsscopyrlsecnt=dsscopyrlsecnt+1
    dsscopyrlse.dsscopy=1
  end
return

stepname = "DSSC"RIGHT("00000"dsctr,4)
call jcd
call jcc stepname "- DFDSS copy "zzdsn1"."
call jcd
call jcl "//"stepname" EXEC PGM=ADRDSSU"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN    DD * "
call jcl "      COPY DATASET( - "
call jcl "         INCLUDE("zzdsn1")) REPLACE -"
call jcl "         TOL(ENQF) BYPASSACS(**) NULLSTORCLAS PROCESS(SYS1) -"
IF zzdsn2 /= "" THEN,
call jcl "         RENAMEU("zzdsn1","zzdsn2") -"
call jcl "         RECATALOG("newmcat") OUTDYNAM("volser") SHARE"
call jcl "      IF MAXCC = 4 THEN SET MAXCC = 0"
IF attrib('RLSEIGNORE',zzparms) THEN
  do
    reldsn=zzdsn1
    IF zzdsn2 /= "" THEN reldsn=zzdsn2
    call jcl "      RELEASE INCLUDE("reldsn") -"
    call jcl "              INCAT("newmcat") ONLYINCAT -"
    call jcl "              LOGDYNAM("volser") PROCESS(SYS1)"
  end
RETURN

/* subr */
copydssbuild:
stepname = "DSSCOPY "
call jcd
call jcc stepname "- DFDSS copy."
call jcd
call jcl "//"stepname" EXEC PGM=ADRDSSU"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN    DD * "
call jcl "      COPY DATASET(INCLUDE( -"
do i=1 to dsscopy
  call jcl "            "dsscopy1.i" -"
end
call jcl "           )) - "
doneren=0
do i=1 to dsscopy
  if dsscopy2.i/="" then
    do
      if \doneren then
        do
          doneren=1
          call jcl "           RENAMEU( -"
        end
      call jcl "                    ("dsscopy1.i", -"
      call jcl "                     "dsscopy2.i") -"
    end
end
if doneren then call jcl "                  ) -"
call jcl "         TOL(ENQF) BYPASSACS(**) NULLSTORCLAS PROCESS(SYS1) -"
call jcl "         RECATALOG("newmcat") OUTDYNAM("volser") SHARE"
call jcl "      IF MAXCC = 4 THEN SET MAXCC = 0"

return

if dsscopyrlsecnt>0 then
  do
    stepname = "DSSRLSE "
    call jcd
    call jcc stepname "- DFDSS release."
    call jcd
    call jcl "//"stepname" EXEC PGM=ADRDSSU"
    call jcl "//SYSPRINT DD SYSOUT=* "
    call jcl "//SYSIN    DD * "
    call jcl "      RELEASE INCLUDE( -"
    do i=1 to dsscopy
      if dsscopyrlse.i then
        do
          reldsn=dsscopy1.i
          if dsscopy2.i/='' then reldsn=dsscopy2.i
          call jcl "                    "reldsn" -"
        end
    end
    call jcl "              ) -"
    call jcl "              INCAT("newmcat") ONLYINCAT -"
    call jcl "              LOGDYNAM("volser") PROCESS(SYS1)"
  end
RETURN

/* subr */
copysnap:
stepname = "SNAP"RIGHT("00000"dsctr,4)
call jcd
call jcc stepname "- Snap "zzdsn1"."
call jcd
call jcl "//"stepname" EXEC PGM=SIBBATCH"
call jcl "//CTRANS   DD DSN=STK.SVA310.SACLINK,DISP=SHR"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSTERM  DD SYSOUT=* "
call jcl "//SOURCE   DD DSN="zzdsn1",DISP=SHR"
IF zzdsn2 /= "" THEN tgtdsn = zzdsn2
ELSE tgtdsn = zzdsn1
call jcl "//TARGET   DD DSN="ssa""tgtdsn",DISP=SHR,"
call jcl "//         UNIT=SYSALLDA,VOL=SER="volser
call jcl "//SYSIN    DD * "
call jcl "      SNAP DATASET(INDD(SOURCE) OUTDD(TARGET) -"
call jcl "         HOSTCOPYMODE(SHARED) -"
call jcl "         TOLERATEENQFAILURE(YES) -"
call jcl "         REPLACE(YES) DATAMOVERNAME(DSS))"
RETURN

/* subr */
copyieb:
stepname = "IEBC"RIGHT("0000"dsctr,4)
call jcd
call jcc stepname "- IEBCOPY "zzdsn1"."
call jcd
call jcl "//"stepname" EXEC PGM=IEBCOPY"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSUT1   DD DSN="zzdsn1",DISP=SHR"
IF zzdsn2 /= "" THEN tgtdsn = zzdsn2
ELSE tgtdsn = zzdsn1
call jcl "//SYSUT2   DD DSN="ssa""tgtdsn",DISP=SHR,"
IF attrib('RLSE',zzparms) THEN, /* If RLSE, specify RLSE.     */
call jcl "//         SPACE=(CYL,(1,1,1),RLSE),"
call jcl "//         UNIT=SYSALLDA,VOL=SER="volser
call jcl "//SYSIN    DD * "
call jcl "  COPY I=SYSUT1,O=SYSUT2,LIST=NO "
RETURN

/* subr */
copygen:
stepname = "GENR"RIGHT("0000"dsctr,4)
call jcd
call jcc stepname "- IEBGENER "zzdsn1"."
call jcd
call jcl "//"stepname" EXEC PGM=IEBGENER"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSUT1   DD DSN="zzdsn1",DISP=SHR"
IF zzdsn2 /= "" THEN tgtdsn = zzdsn2
ELSE tgtdsn = zzdsn1
call jcl "//SYSUT2   DD DSN="ssa""tgtdsn",DISP=SHR,"
IF attrib('RLSE',zzparms) THEN, /* If RLSE, specify RLSE.     */
call jcl "//         SPACE=(CYL,(1,1,1),RLSE),"
call jcl "//         UNIT=SYSALLDA,VOL=SER="volser
call jcl "//SYSIN    DD DUMMY"
RETURN

/* subr */
copynon:
return

stepname = "NOOP"RIGHT("0000"dsctr,4)
IF zzdsn2 /= "" THEN tgtdsn = zzdsn2
ELSE tgtdsn = zzdsn1
call jcd
call jcc stepname "- None: "tgtdsn" will not be copied."
call jcd
RETURN

/* subr */
copyhfs:
stepname = "HFSD"RIGHT("00000"dsctr,4)
call jcd
call jcc stepname
call jcc "Copy "zzdsn1" HFS with DFDSS DUMP and RESTORE."
IF zzdsn2 /= "" THEN,
call jcc "Target dsn is "zzdsn2"."
call jcd
call jcl "//"stepname" EXEC PGM=ADRDSSU"
call jcl "//SYSPRINT  DD SYSOUT=* "
call jcl "//TAPE      DD DISP=(,PASS),DSN=&&TAPE,UNIT=SYSALLDA,"
call jcl "//          VOL=SER="volser2",SPACE=(CYL,(1500,500),RLSE)"
call jcl "//SYSIN     DD * "
call jcl "  DUMP    DATASET(  -"
call jcl "          INCLUDE("zzdsn1")) -"
call jcl "          TOL(ENQF) -"
call jcl "          OUTDD(TAPE)"
stepnam2 = "HFSR"RIGHT("00000"dsctr,4)
call jcl "//"stepnam2" EXEC PGM=ADRDSSU,COND=(4,LT,"stepname")"
call jcl "//SYSPRINT  DD SYSOUT=* "
call jcl "//TAPE      DD DISP=(OLD,DELETE),DSN=&&TAPE"
call jcl "//SYSIN     DD * "
call jcl "  RESTORE DATASET( -"
call jcl "          INCLUDE(**)) -"
call jcl "          RECATALOG("newmcat") -"
call jcl "          BYPASSACS(**) -"
call jcl "          NULLSTORCLAS -"
IF zzdsn2 /= "" THEN,
call jcl "          RENAMEU("zzdsn1","zzdsn2") -"
call jcl "          OUTDYNAM("volser") -"
call jcl "          REPLACE TOL(ENQF) INDD(TAPE) "
RETURN





/*=========================================================*/
/* Alter NONVSAM entries back to final names. (Remove SYSR)*/
/*=========================================================*/
#altnvsm:
call newjob "Alter NONVSAM entries to final names"
call jcc "ALTERNVS - Alter NONVSAM names to final names, removing"
call jcc "           the "ssa" prefix. Since we aliased the SSA from"
call jcc "           the driving system's mastercat, we don't need to"
call jcc "           specify the RESCUE system catalog name in the "
call jcc "           ALTER statements. "
call jcd
call jcl "//ALTERNVS EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD    SYSOUT=*"
call jcl "//SYSIN    DD    *"

do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   /* Symbolic substitution in case &WHATVER was specified. */
   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)
   IF zzmode = "D" THEN ITERATE
   IF zzmode = "S" THEN call altern
   IF zzmode = "C" THEN call altern
   IF zzmode = "G" THEN call altern
   IF zzmode = "N" THEN call altern
end
call subnext
call endjob
RETURN

/* subr */
altern:
IF zzdsn2 /= "" THEN tgtdsn = zzdsn2
ELSE tgtdsn = zzdsn1
call jcl "  ALTER "ssa""tgtdsn" -"
call jcl "        NEWNAME("tgtdsn") -"
call jcl "        CATALOG("newmcat")"
RETURN





/*=========================================================*/
/* RACF Dataset Name Table (ICHRDSNT)                      */
/*=========================================================*/
#rfdsnt:
IF rfdsnt /= 'YES' THEN DO
   say "==>" ,
       "RFDSNT parameter not specified - ICHRDSNT assembly not created."
   RETURN
END

call makedsnt         /* Build the DSN table.              */
call iealpa ICHRDSNT  /* Build MLPA member to use ICHRDSNT.*/

return

/*=========================================================*/
/* RACF Dataset Name Table (ICHRDSNT)                      */
/*=========================================================*/
makedsnt:
call newjob "Assemble ICHRDSNT table"
call jcc "ASMLINK  - Assemble RACF dataset name table (ICHRDSNT)"
call jcd
call jcl "//ASMLINK  EXEC ASMACL,PARM.C='OBJECT,NODECK',"
call jcl "// PARM.L='SIZE=(320K,250K)' "
call jcl "//C.SYSLIB DD  DSN=SYS1.MACLIB,DISP=SHR "
call jcl "//         DD  DSN=SYS1.MODGEN,DISP=SHR "
call jcl "//SYSIN    DD  * "
call jcl "ICHRDSNT CSECT "
call jcl "         DC    AL1(1)             NUMBER OF RACF DATA"
call jcl "         DC    CL44'"racfds"'     RACF PRIMARY DATASET"
call jcl "         DC    CL44' '            RACF BACKUP DATASET"
call jcl "         DC    AL1(255)           RESIDENT INDEX BLKS"
call jcl "         DC    XL1'81'            DUPLICATE ALL EXCEPT"
call jcl "         END"
call jcl "//L.SYSLMOD     DD DSN=SYS1.RESCUE.LINKLIB,DISP=SHR,"
call jcl "//  UNIT=SYSALLDA,VOL=SER="volser
call jcl "//L.SYSIN       DD *"
call jcl "  NAME ICHRDSNT(R) "
call subnext
call endjob
RETURN



/*=========================================================*/
/* RACF Started Task Table (ICHRIN03)                      */
/*=========================================================*/
#rfstc:
IF rfstc /= 'YES' THEN DO
   say "==>" ,
       "RFSTC parameter not specified - ICHRIN03 assembly not created."
   RETURN
END

call makestc          /* Build the STC table.              */
call iealpa ICHRIN03  /* Build MLPA member to use ICHRIN03.*/
call defids           /* Create RACF groups/IDs as needed. */

return

/*=========================================================*/
/* RACF Started Task Table (ICHRIN03)                      */
/*=========================================================*/
makestc:
call newjob "Assemble ICHRIN03 table"
call jcc "ASMLINK  - Assemble RACF Started Task Table (ICHRIN03)"
call jcd
call jcl "//ASMLINK  EXEC ASMACL,PARM.C='OBJECT,NODECK',"
call jcl "// PARM.L='SIZE=(320K,250K)' "
call jcl "//C.SYSLIB DD  DSN=SYS1.MACLIB,DISP=SHR "
call jcl "//         DD  DSN=SYS1.MODGEN,DISP=SHR "
call jcl "//SYSIN    DD  * "
call jcl "ICHRIN03 CSECT                                               "
call jcl "TABSTART DC    AL2(NUMENTR)              NUMBER OF ENTRIES   "

privflag = "X'8000000000000000'"
stdflag  = "X'0000000000000000'"

/*------------------------------------------------------------------*/
/* Use STC's from @PARMS.  RFSTCx = VTAM, $RESCUE, $STC             */
/* p1 = Task name, p2 = RACF ID, p3 = RACF Grp.                     */
/*------------------------------------------------------------------*/
stc.0 = 0
DO xx = 1 TO 99
   IF VALUE("RFSTC"xx) = "RFSTC"xx THEN LEAVE
   ent = VALUE("RFSTC"xx)
   PARSE VAR ent zztask ',' zzid ',' zzgrp .
   zztask = strip(zztask,"B")
   zzid = strip(zzid,"B")
   zzgrp  = strip(zzgrp,"B")
   stc.xx = substr(zztask,1,8)""substr(zzid,1,8)""substr(zzgrp,1,8)
END
stc.0 = xx-1
/*------------------------------------------------------------------*/
/* Loop through the entries we've built, and put them in DC stmts.  */
/* Assume trusted and proviledged for all defined tasks.            */
/*------------------------------------------------------------------*/
DO xx = 1 TO stc.0
   call jcl "         DC    C'"stc.xx"',"privflag
END
/*------------------------------------------------------------------*/
/* Finish up the source for the table, and the rest of the JCL.     */
/*------------------------------------------------------------------*/
call jcl "         DC    C'*       =       STC     ',"stdflag
call jcl "NUMENTR  EQU   (*-TABSTART-2)/32+X'8000'"
call jcl "         DC    C'&SYSDATE' "
call jcl "         DC    C'&SYSTIME' "
call jcl "         END "
call jcl "//L.SYSLMOD     DD DSN=SYS1.RESCUE.LINKLIB,DISP=SHR,"
call jcl "//  UNIT=SYSALLDA,VOL=SER="volser
call jcl "//L.SYSIN       DD *"
call jcl "  NAME ICHRIN03(R) "
call subnext
call endjob
RETURN


/*=========================================================*/
/* JOB: Define RACF IDs needed for RESCUE system.          */
/* JOB: ID submitting job mist have RACF SPECIAL.          */
/*=========================================================*/
defids:
call newjob "Define RACF IDs and Groups for STCs"
call jcc "RFSTCDEF - Create RACF IDs and groups for started tasks."
call jcd
/*---------------------------------------------------------*/
/* Be sure we have RACF special.                           */
/*---------------------------------------------------------*/
IF \racfspec() THEN DO
   call jcc "*** NOTE: ***"
   call jcc "Userid "USERID()" was used to build this job, but does "
   call jcc "not have the RACF SPECIAL attribute.  If "USERID()" is "
   call jcc "used to run this job, it should first be granted the   "
   call jcc "SPECIAL attribute or the equivalent specific privileges "
   call jcc "needed be to run successfully. RACF violations will  "
   call jcc "result if this is not done."
END
ELSE DO
   call jcc "NOTE: Be sure that the ID used to run this job has the"
   call jcc "RACF SPECIAL attribute, or the equivalent specific    "
   call jcc "privileges required."
END
call jcd
call jcl "//RFSTCDEF EXEC PGM=IKJEFT01,REGION=4M"
call jcl "//SYSPRINT DD SYSOUT=*"
call jcl "//SYSIN    DD DUMMY   "
call jcl "//SYSTSPRT DD SYSOUT=*"
call jcl "//SYSTSIN  DD *"

/*------------------------------------------------------------------*/
/* Delete RACF IDs and Groups.                                      */
/*------------------------------------------------------------------*/
/* Use RFSTCx parms from @PARMS to get userids to be defined.       */
/* Delete each GROUP and ID first, but only if they are not already */
/* defined to the driving system.                                   */
/* jobs to be re-run if desired.                                    */
/*------------------------------------------------------------------*/
DO xx = 1 TO 99
   IF VALUE("RFSTC"xx) = "RFSTC"xx THEN LEAVE
   ent = VALUE("RFSTC"xx)
   ent = translate(ent,' ',',')
   PARSE VAR ent zztask zzid zzgrp .
   zztask = strip(zztask,"B"); zzid = strip(zzid,"B");
   zzgrp  = strip(zzgrp,"B")
   /* Delete ID if needed. */
   IF ckstcid(zzid) THEN DO
      c1 = " DELUSER  "zzid
      IF \idthere(zzid) THEN DO
         call jcl " "
         call jcl c1
      END
      ELSE DO
      /* Comment out the commands, because the ID was already there. */
         say "   " ,
             zzid" is already defined to RACF, and was not deleted."
         call jcl " "
         e1  = " "zzid" is already defined to RACF, and was"
         e2  = " not deleted.  Select an ID that does not"
         e3  = " already exist, and change the RFSTC statements"
         e4  = " in the @PARMS member and rerun the rescue execs."
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(e1,1,60)" */"
         call jcl " /*"substr(e2,1,60)" */"
         call jcl " /*"substr(e3,1,60)" */"
         call jcl " /*"substr(e4,1,60)" */"
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(c1,1,60)" */"
      END
   END
END
DO xx = 1 TO 99
   IF VALUE("RFSTC"xx) = "RFSTC"xx THEN LEAVE
   ent = VALUE("RFSTC"xx)
   ent = translate(ent,' ',',')
   PARSE VAR ent zztask zzid zzgrp .
   zztask = strip(zztask,"B"); zzid = strip(zzid,"B");
   zzgrp  = strip(zzgrp,"B")
   /* Delete group if needed. */
   IF ckstcgrp(zzgrp) THEN DO
      c1 = " DELGROUP "zzgrp
      IF \grpthere(zzgrp) THEN DO
         call jcl " "
         call jcl c1
      END
      ELSE DO
         say "   " ,
             zzgrp" is already defined to RACF, and was not deleted."
         call jcl " "
         e1  = " "zzgrp" is already defined to RACF, and was"
         e2  = " not deleted.  Select a Group that does not"
         e3  = " already exist, and change the RFSTC statements"
         e4  = " in the @PARMS member and rerun the rescue execs."
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(e1,1,60)" */"
         call jcl " /*"substr(e2,1,60)" */"
         call jcl " /*"substr(e3,1,60)" */"
         call jcl " /*"substr(e4,1,60)" */"
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(c1,1,60)" */"
      END
   END
END
DROP STCID.
DROP STCGRP.

/*------------------------------------------------------------------*/
/* Define RACF IDs and Groups.                                      */
/*------------------------------------------------------------------*/
/* Use RFSTCx parms from @PARMS to get userids to be defined.       */
/* Define each group and user as needed, but only if they are not   */
/* defined yet. Code a DELGROUP and DELUSER statement to allow the  */
/* jobs to be re-run if desired.                                    */
/*------------------------------------------------------------------*/
DO xx = 1 TO 99
   IF VALUE("RFSTC"xx) = "RFSTC"xx THEN LEAVE
   ent = VALUE("RFSTC"xx)
   ent = translate(ent,' ',',')
   PARSE VAR ent zztask zzid zzgrp .
   zztask = strip(zztask,"B"); zzid = strip(zzid,"B");
   zzgrp  = strip(zzgrp,"B")
   /* Define group if needed. */
   IF ckstcgrp(zzgrp) THEN DO
      c1 = " ADDGROUP "zzgrp" OWNER(SYS1) SUP(SYS1) +"
      c2 = " OMVS(gid(0))"
      IF \grpthere(zzgrp) THEN DO
         call jcl " "
         call jcl c1
         call jcl c2
      END
      ELSE DO
         say "   " ,
             zzgrp" is already defined to RACF, and was not created."
         call jcl " "
         e1  = " "zzgrp" is already defined to RACF, and was"
         e2  = " not created.  Select a Group that does not"
         e3  = " already exist, and change the RFSTC statements"
         e4  = " in the @PARMS member and rerun the rescue execs."
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(e1,1,60)" */"
         call jcl " /*"substr(e2,1,60)" */"
         call jcl " /*"substr(e3,1,60)" */"
         call jcl " /*"substr(e4,1,60)" */"
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(c1,1,60)" */"
         call jcl " /*"substr(c2,1,60)" */"
      END
   END
END
DO xx = 1 TO 99
   IF VALUE("RFSTC"xx) = "RFSTC"xx THEN LEAVE
   ent = VALUE("RFSTC"xx)
   ent = translate(ent,' ',',')
   PARSE VAR ent zztask zzid zzgrp .
   zztask = strip(zztask,"B"); zzid = strip(zzid,"B");
   zzgrp  = strip(zzgrp,"B")
   /* Define ID if needed. */
   IF ckstcid(zzid) THEN DO
      c1 = " ADDUSER  "zzid" OWNER(SYS1) DFLTGRP("zzgrp") +"
      c2 = " OPERATIONS NOPASSWORD NAME('Rescue System') + "
      c3 = " OMVS(uid(0) home('/') program('/bin/sh') )"
      IF \idthere(zzid) THEN DO
         call jcl " "
         call jcl c1
         call jcl c2
         call jcl c3
      END
      ELSE DO
      /* Comment out the commands, because the ID was already there. */
         say "   " ,
             zzid" is already defined to RACF, and was not created."
         call jcl " "
         e1  = " "zzid" is already defined to RACF, and was"
         e2  = " not created.  Select an ID that does not"
         e3  = " already exist, and change the RFSTC statements"
         e4  = " in the @PARMS member and rerun the rescue execs."
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(e1,1,60)" */"
         call jcl " /*"substr(e2,1,60)" */"
         call jcl " /*"substr(e3,1,60)" */"
         call jcl " /*"substr(e4,1,60)" */"
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(c1,1,60)" */"
         call jcl " /*"substr(c1,1,60)" */"
         call jcl " /*"substr(c2,1,60)" */"
         call jcl " /*"substr(c3,1,60)" */"
      END
   END
END

/*-------------------------------------------*/
/*- Define the TSO PROC to RACF             -*/
/*-------------------------------------------*/

/*

Assume we're OK on this rather than possibly messing up a
TSOPROC entry on the driving system

call jcl " RDEFINE TSOPROC "tsoproc" UACC(READ)"
call jcl " RALTER  TSOPROC "tsoproc" UACC(READ)"
call jcl " SETROPTS RACLIST(TSOPROC) REFRESH"
*/
call subnext
call endjob
RETURN





/*=========================================================*/
/* Copy the RACF dataset.                                  */
/*=========================================================*/
#rfcopy:

IF VALUE("racfds") = "RACFDS" | racfds = "" THEN DO
   say "==>" ,
       'RACFDS parameter not specified - RACF dataset not copied.'
   RETURN
END

/*---------------------------------------------------------*/
/* Get DS info.                                            */
/*---------------------------------------------------------*/
x = listdsi("'"racfds"'")
units = 'CYL'
IF sysunits = 'TRACK' THEN units = 'TRK'

/* If RACFVOL specified, specify it in the JCL.            */
IF VALUE("racfvol") = "RACFVOL" | racfvol = "" THEN rfvol = ""
ELSE rfvol = racfvol

/* Build SPACE= parm.                                      */
spaceprm = "SPACE=("units",("sysprimary","sysseconds"))"

/*---------------------------------------------------------*/
/* Build JCL.                                              */
/*---------------------------------------------------------*/
call newjob "Copy RACF Dataset"
call jcc "RACFCOPY - Copy the RACF dataset."
call jcd
call jcl "//RACFCOPY EXEC PGM=IRRUT400,PARM='NOLOCKINPUT,FREESPACE(20)'"
call jcl "//SYSPRINT DD SYSOUT=*"
call jcl "//INDD1    DD DSN="racfds",DISP=OLD,"
call jcl "//         UNIT=SYSALLDA,VOL=SER="rfvol
call jcl "//OUTDD1   DD DSN="ssa""racfds",DISP=(,CATLG),"
call jcl "//         UNIT=SYSALLDA,VOL=SER="volser","
call jcl "//         DCB=("racfds"),"spaceprm
call jcl "//UNLOCK   EXEC PGM=IRRUT400,PARM='UNLOCKINPUT'"
call jcl "//SYSPRINT DD SYSOUT=*"
call jcl "//INDD1    DD DSN="racfds",DISP=OLD,"
call jcl "//         UNIT=SYSALLDA,VOL=SER="rfvol
/*-------------------------------------------*/
/* Alter RF DS name to final name (dump SSA) */
/*-------------------------------------------*/
call jcd
call jcc "ALTERRF  - Change the RACF Dataset name to its final"
call jcc "           name without the "ssa" prefix."
call jcd
call jcl "//ALTERRF  EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD    SYSOUT=*"
call jcl "//SYSIN    DD    *"
call jcl "  ALTER "ssa""racfds" -"
call jcl "        NEWNAME("racfds") -"
call jcl "        CATALOG("newmcat")"
call subnext
call endjob
RETURN





/*=====================================*/
/*  Build the LOAD00 member            */
/*=====================================*/
iodf:
call newmem "LOAD00", "IPLPARM member"
##iodf = "00"
##iodfsys = "SYS1"
/* See if nonstandard SYSx prefix. */
IF substr(iodf,1,3) = 'SYS' THEN DO
   PARSE VAR iodf ##iodfsys "." .
END

/* See if nonstandard IODFxx prefix. */
##y9 = POS('.IODF',iodf)
IF ##y9 > 0 THEN ##iodf = substr(iodf,##y9+5,2)
if VALUE('EDTID')='EDTID' | edtid='' then edtid='00'
call jcl "IODF     "##iodf" "substr(##iodfsys,1,8)"",
         substr(ioconfigid,1,9)||substr(edtid,1,2)
call jcl "NUCLEUS  1"
call jcl "SYSCAT   "substr(volser,1,6)"113C"newmcat

/* Add PARMLIBs */
libs = xdslist('PARMLIB')
DO x = 1 TO WORDS(libs)
   call jcl "PARMLIB  "substr(WORD(libs,x),1,45)volser
END
call clsout pds
RETURN

/*=====================================*/
/*  Build the PROGA0 member (APF libs) */
/*=====================================*/
apf:
call newmem "PROGA0", "PARMLIB member"

call jcl "/*--------------------------------------------------*/"
call jcl "/* APF entries dynamically built by RESCUE exec.    */"
call jcl "/*--------------------------------------------------*/"
call jcl "APF FORMAT(DYNAMIC)"

/* Add APF LIBs */
libs = xdslist('APF')
DO x = 1 TO WORDS(libs)
   ##z10 = "APF ADD "substr("DSNAME("WORD(libs,x)")",1,46)
   ##z10 = ##z10"VOLUME("volser")"
   call jcl ##z10
END
call clsout pds
RETURN

/*=====================================*/
/*  Build the PROGL0 member (LNKlist)  */
/*=====================================*/
lnklst:
call newmem "PROGL0", "PARMLIB member"

call jcl "/*--------------------------------------------------*/"
call jcl "/* LNKLST entries dynamically built by RESCUE exec. */"
call jcl "/*--------------------------------------------------*/"
call jcl "LNKLST DEFINE NAME(LNKLST00)"

/* Add LNKLST LIBs */
libs = xdslist('LNK')
DO x = 1 TO WORDS(libs)
   ##z10 = "LNKLST ADD NAME(LNKLST00)"
   call jcl ##z10
   ##z10 = "     DSNAME("substr(WORD(libs,x)")",1,40)"VOLUME("volser")"
   call jcl ##z10
END

call jcl "LNKLST ACTIVATE NAME(LNKLST00)"
call clsout pds
RETURN

/*=====================================*/
/*  Build the LPALST member.           */
/*=====================================*/
lpa:
call newmem "LPALST00", "PARMLIB member"

/* Add LPALST LIBs */
libs = xdslist('LPA')
DO x = 1 TO WORDS(libs)
   IF x < WORDS(libs) THEN,
   call jcl WORD(libs,x)","
   ELSE,
   call jcl WORD(libs,x)
END

call clsout pds
RETURN


/*=====================================*/
/*  Build the JES2 PROC.               */
/*=====================================*/
jes2:
call newmem "JES2", "JES2 Procedure"

call jcd
call jcc "JES2 Startup PROC."
call jcc "Built dynamically by RESCUE exec, "mydate
call jcd
call jcl "//JES2     PROC JESPARM=JES2PARM"
call jcl "//IEFPROC  EXEC PGM=HASJES20,"
call jcl "//            DPRTY=(15,15),TIME=1440,PERFORM=9"
call jcl "//HASPPARM DD DISP=SHR,DSN=SYS1.RESCUE.PARMLIB(&JESPARM)"

/* Add PROCLIBs */
libs = xdslist('JES2')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//PROC00   DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

call jcl "//*"
call jcl "//IEFRDER  DD SYSOUT=*"
call jcl "//*"
call jcl "//HASPLIST DD DDNAME=IEFRDER"
call jcl "//*"
call endjob

RETURN

/*=====================================*/
/*  Build the JES2PARM member.         */
/*=====================================*/
jes2parm:
call newmem "JES2PARM", "JES2 PARMLIB member"
call setinp pds,'ZJES2PRM','JES2PRM.' /* Input member name.  */

call jcl "/*-------------------------------------------------------*/"
call jcl "/* JES2 Parameter deck.                                  */"
call jcl "/* Built dynamically by RESCUE exec, "mydate"            */"
call jcl "/*-------------------------------------------------------*/"
call jcl "CKPTDEF  CKPT1=(DSNAME="chkpoint","
call jcl "         INUSE=YES,VOLSER="volser"),MODE=DUAL,DUPLEX=OFF"
call jcl "SPOOLDEF BUFSIZE=3992," /* was 3856 */
call jcl "         DSNAME="spool","
call jcl "         FENCE=NO,"
call jcl "         SPOOLNUM=32,"
call jcl "         TGBPERVL=5,"
call jcl "         TGSPACE=(MAX=16288,WARN=80),"
call jcl "         TGSIZE=36,"    /* was 33 */
call jcl "         TRKCELL=3,"    /* was 5 */
call jcl "         VOLUME="spoolvol
/*-------------------------------------*/
/*  Copy rest of parms from JES2PRM.   */
/*-------------------------------------*/
DO x = 1 TO JES2PRM.0
   call jcl JES2PRM.x
END

call clsout pds,'JES2PARM'
DROP JES2PRM.

RETURN


/*=====================================*/
/*  Build the BPXPRM00 member.         */
/*=====================================*/
bpxprm:
call newmem "BPXPRM00", "OMVS PARMLIB member"
call setinp pds,'ZBPXPRM','BPXPRM.' /* Input member name. */

/*--------------------------------------------------------*/
/*  Create haeader and copy main part of BPXPRM.          */
/*--------------------------------------------------------*/
call jcl "/*-------------------------------------------------------*/"
call jcl "/* OMVS parameters.                                      */"
call jcl "/* Built dynamically by RESCUE exec, "mydate"            */"
call jcl "/*-------------------------------------------------------*/"
DO x = 1 TO BPXPRM.0
   call jcl BPXPRM.x
END
call jcl " "

/*--------------------------------------------------------*/
/*  Build MOUNT statments for OMVS libs.                  */
/*--------------------------------------------------------*/
DO x = 1 TO DSNS.0
   /*--------------------------------------------------------*/
   /* Parse out dsn1, dsn2 and the parms for each dataset in */
   /* the @DATASET member.  Any that have OMVSxxx will have  */
   /* a mount entry defined in BPXPRM00.                     */
   /*--------------------------------------------------------*/
   PARSE VAR DSNS.x . ',' . ',' . ',' . ',' . ',',
                    zzdsn1 ',' zzdsn2 ',' '(' zzparms ')' .
   /* Symbolic substitution in case &WHATVER was specified. */
   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)
   IF POS('OMVS',zzparms) = 0 THEN ITERATE
   PARSE VAR zzparms 'OMVS' omvsprm .    /* Is this an OMVS* entry? */
   IF zzdsn2 /= "" THEN zzdsn = zzdsn2   /* Use dsn2 if its there.  */
   ELSE zzdsn = zzdsn1
   /* Yes, it's an OMVS parm, so make a MOUNT command for it.*/
   IF omvsprm /= "" THEN call omvsmnt omvsprm, zzdsn
END

call clsout pds
DROP BPXPRM.
RETURN

/*=====================================*/
/*  Build the SMFPRM00 member.         */
/*=====================================*/
smfprm:
call newmem "SMFPRM00", "PARMLIB member"

/*--------------------------------------------------------*/
/*  Create haeader and copy main part of BPXPRM.          */
/*--------------------------------------------------------*/
call jcl "/*-------------------------------------------------------*/"
call jcl "/* SMF parameters.                                       */"
call jcl "/* Built dynamically by RESCUE exec, "mydate"            */"
call jcl "/*-------------------------------------------------------*/"
call jcl " ACTIVE"

call smflist   /* Make list of SMF datasets. */
DO xx = 1 TO SMF.0
   smfds  = SMF.xx.$ds
   select
     when xx=1 & SMF.0=1 then
       call jcl " DSNAME("smfds")"
     when xx=1 then
       call jcl " DSNAME("smfds","
     when xx=SMF.0 then
       call jcl "        "smfds")"
    otherwise
       call jcl "        "smfds","
  end
END
call jcl " INTVAL(15)"
call jcl " JWT(0030)"
call jcl " LISTDSN"
call jcl " MAXDORM(3000)"
call jcl " NOPROMPT"
call jcl " REC(PERM)"
call jcl " SID("smfid")"
call jcl " STATUS(SMF,SYNC)"
call jcl " SYNCVAL(00)"
call jcl " SYS(NOTYPE(19),EXITS(IEFU83,IEFACTRT,IEFUJI,IEFU29),"
call jcl "     DETAIL,INTERVAL(SMF,SYNC))"
call jcl " SUBSYS(STC,EXITS(IEFUJI,IEFACTRT,IEFU83,IEFU29))"
call jcl " SUBSYS(JES2,EXITS(IEFUJI,IEFACTRT,IEFU83))"

call clsout pds
RETURN

/* subr. */
omvsmnt:
PARSE ARG ##omvsprm, ##omvsds
IF ##omvsprm = '/'    THEN DO
   call jcl "ROOT     FILESYSTEM('"##omvsds"')"
   call jcl "         TYPE(HFS)"
   call jcl "         MODE(RDWR)"
   call jcl " "
END
ELSE DO
   call jcl "MOUNT    FILESYSTEM('"##omvsds"')"
   call jcl "         MOUNTPOINT('"##omvsprm"')"
   call jcl "         TYPE(HFS)"
   call jcl "         MODE(RDWR)"
   call jcl " "
END
RETURN

/*=====================================*/
/*  Build the TSO LOGON PROC.          */
/*=====================================*/
tsoproc:
IF SYMBOL("TSOPROC") = 'LIT' THEN DO
   say "==>" ,
       "TSOPROC name not defined in @PARMS member, no TSO PROC created."
   RETURN
END

call newmem tsoproc, "TSO Procedurer"

call jcd
call jcc "TSO LOGON PROC"tsoproc"."
call jcc "Built dynamically by RESCUE exec, "mydate
call jcd
p = substr(tsoproc,1,8)
call jcl "//"p" PROC"
call jcl "//IKJACCNT EXEC PGM=IKJEFT01,"
call jcl "//             DYNAMNBR=200,"
call jcl "//             TIME=1440,"
call jcl "//             PARM='%ISPALLOC'"

/* Add ISPPLIBs */
libs = xdslist('ISPPLIB')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//ISPPLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add ISPMLIBs */
libs = xdslist('ISPMLIB')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//ISPMLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add ISPSLIBs */
libs = xdslist('ISPSLIB')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//ISPSLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add ISPLLIBs */
libs = xdslist('ISPLLIB')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//ISPLLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add ISPTLIBs */
libs = xdslist('ISPTLIB')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//ISPTLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add SYSPROCs */
sysproclibs = xdslist('SYSPROC')
DO x = 1 TO WORDS(sysproclibs)
   IF x = 1 THEN,
   call jcl "//SYSPROC  DD DISP=SHR,DSN="WORD(sysproclibs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(sysproclibs,x)
END

/* Add SYSHELPs */
libs = xdslist('SYSHELP')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//SYSHELP  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add SYSLBC */
libs = xdslist('SYSLBC')
IF words(libs) > 0 THEN DO
   call jcl "//SYSLBC   DD DISP=SHR,DSN="WORD(libs,1)
END

/* Add MISC LOGON statements. */

call jcl "//SYSPRINT DD TERM=TS,SYSOUT=Z"
call jcl "//SYSTERM  DD TERM=TS,SYSOUT=Z"
call jcl "//SYSIN    DD TERM=TS "
call clsout pds
RETURN

/*=====================================*/
/*  Build the COFVLF00 member.         */
/*=====================================*/
cofvlf:
call newmem "COFVLF00", "PARMLIB member"

/*--------------------------------------------------------*/
/*  Create haeader and copy main part of BPXPRM.          */
/*--------------------------------------------------------*/
call jcl "/*-------------------------------------------------------*/"
call jcl "/* VLF parameters.                                       */"
call jcl "/* Built dynamically by RESCUE exec, "mydate"            */"
call jcl "/*-------------------------------------------------------*/"
call jcl "CLASS NAME(CSVLLA) "
call jcl "      EMAJ(LLA) "
call jcl "      MAXVIRT(4096) "
call jcl "CLASS NAME(IRRGTS) "
call jcl "      EMAJ(GTS) "
call jcl "      MAXVIRT(256) "
call jcl "CLASS NAME(IRRACEE) "
call jcl "      EMAJ(ACEE) "
call jcl "CLASS NAME(IKJEXEC) "
/* Add SYSPROCs */
DO x = 1 TO WORDS(sysproclibs)
   call jcl "      EDSN("WORD(sysproclibs,x)")"
END
call jcl "      MAXVIRT(256) "
call jcl "CLASS NAME(IRRGMAP) "
call jcl "      EMAJ(GMAP) "
call jcl "CLASS NAME(IRRUMAP) "
call jcl "      EMAJ(UMAP) "
call jcl "CLASS NAME(IRRSMAP) "
call jcl "      EMAJ(SMAP) "

call clsout pds
RETURN




/*=====================================*/
/*  Build the VTAM startup PROC.       */
/*=====================================*/
vtamproc:
call newmem "VTAM", "VTAM Procedure"

call jcd
call jcc "VTAM Started procedure."
call jcc "Built dynamically by RESCUE exec, "mydate
call jcd
call jcl "//VTAM     EXEC PGM=ISTINM01,REGION=0M,"
call jcl "//         DPRTY=(15,15),TIME=1440,PERFORM=8"

/* Add VTAMLSTs */
libs = xdslist('VTAMLST')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//VTAMLST  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add VTAMLIBs */
libs = xdslist('VTAMLIB')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//VTAMLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END
sistclib = 'SYS1.SISTCLIB'
IF xdsthere(sistclib) THEN,
call jcl "//SISTCLIB DD DISP=SHR,DSN="sistclib

call jcl "//SYSABEND DD SYSOUT=*,HOLD=YES"
call clsout pds
RETURN

/*=====================================*/
/*  Build Master JCL deck (MSTJCL01)   */
/*=====================================*/
mstrjcl:
call newmem "MSTJCL01", "Master JCL PARMLIB member"

call jcl "//MSTJCL01 JOB MSGLEVEL=(1,1),TIME=1440"
call jcd
call jcc "Master JCL."
call jcc "Built dynamically by RESCUE exec, "mydate
call jcd
call jcl "//         EXEC PGM=IEEMB860,DPRTY=(15,15)"
call jcl "//STCINRDR DD SYSOUT=(A,INTRDR)"
call jcl "//TSOINRDR DD SYSOUT=(A,INTRDR)"

/* Add PROCLIBs */
libs = xdslist('JES2')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//IEFPDSI  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add SYSUADSs */
libs = xdslist('SYSUADS')
IF WORDS(libs) > 0 THEN,
   call jcl "//SYSUADS  DD DISP=SHR,DSN="WORD(libs,1)

/* Add SYSLBCs */
libs = xdslist('SYSLBC')
IF WORDS(libs) > 0 THEN,
   call jcl "//SYSLBC   DD DISP=SHR,DSN="WORD(libs,1)
call clsout pds
RETURN

/*=========================================================*/
/* Create IGDSMS member from ZIGDSMS contents plus entries */
/* for the ACDS and COMMDS files.                          */
/*=========================================================*/
igdsms:

call newmem "IGDSMS00", "SMS Startup PARMLIB member"
/*---------------------------------------------------------*/
/* If no member found, set stem count to 0 for later, and  */
/* plan to write output to ZIEALPA.                        */
/*---------------------------------------------------------*/
stat = setinp(pds,'ZIGDSMS')  /* Open member ZIEALPA for input. */
IF stat = 'MEMBER NOT FOUND' THEN DO
   say "==>" ,
       "IGDSMS00 not created, model ZIGDSMS not found."
   RETURN
END
libs1 = xdslist('ACDS')
libs2 = xdslist('COMMDS')
IF WORDS(libs1) = 0 THEN DO
   say "==>" ,
       "IGDSMS00 not built -- ACDS must be defined in @DATASET."
   RETURN
END
IF WORDS(libs2) = 0 THEN DO
   say "==>" ,
       "IGDSMS00 not built -- COMMDS must be defined in @DATASET."
   RETURN
END

smsacds = WORD(libs1,1)  /* Pick first (hopefully only) ACDS ent. */
smscommds = WORD(libs2,1)  /* Pick first (hopefully only) COMM ent. */

/*---------------------------------------------------------*/
/* Build IGDSMS00 member.                                  */
/*---------------------------------------------------------*/
/* Code ACDS and COMMDS to start member.                   */
call jcl "SMS ACDS("smsacds")"
call jcl "    COMMDS("smscommds")"

/* Finish member with ZIGDSMS contents.                    */
DO xx = 1 TO INPUT.0
   call jcl INPUT.xx
END

call clsout pds

RETURN





/*=========================================================*/
/* Copy members from RESCUE PDS to various places.         */
/*=========================================================*/
#copymem:
if \verpds() THEN exit 12 /* Make sure RESCUE.PARMLIB and    */
                        /* RESCUE.PROCLIB are there.       */
call newjob "Copy generated members"
call jcc "COPYMEM  - Copy customized members for various PROCs,   "
call jcc "           PARMLIB members, etc."
call jcd
call jcl "//COPYMEM  EXEC  PGM=IEBCOPY"
call jcl "//SYSPRINT DD SYSOUT=*"

/*--------------------------------------------------------------------*/
/* Look for COPY commands in @DATASET member, and build DD statements.*/
/* The nxtdd() function returns a unique DDNAME to associate with the */
/* DSN passed to it.  It also saves the DSN/DD pair in the stem var   */
/* DD.x.  DD.x.$dsn = the dsn for entry x, DD.x.$dd is the correspond.*/
/* ddname for that entry. This enables us to look up the DDNAME for   */
/* our second pass through the COPY statements, which is when we build*/
/* the "  COPY I=INDD,O=OUTDD" statements.                            */
/*--------------------------------------------------------------------*/
DO xx = 1 TO DSNS.0
   IF WORD(DSNS.xx,1) /= 'COPY' THEN ITERATE
   IF POS('IN=',DSNS.xx) > 0 THEN DO
      PARSE VAR DSNS.xx 'IN=' inds1 . 1 'IN=' inds2 ','
      /* Parse ending with space, then with ',' -- Pick shortest one. */
      IF length(inds1) < length(inds2) THEN indsn = inds1
      ELSE indsn = inds2
      /* Do crude variable substitution.  */
      indsn = varsub(indsn)
      /* Parse ending with space, then with ',' -- Pick shortest one. */
      PARSE VAR DSNS.xx 'OUT=' outds1 . 1 'OUT=' outds2 ','
      IF length(outds1) < length(outds2) THEN outdsn = outds1
      ELSE outdsn = outds2
      /* See if we need to code a DD statement for this DSN:          */
      zdd = nxtdd(indsn)
      if zdd /= "" THEN DO
         call jcl "//"left(zdd,8)" DD DISP=SHR,DSN="indsn
      END
      wdd = nxtdd(outdsn)
      if wdd /= "" THEN DO
         call jcl "//"left(wdd,8)" DD DISP=SHR,DSN="outdsn","
         call jcl "//         UNIT=SYSALLDA,VOL=SER="volser
      END
   END
END

/* Look for COPY commands in @DATASET member, and build SYSIN stmts.  */
call jcl "//SYSIN    DD *"
DO xx = 1 TO DSNS.0
   IF WORD(DSNS.xx,1) /= 'COPY' THEN ITERATE
   /* Set current IN= and OUT= libraries. */
   IF POS('IN=',DSNS.xx) > 0 THEN DO
      /* Parse ending with space, then with ',' -- Pick shortest one. */
      PARSE VAR DSNS.xx 'IN=' inds1 . 1 'IN=' inds2 ','
      IF length(inds1) < length(inds2) THEN indsn = inds1
      ELSE indsn = inds2
      /* Do crude variable substitution.  */
      indsn = varsub(indsn)
      PARSE VAR DSNS.xx 'OUT=' outds1 . 1 'OUT=' outds2 ','
      /* Parse ending with space, then with ',' -- Pick shortest one. */
      IF length(outds1) < length(outds2) THEN outdsn = outds1
      ELSE outdsn = outds2
      /* Look up the dsns in the ddname table (DD.x)  */
      call jcl "  COPY I="getdd(indsn)",O="getdd(outdsn)
   END
   /* Handle the member statements. */
   IF POS('M=',DSNS.xx) > 0 THEN DO
   /* Parse membername, check for with and without parens. */
      PARSE VAR DSNS.xx 'M=(' mem1 ')' . 1 'M=' mem2 .
      IF mem1 /= "" THEN mem = mem1
      ELSE mem = mem2
      PARSE VAR mem m1 ',' m2 .
      /* Do crude variable substitution.  */
      m1 = varsub(m1); m2 = varsub(m2)
      /* Build S M=((x,y,R)) statements. */
      call jcl "   S M=(("m1","m2",R))"
   END
END
call subnext
call endjob
RETURN

getdd:
/* Get DDNAME saved for this dsn. */
ARG ##dsn
IF VALUE("DD.0") = "DD.0" THEN DD.0 = 0
DO ##x10 = 1 TO DD.0
   IF DD.##x10.$dsn = ##dsn THEN RETURN DD.##x10.$dd
END
RETURN ""

nxtdd:
/* See if a DDNAME has been coded yet for this DSN: */
ARG ##dsn
IF VALUE("DD.0") = "DD.0" THEN DD.0 = 0
DO ##x10 = 1 TO DD.0
   IF DD.##x10.$dsn = ##dsn THEN RETURN ""
END

/* It hasn't yet, so find a unique DDNAME, and code it. */
##y10 = DD.0 + 1; DD.0 = ##y10
DD.##y10.$dsn = ##dsn
IF uniqdd(llq(##dsn)) THEN DO
   DD.##y10.$dd = llq(##dsn)
   RETURN DD.##y10.$dd
END

/* DDname was already taken and associated with a different dsn, */
/* so need to find a unique DDNAME (Like PROCLIB2 vs. PROCLIB)   */
/* ##a10 is the left 6 chars of the llq.                         */
##a10 = strip(left(llq(##dsn),6),'B')
DO ##z10 = 1 TO 99
  ##b10 = ##a10""right("00"##z10,2)    /* PARMLI01 for examle.   */
  if uniqdd(##b10) THEN DO
     DD.##y10.$dd = ##b10
     RETURN DD.##y10.$dd
  END
END
RETURN ""  /* Greater than 99 ddnames based on the bas ddn - Error. */

uniqdd:
ARG ##dd
IF VALUE("DD.0") = "DD.0" THEN DD.0 = 0
DO ##x11 = 1 TO DD.0
   IF DD.##x11.$dd = ##dd THEN RETURN 0
END
RETURN 1





/*=========================================================*/
/* Delete the SSA (System Specific Alias)                  */
/* and export disconnect the rescue system master catalog  */
/*=========================================================*/
#delssa:
call newjob "Delete SSA: "ssa
call jcc "DELSSA  - Delete the System Specifc Alias: "ssa
call jcc "          and export the rescue system master catalog"
call jcd
call jcl "//DELSSA   EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN    DD * "
call jcl " DELETE "strip(ssa,"B",".")" ALIAS"
call jcl " IF MAXCC = 0 THEN DO "
call jcl "   EXPORT "newmcat "-"
call jcl "            DISCONNECT    "
call jcl " END"
call subnext
call endjob
RETURN





/*=========================================================*/
/* Misc.                                                   */
/*=========================================================*/
#misc:
call newjob "Misc. tasks"
call jcc "LOGREC   - Format LOGREC dataset."
call jcc "SYNCUADS - Sync UADS / Brodcast dataset."
call jcc "DUMPINIT - Format DUMP datasets."
call jcd

call logrec           /* Initialize logrec dataset.        */
call syncuads         /* SYNC UADS ds.                     */
call dumpfmt          /* Format DUMP datasets.             */
call subnext
call endjob
RETURN

/*---------------------------------------------------------*/
/* Format LOGREC dataset.                                  */
/*---------------------------------------------------------*/
logrec:
libs = xdslist('LOGREC')
IF WORDS(libs) > 0 THEN logrec = WORD(libs,1)
ELSE logrec = ""

/* Format LOGREC dataset if any entry in @dataset was found with */
/* the LOGREC parm coded.    */
IF logrec /= "" THEN DO
   call jcl "//LOGREC   EXEC PGM=IFCDIP00"
   call jcl "//SERERDS  DD DISP=SHR,DSN="logrec","
   call jcl "//         UNIT="devtype",VOL=SER="volser
END

RETURN

/*---------------------------------------------------------*/
/* SYNC UADS if SYSUADS and SYSLBC datasets were found in  */
/* @DATASET.                                               */
/*---------------------------------------------------------*/
syncuads:
libs = xdslist('SYSUADS')
IF WORDS(libs) > 0 THEN sysuads = WORD(libs,1)
ELSE sysuads = ""
libs = xdslist('SYSLBC')
IF WORDS(libs) > 0 THEN syslbc = WORD(libs,1)
ELSE syslbc = ""
IF sysuads = "" | syslbc = "" THEN DO
   say "==>" ,
       "SYSUADS and SYSLBC datasets not defined in @DATASET-Exiting."
   RETURN
END

/* Found the SYSUADS and SYSLBC, so build the SYNC JCL. */

call jcd
call jcl "//SYNCUADS EXEC PGM=IKJEFT01,DYNAMNBR=15 "
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN    DD DUMMY "
call jcl "//SYSUADS  DD DISP=SHR,DSN="sysuads","
call jcl "//         UNIT="devtype",VOL=SER="volser
call jcl "//SYSLBC   DD DISP=SHR,DSN="syslbc","
call jcl "//         UNIT="devtype",VOL=SER="volser
call jcl "//SYSTSPRT DD SYSOUT=* "
call jcl "//SYSTSIN  DD * "
call jcl "  ACCOUNT       "
call jcl "  SYNC          "
call jcl "  END           "

RETURN

/*---------------------------------------------------------*/
/* JCL to format any DUMP datasets found in @DATASET.      */
/*---------------------------------------------------------*/
dumpfmt:
libs = xdslist('DUMP')
IF WORDS(libs) = 0 THEN DO
   say "==>" ,
       "No DUMP datasets defined in @DATASET - Exiting."
   RETURN
END

/* Found the some dump datasets, so format them.        */
call jcd

DO xx = 1 TO WORDS(libs)
   dmpds = WORD(libs,xx)
   call jcl "//DUMPINIT EXEC PGM=IEBGENER"
   call jcl "//SYSPRINT DD SYSOUT=*"
   call jcl "//SYSIN    DD DUMMY"
   call jcl "//SYSUT1   DD DUMMY,"
   call jcl "//         LRECL=4160,BLKSIZE=4160,RECFM=FB,DSORG=PS"
   call jcl "//SYSUT2   DD DSN="dmpds",DISP=SHR,"
   call jcl "//         UNIT="devtype",VOL=SER="volser
END

RETURN













/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Start new member                                        */
/*---------------------------------------------------------*/
newmem:
parse ARG ##xm, ##xd
say "Building" ##xm":" ##xd
call setout pds,##xm
return

/*---------------------------------------------------------*/
/* Submit next job in chain                                */
/*---------------------------------------------------------*/
subnext:
jobnext=jobind+1
jobnext = jobchar.jobnext
call jcd
call jcl "//SUBNEXT  EXEC PGM=IEBGENER,COND=(0,NE)"
call jcl "//SYSPRINT DD  DUMMY"
call jcl "//SYSIN    DD  DUMMY"
call jcl "//SYSUT1   DD  DSN="pds"(JOB"jobnext"),DISP=SHR"
call jcl "//SYSUT2   DD  SYSOUT=(X,INTRDR)"
return

/*---------------------------------------------------------*/
/* Start/end of job                                        */
/*---------------------------------------------------------*/
newjob:
parse ARG ##jobdesc
jobind=jobind+1
jobchar = jobchar.jobind
Say "Building Job" jobchar":" ##jobdesc
call setout pds,'JOB'jobchar
call jobcard jobchar
call jcd
call jcc "Job "jobchar" - "##jobdesc
call jcc mydate" "comment
call jcd
return

endjob:
call jcl "//"
call clsout pds,'JOB'jobchar
return
/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
if $$debug then say ##txt7
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
"ALLOC FI(output) DA('"##ds"("##mem")') SHR REUSE"
IF RC = 0 THEN RETURN 1
ELSE DO
   say '*** Error allocating '##ds'('##mem')'
   exit 12
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
"FREE  FI(output)"
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY '*** Error closing '##ds5'('##mem5') -' rcde
   exit 12
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinpold:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR REUSE"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 1
END
ELSE DO
   say '*** Error allocating '##ds2'('##mem2')'
   RETURN 0
END

setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
##stat = SYSDSN("'"##ds2"("##mem2")'")
IF ##stat /= 'OK' THEN DO
   RETURN ##stat
END
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR REUSE"
cc = rc
IF cc = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 'OK'
END
ELSE DO
   RETURN 'ALLOC ERROR' cc
END

/*-----------------------------------------------------*/
/* Close input member                                  */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq


/*---------------------------------------------------------*/
/* Make a list of SMF datasets, plus the PRI and SEC aloc. */
/*---------------------------------------------------------*/
smflist:
SMF.0 = 0
##x91 = 0
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zzparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   /* Symbolic substitution in case &WHATVER was specified. */
   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)
   zzparms = translate(zzparms,'    ','(),.')
   IF WORDPOS('SMF',zzparms) > 0 THEN DO
      ##x91 = ##x91 + 1
      SMF.##x91.$ds = zzdsn1
      SMF.##x91.$pri = zzpri
   END
end
SMF.0 = ##x91

RETURN

/*------------------------------------------------------------*/
/* Make a list of COMMDS datasets, plus the PRI and SEC aloc. */
/*------------------------------------------------------------*/
commdslist:
COMMDS.0 = 0
##x91 = 0
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zzparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   /* Symbolic substitution in case &WHATVER was specified. */
   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)
   zzparms = translate(zzparms,'    ','(),.')
   IF WORDPOS('COMMDS',zzparms) > 0 THEN DO
      ##x91 = ##x91 + 1
      COMMDS.##x91.$ds = zzdsn1
      COMMDS.##x91.$pri = zzpri
      COMMDS.##x91.$sec = zzsec
   END
end
COMMDS.0 = ##x91

RETURN


/*-------------------------------------------*/
/* Variable substitution - Very crude.       */
/* Handle some special variables, but        */
/* otherwise just return the var value.      */
/* This enables the user to specify &TSOPROC */
/* and the like in the @DATASET member.      */
/*-------------------------------------------*/
varsub:
ARG ####str
IF substr(####str,1,1) /= '&' THEN RETURN ####str
####str = substr(####str,2)  /* Strip off the "&" */
IF ####str = 'RESCUE' THEN RETURN pds
IF SYMBOL(####str) = 'VAR' THEN RETURN VALUE(####str)
ELSE RETURN ####str


/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##attrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib: procedure
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0


/*---------------------------------------------------------*/
/* Create IEALPA member from ZIEALPA contents plus an      */
/* entry we'll build for particular module                 */
/*---------------------------------------------------------*/
iealpa:
arg ##lpaent
/*---------------------------------------------------------*/
/* If no member found, set stem count to 0 for later, and  */
/* plan to write output to ZIEALPA.                        */
/*---------------------------------------------------------*/
stat = setinp(pds,'ZIEALPA')  /* Open member ZIEALPA for input. */
IF stat = 'MEMBER NOT FOUND' THEN DO
   say "==>",
       "Model MLPA member ZIEALPA not found, and will be created."
   INPUT.0 = 0
   outmem = 'ZIEALPA'
END
ELSE IF stat /= 'OK' THEN DO
   Say "*** Error opening ZIEALPA, exiting -" stat
   exit 12
END

/*---------------------------------------------------------*/
/* If no member read, set stem count to 0 for later.       */
/*---------------------------------------------------------*/
IF INPUT.0 = "INPUT.0" THEN DO
   SAY "Model MLPA member ZIEALPA not found."
   INPUT.0 = 0
END

/*---------------------------------------------------------*/
/* If there's already an entry for this module, do nothing.*/
/*---------------------------------------------------------*/
DO xx = 1 TO INPUT.0
/* Parse out comments first. */
   PARSE VAR INPUT.xx p '/*'
   IF POS(##lpaent,p) > 0 THEN DO
      say "    "##lpaent "entry already in MLPA model - No entry added."
      call clsinp pds,'ZIEALPA'  /* Close input file. */
      RETURN
   END
END

/*---------------------------------------------------------*/
/* No entry found, so rebuild ZIEALPA with out mod added.  */
/*---------------------------------------------------------*/
call setout pds,'ZIEALPA'
DO xx = 1 TO INPUT.0
   call jcl INPUT.xx
END
stcent = "INCLUDE LIBRARY(SYS1.RESCUE.LINKLIB) MODULES( "##lpaent" )"
call jcl stcent
call clsout pds,'ZIEALPA'
Say "    Entry" ##lpaent "added to ZIEALPA MLPA model."

RETURN


/*-------------------------------------------*/
/*-ckstcid - Check if we need to process     */
/*-this stc id.  If not, return 0.  If so,   */
/*-return 1.                                 */
/*-------------------------------------------*/
ckstcid:
ARG ##id
IF STCID.0 = "STCID.0" THEN stcid.0 = 0
DO ##x = 1 TO stcid.0
   IF ##id = stcid.##x THEN RETURN 0
END
##x34 = stcid.0
##x34 = ##x34 + 1
stcid.0 = ##x34
stcid.##x34 = ##id
RETURN 1

ckstcgrp:
ARG ##grp
IF STCGRP.0 = "STCGRP.0" THEN stcgrp.0 = 0
DO ##x = 1 TO stcgrp.0
   IF ##grp = stcgrp.##x THEN RETURN 0
END
##x34 = stcgrp.0
##x34 = ##x34 + 1
stcgrp.0 = ##x34
stcgrp.##x34 = ##grp
RETURN 1

/*---------------------------------------------------------*/
/* idisthere  - Says if a RACF ID is defined.              */
/* grpisthere - Says if a RACF ID is defined.              */
/*---------------------------------------------------------*/
idthere:
ARG ##id
x = outtrap('list.',1)
"LU "##id
 cc = rc
x = outtrap('OFF')
RETURN (cc = 0)

grpthere:
ARG ##grp
x = outtrap('list.',1)
"LG "##grp
 cc = rc
x = outtrap('OFF')
RETURN (cc = 0)


/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.            */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zzparm ')' .
   zzdsn = strip(zzdsn,'B')
   IF zzdsn = "" THEN ITERATE
   IF attrib(##prm,zzparm) THEN DO
      IF zzdsn2 /= "" THEN,
      ###dslst = ###dslst" "zzdsn2
      ELSE,
      ###dslst = ###dslst" "zzdsn1
   END
END
RETURN ###dslst


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.            */
/*---------------------------------------------------------*/
xdsthere:
ARG ##prm .
do ##xxx = 1 TO DSNS.0
   IF POS(##prm,DSNS.##xxx) > 0 THEN RETURN 1
END
RETURN 0

/*---------------------------------------------------------*/
/* Check for presence of all datasets.  If copy mode is    */
/* "N" meaning the DS is not copied bu just created, then  */
/* assume it is ok.                                        */
/*---------------------------------------------------------*/
verpds:
##ok1 = 0; ##ok2 = 0
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   IF zzdsn2 = 'SYS1.RESCUE.PARMLIB' THEN ##ok1 = 1
   IF zzdsn2 = 'SYS1.RESCUE.PROCLIB' THEN ##ok2 = 1
END

IF \##ok1 THEN DO
   SAY "*** SYS1.RESCUE.PARMLIB not defined in @DATASET member;"
END
IF \##ok2 THEN DO
   SAY "*** SYS1.RESCUE.PROCLIB not defined in @DATASET member;"
END
IF \##ok1 | \##ok2 THEN DO
   SAY "*** Unable to continue."
   exit 12
END

RETURN ##ok1 & ##ok2




























./ ADD NAME=RESCUE20 0100-02207-02207-1614-00058-00058-00000-*BASE*
---------------------------------------------------
OS/390 Rescue System - Version 2.0
---------------------------------------------------
03/28/2001

Based on OS/390 version 2.10

An OS/390 system typically is spread out over several disk packs.  This
set of Rexx execs builds the necessary jobs to generate a completely
self-contained IPL'able OS/390 version 2.10 system on a single 3390-3
disk pack.  Earlier versions of OS/390 can also be used, but the techniques
used for copying OMVS datasets may not work depending on the release and
maintenance level of the system being "cloned."

The system datasets on your existing OS/390 system are copied (or in some
cases re-created) on the one pack system, so the rescue system will be at
the same maintenance level as your production system.  You can easily rebuild
the rescue system after maintenance is applied to the production system if so
desired.

I recommend that you build a rescue system on one of your "spare" disk volumes,
and then make a tape backup of this volume that you keep in a safe place. This
way you will have your RESCUE system on a disk pack and ready to IPL when you
need it, but you can also restore over this pack if you need it for any reason,
and restore the RESCUE system to some other volume from your backup tape.  Job
$SAREST will create a tape with stand alone DFDSS on file 1 of the tape, and the
RESCUE volume DFDSS restore image in file 2.  This enables you to bring up a
IPLable OS/390 system from a totally inoperable environment.
(Great for disaster recovery.)

The uses for such a system are many.  For those times when you cannot IPL your m
production system, this one pack rescue system can be IPL'd to perform the neces
repair to the production system.


How to transfer to MVS host:
---------------------------------------------------
- Download the RESCUE20.EXE self-extracting file to a PC.  Place RESCUE20.EXE
  in a directory by itself, and run it.  This will result in all required
  members being extracted. (These won't be readable on a PC  See note below)

- Create a PDS on the MVS system that will hold the RESCUE system execs and para
  CYL(1,1,15) should be big enough. RECFM=FB,LRECL=80,BLKSIZE=6160 are suitable
  parameters.

- FTP all the extracted files from the PC to the MVS PDS allocated in the
  first step.  Use the FTP subcommand: "BINARY" or equivalent to specify
  a binary transfer.  This is a must.
  (These FTP'd files become members of the target PDS.)

- Read the $$$DOC member in the PDS for further instructions.

NOTE: The files that are in this self-extracting zip file are in EBCDIC format,
so they will look like garbage on the PC, even after being extracted.  They will
however be normal, readable EBCDIC PDS members after they are extracted and
transferred to an MVS host using Binary mode.

---------------------------------------------------
./ ADD NAME=SMFPRM00
/*-------------------------------------------------------*/
/* SMF parameters.                                       */
/* Built dynamically by RESCUE exec, 19/09/2002 12:09            */
/*-------------------------------------------------------*/
 ACTIVE
 DSNAME(SYS1.MANX,
        SYS1.MANY,
        SYS1.MANZ)
 INTVAL(15)
 JWT(0030)
 LISTDSN
 MAXDORM(3000)
 NOPROMPT
 REC(PERM)
 SID(RESC)
 STATUS(SMF,SYNC)
 SYNCVAL(00)
 SYS(NOTYPE(19),EXITS(IEFU83,IEFACTRT,IEFUJI,IEFU29),
     DETAIL,INTERVAL(SMF,SYNC))
 SUBSYS(STC,EXITS(IEFUJI,IEFACTRT,IEFU83,IEFU29))
 SUBSYS(JES2,EXITS(IEFUJI,IEFACTRT,IEFU83))
./ ADD NAME=VTAM
//*-----------------------------------------------------------------*
//* VTAM Started procedure.                                         *
//* Built dynamically by RESCUE exec, 19/09/2002 12:09              *
//*-----------------------------------------------------------------*
//VTAM     EXEC PGM=ISTINM01,REGION=0M,
//         DPRTY=(15,15),TIME=1440,PERFORM=8
//VTAMLST  DD DISP=SHR,DSN=SYS2.XXXXXXXX.VTAMLST
//         DD DISP=SHR,DSN=SYS1.VTAMLST
//VTAMLIB  DD DISP=SHR,DSN=SYS2.XXXXXXXX.VTAMLIB
//         DD DISP=SHR,DSN=SYS1.VTAMLIB
//SISTCLIB DD DISP=SHR,DSN=SYS1.SISTCLIB
//SYSABEND DD SYSOUT=*,HOLD=YES
./ ADD NAME=WAIT     0101-02207-03007-1046-00157-00157-00000-ITSCXB
//WAIT     JOB ZZTS0000Z,'CHRIS BUCKLEY',CLASS=S,MSGCLASS=X,REGION=4M
//ASMACL   EXEC  ASMACL,PARM.L='MAP,LET,LIST,NCAL'
//C.SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//           DD  DSN=SYS1.MODGEN,DISP=SHR
//C.SYSIN    DD  *
PRC      TITLE 'WAIT - WAIT A LITTLE BIT.'
********************************************************************
*                                                                  *
* NAME - WAIT.                                                     *
*                                                                  *
* DESCRIPTION -                                                    *
*                                                                  *
*   THIS MODULE WILL WAIT THE REQUESTED NUMBER OF SECONDS.         *
*                                                                  *
* TO USE -                                                         *
*                                                                  *
*   PARM='NNNN', WHERE 0 < NNNN <= 9999, THE NUMBER OF SECONDS TO  *
*     WAIT. DEFAULT IS 10 SECONDS.                                 *
*                                                                  *
* RETURN CODES -                                                   *
*                                                                  *
*   R15 = 20, BAD PARM FIELD.                                      *
*                                                                  *
* LOG -                                                            *
*   05/30/86 L01 PTW IMPLEMENTED                                   *L01
*   09/27/88 L02 PTW IMPLEMENTED                                   *L02
*                                                                  *
********************************************************************
         LCLC  &CSECT
&CSECT   SETC  'WAIT'
&CSECT   CSECT
********************************************************************
*                                                                  *
*        I N I T I A L I Z E                                       *
*                                                                  *
********************************************************************
         PRINT NOGEN
         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME
         LR    R12,R15            ESTABLISH BASE.
         USING &CSECT,R12
         GETMAIN RU,LV=DYNLEN
         LR    R2,R13
         LR    R13,R1
         USING DYNAMIC,R13
         LR    R0,R1
         LA    R14,DYNLEN
         LA    R1,R1
         SLR   R15,R15
         MVCL  R0,R14             ZERO STORAGE.
         ST    R2,4(,R13)         BACK CHAIN.
         ST    R13,8(,R2)         FORWARD CHAIN.
         XC    RC,RC
********************************************************************
*                                                                  *
*        P A R M   P R O C E S S I N G                             *
*                                                                  *
********************************************************************
         MVC   SECONDS,=F'10'     DEFAULT.
         L     R2,4(,R13)         A(PREVIOUS SAVEAREA).
         L     R2,24(,R2)         A(A(PARM)).
         LTR   R2,R2              CHECK FOR NULL PARM.
         BZ    DOTIME
         L     R2,0(,R2)          A(PARM).
         LH    R3,0(,R2)          L'PARM.
         LTR   R3,R3              IF ZEROS +
         BZ    DOTIME               THEN EXIT.
         CH    R3,=H'4'           IF LENGTH NGT '4' +
         BH    BADTIME            FORGET NEXT.
         LA    R4,2(,R2)
VERNUM   DS    0H
         CLI   0(R4),C'0'         SCAN
         BL    BADTIME             FORWARD
         CLI   0(R4),C'9'         SCAN
         BH    BADTIME             FORWARD
         LA    R4,1(,R4)            TO FIRST
         BCT   R3,VERNUM
         LH    R3,0(,R2)
         BCTR  R3,0               MACHINE LENGTH.
         EX    R3,PACKSEC         PACK SECONDS.
         CVB   R3,DOUBLE          CONVERT TO BINARY.
         CH    R3,=H'1'           TEST SECONDS
         BL    BADTIME             FOR LIMITS.
         CH    R3,=H'9999'
         BH    BADTIME
         ST    R3,SECONDS          AND STORE.
PACKSEC  PACK  DOUBLE,2(*-*,R2)
********************************************************************
*                                                                  *
*        W A I T                                                   *
*                                                                  *
********************************************************************
DOTIME   DS    0H
         L     R2,SECONDS
         MH    R2,=H'100'
         ST    R2,SECONDS
         STIMER WAIT,BINTVL=SECONDS
         XC    RC,RC
********************************************************************
*                                                                  *
*        R E T U R N                                               *
*                                                                  *
********************************************************************
RETURN   DS    0H
         L     R2,RC                  R2 = RC.
         LR    R1,R13              PREPARE
         L     R13,4(,R13)         FOR FREEMAIN.
         FREEMAIN RU,LV=DYNLEN,A=(1)
         LR    R15,R2              AND RETURN
         RETURN (14,12),RC=(15)      WITH R15 = RC.
********************************************************************
*                                                                  *
*        E R R O R S                                               *
*                                                                  *
********************************************************************
BADTIME  DS    0H
         WTO   'WAIT: BAD PARM - SPECIFY NNNN (1-9999 SECONDS).',      X
               ROUTCDE=11,MCSFLAG=HRDCPY
         MVC   RC,=F'20'
         B     RETURN
********************************************************************
*                                                                  *
*        S T A T I C   A R E A                                     *
*                                                                  *
********************************************************************
SRCLEVEL DC    C'                                        '
         LTORG *
********************************************************************
*                                                                  *
*        D Y N A M I C   A R E A                                   *
*                                                                  *
********************************************************************
DYNAMIC  DSECT
SAVE     DS    18F .
DOUBLE   DS    D
RC       DS    F
SECONDS  DS    F
DYNLEN   EQU   *-DYNAMIC
         PRINT OFF
R0       EQU   00
R1       EQU   01
R2       EQU   02
R3       EQU   03
R4       EQU   04
R5       EQU   05
R6       EQU   06
R7       EQU   07
R8       EQU   08
R9       EQU   09
R10      EQU   10
R11      EQU   11
R12      EQU   12                 PROGRAM BASE.
R13      EQU   13                 A(SAVE AREA).
R14      EQU   14
R15      EQU   15
         PRINT ON
         END   &CSECT
//L.SYSLMOD DD  DSN=SYS2.XXXXXXXX.LINKLIB(RESCWAIT),DISP=SHR,UNIT=
./ ADD NAME=ZBPXPRM  0100-02207-02207-1614-00049-00049-00000-*BASE*
FILESYSTYPE TYPE(HFS)
            ENTRYPOINT(GFUAINIT)
            PARM(' ')

FILESYSTYPE TYPE(TFS)
            ENTRYPOINT(BPXTFS)

   MAXPROCSYS(900)
   MAXPROCUSER(100)
   MAXUIDS(200)
   MAXFILEPROC(2000)
   MAXPTYS(800)
   CTRACE(CTIBPX00)
   FILESYSTYPE TYPE(UDS) ENTRYPOINT(BPXTUINT)
   NETWORK DOMAINNAME(AF_UNIX)
           DOMAINNUMBER(1)
           MAXSOCKETS(2000)
           TYPE(UDS)
   FILESYSTYPE TYPE(INET) ENTRYPOINT(EZBPFINI)
   NETWORK DOMAINNAME(AF_INET)
           DOMAINNUMBER(2)
           MAXSOCKETS(64000)
           TYPE(INET)
   MAXTHREADTASKS(1000)
   MAXTHREADS(500)
   IPCMSGNIDS    (500)
   IPCMSGQBYTES  (2147483647)
   IPCMSGQMNUM   (10000)
   IPCSHMNIDS    (500)
   IPCSHMSPAGES  (262144)
   IPCSHMMPAGES  (25600)
   IPCSHMNSEGS   (500)
   IPCSEMNIDS    (500)
   IPCSEMNSEMS   (1000)
   IPCSEMNOPS    (25)
   MAXMMAPAREA(40960)
   MAXCORESIZE(4194304)
   MAXASSIZE(209715200)
   MAXCPUTIME(1000)
   MAXSHAREPAGES(131072)
   FORKCOPY(COW)
   SUPERUSER(BPXROOT)
   TTYGROUP(TTY)
   STARTUP_PROC(OMVS)
   SYSCALL_COUNTS(NO)
   MAXQUEUEDSIGS(1000)
   SYSPLEX(NO)
   SHRLIBRGNSIZE(67108864)
   SHRLIBMAXPAGES(4096)
./ ADD NAME=ZCOMMND  0101-02207-02219-1251-00008-00008-00000-ITSCXB
COM='CD SET,SDUMP,NODUMP'
COM='S VLF,SUB=MSTR'
COM='S DLF,SUB=MSTR'
COM='*S TSSO,SUB=MSTR'
COM='S EZAZSSI,P=RESCUE'
COM='S IRRDPTAB'
COM='S SDSF'
COM='S VTAM,,,(LIST=RU)'
./ ADD NAME=ZIEALPA
INCLUDE LIBRARY(SYS1.RESCUE.LINKLIB) MODULES( ICHRDSNT )
INCLUDE LIBRARY(SYS1.RESCUE.LINKLIB) MODULES( ICHRIN03 )
./ ADD NAME=ZIEAPAK  0100-02212-02212-1930-00001-00001-00000-ITSCXB
(IEFBR14)
./ ADD NAME=ZIEASVC  0101-02207-02207-1614-00001-00001-00000-*BASE*
 /*                                                                  */
./ ADD NAME=ZIEASYS  0109-02207-02219-1250-00041-00043-00000-ITSCXB
CLOCK=(00,L),                 SELECT CLOCK00
CMB=(UNITR,COMM,GRAPH,CHRDR), ADDITIONAL CMB ENTRIES
CMD=00,                       SELECT COMMD00
CON=(20,L,NOJES3),            SELECT CONSOLXX
COUPLE=**,                    XCF LOCAL MODE
CSA=(3000,30000),             CSA RANGE
DUMP=DASD,                    PLACE SVC DUMPS ON DASD DEVICES
GRS=NONE,                     NO COORDINATION OF GRS REQUESTS
ICS=00,                       SELECT IEAICS00, CNTL SPECS FOR SRM
IPS=00,                       SELECT IEAIPS00, PERF SPECS FOR SRM
LNKAUTH=LNKLST,               AUTHORIZE LNKLST00, APFTAB IS ALTERNATE
LOGCLS=9,                     WILL NOT BE PRINTED BY DEFAULT
LOGLMT=999999,                MAX WTL MESSAGES QUEUED, MUST BE 6 DIGITS
LOGREC=SYS1.LOGREC,           ERROR RECORDING
LPA=(00,L),                   SELECT LPALST00
MAXUSER=250,                  SYS TASKS PLUS INITS PLUS TSOUSERS
MLPA=00,                      SELECT IEALPA00, MLPA PARAMETERS
MSTRJCL=(01,L),               SELECT MSTJCL01, MASTER JCL
OMVS=(00),                    SELECT BPXPRM00
OPI=YES,                      ALLOW OPERATOR OVERRIDE TO IEASYS00
OPT=00,                       SELECT IEAOPT00, SRM TUNING PARAMETERS
PAGE=(PAGE.RESCUE.PLPA,
      PAGE.RESCUE.COMMON,
      PAGE.RESCUE.LOCAL1,L),
PAK=(00,L),                   SELECT IEAPAK00
PROD=00,                      SELECT IFAPRD01
PROG=(L0,A0),                 SELECT PROGL0 AND A0 (LINKLST AND APF)
REAL=128,                     ALLOWS 2 64K OR 1 128K JOB TO RUN V=R
RSU=0,                        NO RECONFIG STORAGE UNITS
RSVNONR=5,                    RESERVED ASVT ENTRIES
RSVSTRT=5,                    RESERVED ASVT ENTRIES
SCH=00,                       SELECT SCHED00
SMF=00,                       SELECT SMFPRM00, SMF PARAMETERS
SMS=00,                       SMS PARAMETERS
SQA=(15,64),                  SQA SIZE APPROX 640K
SSN=00,                       SELECT IEFSSN00, SUBSYSTEM NAMES
SVC=00,                       SELECT IEASVC00, USER SVCS
SYSNAME=RESC,                 SYSTEM NAME
VAL=00,                       SELECT VATLST00
VIODSN=SYS1.STGINDEX,         VIO DS
VRREGN=64                     DEFAULT REAL-STORAGE REGION SIZE
./ ADD NAME=ZIEFSSN  0100-02207-02207-1614-00012-00012-00000-*BASE*
SUBSYS SUBNAME(SMS)
   INITRTN(IGDSSIIN)
   INITPARM('ID=02,PROMPT=DISPLAY')
SUBSYS SUBNAME(JES2) PRIMARY(YES) START(YES)
SUBSYS SUBNAME(IRLM)
SUBSYS SUBNAME(JRLM)
SUBSYS SUBNAME(FFST)
SUBSYS SUBNAME(SOM)  INITRTN(GOSAMSSI)
SUBSYS SUBNAME(TNF)
SUBSYS SUBNAME(VMCF)
SUBSYS SUBNAME(CICS) INITRTN(DFHSSIN)
SUBSYS SUBNAME(TSSO) INITRTN(TSSOINIT)
./ ADD NAME=ZIGDSMS  0100-02207-02207-1614-00010-00010-00000-*BASE*
    INTERVAL(15)
    DINTERVAL(150)
    REVERIFY(NO)
    ACSDEFAULTS(NO)
    TRACE(ON)
    SIZE(128K)
    TYPE(ALL)
    JOBNAME(*)
    ASID(*)
    SELECT(ALL)
./ ADD NAME=ZISPALOC 0100-02207-02207-1614-00043-00043-00000-*BASE*
/*-------------------------------------------------------rexx--------*/
/* TSO Allocation EXEC.                                              */
/* Rescue System.                                                    */
/*-------------------------------------------------------------------*/
/* call setup */

/*-------------------------------------------------------------------*/
/* Allocate ISPPROF dataset                                          */
/*-------------------------------------------------------------------*/
ispprof = USERID()".ISPF.ISPPROF"
if \alc('ISPPROF', "'"ispprof"'") THEN DO
   "alloc da('"ispprof"') f(ISPPROF) new",
   "space(1 1) cyl lrecl(80) blksize(6160) recfm(f b) dir(15)"
   cc = RC
   IF cc /= 0 THEN DO
      SAY "Unable to allocate ISPF profile dataset "ispprof";"
      SAY "Please contact systems support for assistance."
      SAY "Return code: "cc
   END
END

/*-------------------------------------------------------------------*/
/* Execute user CLIST/Exec if present (Pre-allocation)               */
/*-------------------------------------------------------------------*/
IF SYSDSN("'"ispprof"(PRE)'") = "OK" THEN DO
   "EXEC '"ispprof"(PRE)'"
   cc = RC
   IF cc /= 0 THEN exit
END

"PDF"
exit

/*--------- Allocate the concatenation ------------*/
alc:
PARSE UPPER ARG ddname, dsname
mg = MSG('OFF')                          /* Turn msg off             */
"FREE  FI("ddname")"                     /* Free the DDNAME          */
mg = MSG(mg)                             /* Restore msg level        */
"ALLOC FI("ddname") DA("dsname") SHR"    /* Allocate the files       */
cc = RC                                  /* Save return code         */
RETURN cc <= 4                           /* Return 1 if OK           */

./ ADD NAME=ZISRPRIM 0101-02212-02262-1123-00370-00369-00000-ITSCXB
)PANEL KEYLIST(ISRSAB,ISR) IMAGE(&ZIMGNAM,&ZIMGROW,&ZIMGCOL)
)ATTR DEFAULT() FORMAT(MIX)            /* ISR@PRIM - ENGLISH - 5.0 */
 0B TYPE(AB)
 0D TYPE(PS)
 04 TYPE(ABSL) GE(ON)
 05 TYPE(PT)
 09 TYPE(FP)
 0A TYPE(NT)
 11 TYPE(SAC)
 16 TYPE(VOI) PADC(USER)
 2B TYPE(DT)
 22 TYPE(WASL) SKIP(ON) GE(ON)
 26 TYPE(NEF) CAPS(ON) PADC(USER)
 27 AREA(SCRL) EXTEND(ON)
 28 TYPE(PS) CSRGRP(99)
 29 TYPE(GRPBOX)
 2A AREA(DYNAMIC)
 19 TYPE(DATAOUT) COLOR(WHITE)
 1A TYPE(DATAOUT) COLOR(RED)
 1B TYPE(DATAOUT) COLOR(BLUE)
 1C TYPE(DATAOUT) COLOR(GREEN)
 1D TYPE(DATAOUT) COLOR(PINK)
 1E TYPE(DATAOUT) COLOR(YELLOW)
 1F TYPE(DATAOUT) COLOR(TURQ)
 30 TYPE(DATAOUT) PAS(ON)
 31 TYPE(CHAR) COLOR(WHITE)
 32 TYPE(CHAR) COLOR(RED)
 33 TYPE(CHAR) COLOR(BLUE)
 34 TYPE(CHAR) COLOR(GREEN)
 35 TYPE(CHAR) COLOR(PINK)
 36 TYPE(CHAR) COLOR(YELLOW)
 37 TYPE(CHAR) COLOR(TURQ)
 38 TYPE(DATAOUT) CUADYN(VOI)
 39 TYPE(CHAR) COLOR(WHITE) HILITE(REVERSE)
 3A TYPE(CHAR) COLOR(RED) HILITE(REVERSE)
 3B TYPE(CHAR) COLOR(BLUE) HILITE(REVERSE)
 3C TYPE(CHAR) COLOR(GREEN) HILITE(REVERSE)
 3D TYPE(CHAR) COLOR(PINK) HILITE(REVERSE)
 3E TYPE(CHAR) COLOR(YELLOW) HILITE(REVERSE)
 3F TYPE(CHAR) COLOR(TURQ) HILITE(REVERSE)
)ABC DESC('Menu') MNEM(1)
PDC DESC('Settings') UNAVAIL(ZPM1) MNEM(1) ACC(CTRL+S)
 ACTION RUN(ISRROUTE) PARM('SET')
PDC DESC('View') UNAVAIL(ZPM2) MNEM(1) ACC(CTRL+V)
 ACTION RUN(ISRROUTE) PARM('BR1')
PDC DESC('Edit') UNAVAIL(ZPM3) MNEM(1) ACC(CTRL+E)
 ACTION RUN(ISRROUTE) PARM('ED1')
PDC DESC('ISPF Command Shell') UNAVAIL(ZPM4) MNEM(6) ACC(CTRL+C)
 ACTION RUN(ISRROUTE) PARM('C1')
PDC DESC('Dialog Test...') UNAVAIL(ZPM5) MNEM(8) ACC(CTRL+T)
 ACTION RUN(ISRROUTE) PARM('DAL')
PDC DESC('Other IBM Products...') UNAVAIL(ZPM6) MNEM(1) ACC(CTRL+O)
 ACTION RUN(ISRROUTE) PARM('OIB')
PDC DESC('SCLM') UNAVAIL(ZPM7) MNEM(3) ACC(CTRL+L)
 ACTION RUN(ISRROUTE) PARM('SCL')
PDC DESC('ISPF Workplace') UNAVAIL(ZPM8) MNEM(6) ACC(CTRL+W)
 ACTION RUN(ISRROUTE) PARM('WRK')
PDC DESC('Status Area...') UNAVAIL(ZPMS) MNEM(8) ACC(CTRL+A)
 ACTION RUN(ISRROUTE) PARM('SAM')
PDC DESC('Exit') MNEM(2) PDSEP(ON) ACC(CTRL+X) ACTION RUN(EXIT)
)ABCINIT
.ZVARS=ISR@OPT
)ABC DESC('Utilities') MNEM(1)
PDC DESC('Library') UNAVAIL(ZUT1) MNEM(1) ACC(ALT+1)
 ACTION RUN(ISRROUTE) PARM('U1')
PDC DESC('Data set') UNAVAIL(ZUT2) MNEM(1) ACC(ALT+2)
 ACTION RUN(ISRROUTE) PARM('U2')
PDC DESC('Move/Copy') UNAVAIL(ZUT3) MNEM(1) ACC(ALT+3)
 ACTION RUN(ISRROUTE) PARM('U3')
PDC DESC('Data Set List') UNAVAIL(ZUT4) MNEM(2) ACC(ALT+4)
 ACTION RUN(ISRROUTE) PARM('U4')
PDC DESC('Reset Statistics') UNAVAIL(ZUT5) MNEM(5) ACC(ALT+5)
 ACTION RUN(ISRROUTE) PARM('U5')
PDC DESC('Hardcopy') UNAVAIL(ZUT6) MNEM(1) ACC(ALT+6)
 ACTION RUN(ISRROUTE) PARM('U6')
PDC DESC('Download...') UNAVAIL(ZUTDT) MNEM(2) ACC(ALT+7)
 ACTION RUN(ISRROUTE) PARM('UDT')
PDC DESC('Outlist') UNAVAIL(ZUT7) MNEM(2) ACC(ALT+8)
 ACTION RUN(ISRROUTE) PARM('U8')
PDC DESC('Commands...') UNAVAIL(ZUT8) MNEM(1) ACC(ALT+9)
 ACTION RUN(ISRROUTE) PARM('U9')
PDC DESC('Reserved') UNAVAIL(ZUT9) MNEM(6) ACTION RUN(ISRROUTE) PARM('U10')
PDC DESC('Format') UNAVAIL(ZUT10) MNEM(1) ACC(ALT+F1)
 ACTION RUN(ISRROUTE) PARM('U11')
PDC DESC('SuperC') UNAVAIL(ZUT11) MNEM(1) PDSEP(ON) ACC(CTRL+F2)
 ACTION RUN(ISRROUTE) PARM('U12')
PDC DESC('SuperCE') UNAVAIL(ZUT12) MNEM(3) ACC(CTRL+F3)
 ACTION RUN(ISRROUTE) PARM('U13')
PDC DESC('Search-For') UNAVAIL(ZUT13) MNEM(2) ACC(CTRL+F4)
 ACTION RUN(ISRROUTE) PARM('U14')
PDC DESC('Search-ForE') UNAVAIL(ZUT14) MNEM(4) ACC(CTRL+F5)
 ACTION RUN(ISRROUTE) PARM('U15')
)ABCINIT
.ZVARS=PDFUTIL
     &zut9 = '1'
)ABC DESC('Compilers') MNEM(1)
PDC DESC('Foreground Compilers') MNEM(1) ACTION RUN(ISRROUTE) PARM('FGD')
PDC DESC('Background Compilers') MNEM(1) ACTION RUN(ISRROUTE) PARM('BKG')
PDC DESC('ISPPREP Panel Utility...') MNEM(1) ACTION RUN(ISPPREP)
PDC DESC('DTL Compiler...') MNEM(1) ACTION RUN(ISPDTLC)
)ABCINIT
.ZVARS=ISRLANG
)ABC DESC('Options') MNEM(1)
PDC DESC('General Settings') MNEM(1) ACTION RUN(ISRROUTE) PARM('SET')
PDC DESC('CUA Attributes...') MNEM(1) ACTION RUN(CUAATTR)
PDC DESC('Keylists...') MNEM(1) ACTION RUN(KEYLIST)
PDC DESC('Point-and-Shoot...') MNEM(1) ACTION RUN(PSCOLOR)
PDC DESC('Colors...') MNEM(2) ACTION RUN(COLOR)
PDC DESC('Dialog Test appl ID...') MNEM(1) ACTION RUN(ISRROUTE) PARM('DAP')
)ABCINIT
.ZVARS=PDFOPTM
)ABC DESC('Status') MNEM(1)
PDC DESC('Session') UNAVAIL(ZCSTA) MNEM(1) ACTION RUN(ISRROUTE) PARM('SES')
PDC DESC('Function keys') UNAVAIL(ZCSTB) MNEM(1)
 ACTION RUN(ISRROUTE) PARM('FUN')
PDC DESC('Calendar') UNAVAIL(ZCSTC) MNEM(1) ACTION RUN(ISRROUTE) PARM('CAL')
PDC DESC('User status') UNAVAIL(ZCSTD) MNEM(1) ACTION RUN(ISRROUTE) PARM('USE')
PDC DESC('User point and shoot') UNAVAIL(ZCSTE) MNEM(3)
 ACTION RUN(ISRROUTE) PARM('UPS')
PDC DESC('None') UNAVAIL(ZCSTF) MNEM(1) ACTION RUN(ISRROUTE) PARM('OFF')
)ABCINIT
.ZVARS=PDFSTA
IF (&ZSCREEN = '1')
  VGET (ZSAREA1)
  &ZSAREA = &ZSAREA1
  GOTO A
IF (&ZSCREEN = '2')
  VGET (ZSAREA2)
  &ZSAREA = &ZSAREA2
  GOTO A
IF (&ZSCREEN = '3')
  VGET (ZSAREA3)
  &ZSAREA = &ZSAREA3
  GOTO A
IF (&ZSCREEN = '4')
  VGET (ZSAREA4)
  &ZSAREA = &ZSAREA4
  GOTO A
ELSE
  VGET (ZSAREA5)
  &ZSAREA = &ZSAREA5
A:
&zcsta = 0
&zcstb = 0
&zcstc = 0
&zcstd = 0
&zcste = 0
&zcstf = 0
IF (&ZSAREA = 'SES') &zcsta = 1
IF (&ZSAREA = 'FUN') &zcstb = 1
IF (&ZSAREA = 'CAL') &zcstc = 1
IF (&ZSAREA = 'USE') &zcstd = 1
IF (&ZSAREA = 'UPS') &zcste = 1
IF (&ZSAREA = 'OFF') &zcstf = 1
&PDFSTA = ' '
)ABC DESC('Help') MNEM(1)
PDC DESC('General') MNEM(1) ACTION RUN(TUTOR) PARM('ISR01000')
PDC DESC('Settings') MNEM(1) ACTION RUN(TUTOR) PARM('ISP05000')
PDC DESC('View') MNEM(1) ACTION RUN(TUTOR) PARM('ISR10000')
PDC DESC('Edit') MNEM(1) ACTION RUN(TUTOR) PARM('ISR20000')
PDC DESC('Utilities') MNEM(1) ACTION RUN(TUTOR) PARM('ISR30000')
PDC DESC('Foreground') MNEM(1) ACTION RUN(TUTOR) PARM('ISR40000')
PDC DESC('Batch') MNEM(1) ACTION RUN(TUTOR) PARM('ISR50000')
PDC DESC('Command') MNEM(1) ACTION RUN(TUTOR) PARM('ISR60010')
PDC DESC('Dialog Test') MNEM(1) ACTION RUN(TUTOR) PARM('ISP70000')
PDC DESC('LM Facility') MNEM(1) ACTION RUN(TUTOR) PARM('ISR80000')
PDC DESC('IBM Products') MNEM(1) ACTION RUN(TUTOR) PARM('ISRD0000')
PDC DESC('SCLM') MNEM(4) ACTION RUN(TUTOR) PARM('FLMTD')
PDC DESC('Workplace') MNEM(1) ACTION RUN(TUTOR) PARM('ISR00400')
PDC DESC('Exit') MNEM(2) ACTION RUN(TUTOR) PARM('ISP90100')
PDC DESC('Status Area') MNEM(2) ACTION RUN(TUTOR) PARM('ISPSAMHP')
PDC DESC('About...') MNEM(1) ACTION RUN(TUTOR) PARM('ISRLOGO')
PDC DESC('Changes for this Release') MNEM(2) ACTION RUN(TUTOR) PARM('ISR00005')
PDC DESC('Tutorial') MNEM(4) ACTION RUN(TUTOR) PARM('ISR00000')
PDC DESC('Appendices') MNEM(2) ACTION RUN(TUTOR) PARM('ISR00004')
PDC DESC('Index') MNEM(2) ACTION RUN(TUTOR) PARM('ISR91000')
)ABCINIT
.ZVARS=PRIMHELP
)BODY  CMD(ZCMD)
 Menu Utilities Compilers Options Status Help
------------------------------------------------------------------------------
                          	ISPF Primary Option Menu                          
Option ===>Z                                                                 
SAREA39                                               GRPBOX1
                                                      TMPROWS,TMPSHDW    
                                                                         
                                                                         
                                                                         
                                                                         
                                                                         
                                                                         
                                                                         
                                                                         
                                                                         
                                                                         
                                                       
                                                      
ZEXI 
    EnterZto Terminate using log/list defaults
)AREA SAREA39
0 Settings     Terminal and user parameters         
1 View         Display source data or listings      
2 Edit         Create or change source data         
3 Utilities    Perform utility functions            
4 Foreground   Interactive language processing      
5 Batch        Submit job for language processing   
6 Command      Enter TSO or Workstation commands    
7 Dialog Test  Perform dialog testing               
8 LM Facility  Library administrator functions      
9 IBM Products IBM program development products     
10SCLM         SW Configuration Library Manager     
11Workplace    ISPF Object/Action Workplace         
R RACF         Resource Access Control Facility     
S SDSF         System Display and Search Facility   
ISISMF         Interactive Storage Management Fac.  
IPIPCS         Interactive Problem Control Facility 
SMSMP/E        SMP/E Dialogs                        
ICICSF         Integrated Cryptographic Service Fac.
OSSUPPORT      OS/390 ISPF System Support Options   
OUUSER         OS/390 ISPF User Options             
HCHCD          Hardware Configuration Definition    
BRBMR READ     BookManager Read                     
BIBMR INDX     BookManager Read (Create Index)      
)INIT
.ZVARS = '(ZCMD ZEXX)'
.HELP = ISR00003
&ZPRIM = YES
&ZEXX = 'X'
&ZEXI = ' '
.CURSOR = ZCMD
&TMPROWS = &ZSDATA
&TMPSHDW = &ZSSHDW
IF (&ZHILITE = YES OR &ZGUI ¬= &Z)
  .ATTRCHAR(19)='PAS(ON) COLOR(WHITE)'
  .ATTRCHAR(1A)='PAS(ON) COLOR(RED)'
  .ATTRCHAR(1B)='PAS(ON) COLOR(BLUE)'
  .ATTRCHAR(1C)='PAS(ON) COLOR(GREEN)'
  .ATTRCHAR(1D)='PAS(ON) COLOR(PINK)'
  .ATTRCHAR(1E)='PAS(ON) COLOR(YELLOW)'
  .ATTRCHAR(1F)='PAS(ON) COLOR(TURQ)'
IF (&ZGUI ¬= &Z)
  &ZPASICON = 'ON'
  &ZPASTEXT = 'OFF'
  IF (&ZSCREEN = '1')
    VGET (ZSAREA1)
    &ZSAREA = &ZSAREA1
    GOTO A
  IF (&ZSCREEN = '2')
    VGET (ZSAREA2)
    &ZSAREA = &ZSAREA2
    GOTO A
  IF (&ZSCREEN = '3')
    VGET (ZSAREA3)
    &ZSAREA = &ZSAREA3
    GOTO A
  IF (&ZSCREEN = '4')
    VGET (ZSAREA4)
    &ZSAREA = &ZSAREA4
    GOTO A
  ELSE
    VGET (ZSAREA5)
    &ZSAREA = &ZSAREA5
  A:
  &zcstf = 0                   /* initialize Status AB unavail flags */
  IF (&ZSAREA = 'OFF') &zcstf = 1
ELSE
  &ZPASICON = 'OFF'
  &ZPASTEXT = 'ON'
VGET (ZSCML ZSCBR ZSCED ZTAPPLID) PROFILE /*   @V6A*/
IF (&ZSCML = ' ') &ZSCML = 'PAGE'        /*                      @V6A */
IF (&ZSCBR  = ' ') &ZSCBR = 'PAGE'       /*                      @V6A */
IF (&ZSCED  = ' ') &ZSCED = 'PAGE'       /*                      @V6A */
IF (&ZTAPPLID = ' ') &ZTAPPLID = 'ISR'
VPUT (ZSCML ZSCBR ZSCED ZTAPPLID) PROFILE /*   @V6A*/
&ZHTOP = ISR00003   /* TUTORIAL TABLE OF CONTENTS        */
&ZHINDEX = ISR91000 /* TUTORIAL INDEX - 1ST PAGE         */
&ZSCLMPRJ = &Z      /* TUTORIAL INDEX - 1ST PAGE     @L1A*/
IF (&ZLOGO = 'YES')                                     /* CK@MJC*/
  IF (&ZSPLIT = 'NO')      /* Not in split screen            @L5A*/
    IF (&ZCMD = &Z)        /* No command pending             @L5A*/
      IF (&ZLOGOPAN ¬= 'DONE') /* No logo displayed yet      @L5A*/
        .MSG = ISRLO999    /* Set logo information           @L5A*/
        .RESP = ENTER      /* Simulate enter                 @L5A*/
        &ZLOGOPAN = 'DONE' /*                                @L5A*/
        &ZCLEAN = 'NO'     /*                                @L5A*/
    IF (&ZCMD ¬= &Z) &ZLOGOPAN = 'DONE'   /* command pending @L5A*/
    VPUT (ZLOGOPAN) SHARED /*                                @L5A*/
  IF (&ZSPLIT = 'YES') &ZLOGOPAN = 'DONE'
VPUT (ZHTOP,ZHINDEX,ZSCLMPRJ) PROFILE
IF (&ZCSTF = 1)   /* Status area = None */
  &ZIMGNAM ='ISPFGIFL'
  &ZIMGROW =3
ELSE
  &ZIMGNAM ='ISPFGIFS'
  &ZIMGROW =15
&ZIMGCOL =56
&GRPBOX1 = ''
IF (&ZCSTF='0') .ATTR(GRPBOX1) = 'WIDTH(22) DEPTH(13)'
ELSE .ATTR(GRPBOX1) = 'WIDTH(0)'
.ATTR(ZEXI)='PADC(NULLS) PAS(&ZPASICON) CSRGRP(99)'
.ATTR(ZEXX)='PAS(&ZPASTEXT) CSRGRP(99)'
)REINIT
.CURSOR = ZCMD
VGET (ZTAPPLID) PROFILE       /*                 Z41@MEA*/
IF (&ZTAPPLID = ' ') &ZTAPPLID = 'ISR'        /* Z41@MEA*/
)PROC
IF (&ZCSTF='1') .ATTR(GRPBOX1) = 'WIDTH(0)'
IF (.CURSOR = TMPROWS AND &ZCMD = ' ')
 &ZSAR  =TRANS(&ZSCREEN 1,&ZSAREA1 2,&ZSAREA2 3,&ZSAREA3 4,&ZSAREA4 *,&ZSAREA5)
 IF (&ZSAR = 'CAL','UPS','SES') &ZCMD = 'SP'
&ZSEL = TRANS (TRUNC (&ZCMD,'.')
  0,'PGM(ISPISM) SCRNAME(SETTINGS)'
  1,'PGM(ISRBRO) PARM(ISRBRO01) SCRNAME(VIEW)'
  2,'PGM(ISREDIT) PARM(P,ISREDM01) SCRNAME(EDIT)'
  3,'PANEL(ISRUTIL) SCRNAME(UTIL)'
  4,'PANEL(ISRFPA) SCRNAME(FOREGRND)'
  5,'PGM(ISRJB1) PARM(ISRJPA) SCRNAME(BATCH) NOCHECK'
  6,'PGM(ISRPTC) SCRNAME(CMD)'
  7,'PGM(ISPYXDR) PARM(&ZTAPPLID) SCRNAME(DTEST) NOCHECK'
  8,'PANEL(ISRLPRIM) SCRNAME(LMF)'
  9,'PANEL(ISRDIIS) ADDPOP'
 10,'PGM(ISRSCLM) SCRNAME(SCLM) NOCHECK'
 11,'PGM(ISRUDA) PARM(ISRWORK) SCRNAME(WORK)'
  R,'PANEL(ICHP00)'
  S,'PGM(ISFISP) NOCHECK NEWAPPL(ISF) PARM(&NEXTOPT)'
 IS,'PGM(DGTFMD01) PARM(&ZCMD) NEWAPPL(DGT) NOCHECK'
 IP,'PGM(BLSGLIBD) PARM(PANEL(BLSPPRIM)) NEWAPPL(BLSG)'
 SM,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK NEWAPPL(SMPE)'
 IC,'PANEL(CSF@PRIM) NEWAPPL(ICSF)'
 OS,'PANEL(ISR@390S) SCRNAME(OS390S) NEWAPPL(ISR)'
 OU,'PANEL(ISR@390U) SCRNAME(OS390U) NEWAPPL(ISR)'
 HC,'CMD(%CBDCHCD)'
 BR,'CMD(%EOXVSTRT) MODE(FSCR) SUSPEND NEWAPPL(EOXR) NOCHECK'
 BI,'CMD(%BKINDEX)'
  T,'PANEL(IPOICQ)'
  X,EXIT
 SP,'PGM(ISPSAM) PARM(PNS)'
 ' ',' '
   *,'?' )
&ZTRAIL=.TRAIL
)PNTS
FIELD(ZPS01001) VAR(ZCMD) VAL(0)
FIELD(ZPS01002) VAR(ZCMD) VAL(1)
FIELD(ZPS01003) VAR(ZCMD) VAL(2)
FIELD(ZPS01004) VAR(ZCMD) VAL(3)
FIELD(ZPS01005) VAR(ZCMD) VAL(4)
FIELD(ZPS01006) VAR(ZCMD) VAL(5)
FIELD(ZPS01007) VAR(ZCMD) VAL(6)
FIELD(ZPS01008) VAR(ZCMD) VAL(7)
FIELD(ZPS01009) VAR(ZCMD) VAL(8)
FIELD(ZPS01010) VAR(ZCMD) VAL(9)
FIELD(ZPS01011) VAR(ZCMD) VAL(10)
FIELD(ZPS01012) VAR(ZCMD) VAL(11)
FIELD(ZPS01013) VAR(ZCMD) VAL(R)
FIELD(ZPS01014) VAR(ZCMD) VAL(S)
FIELD(ZPS01015) VAR(ZCMD) VAL(IS)
FIELD(ZPS01016) VAR(ZCMD) VAL(IP)
FIELD(ZPS01017) VAR(ZCMD) VAL(SM)
FIELD(ZPS01018) VAR(ZCMD) VAL(IC)
FIELD(ZPS01019) VAR(ZCMD) VAL(OS)
FIELD(ZPS01020) VAR(ZCMD) VAL(OU)
FIELD(ZPS01021) VAR(ZCMD) VAL(HC)
FIELD(ZPS01022) VAR(ZCMD) VAL(BR)
FIELD(ZPS01023) VAR(ZCMD) VAL(BI)
FIELD(ZEXI) VAR(ZCMD) VAL(X) DEPTH(2) IMAGE(ISPEXIT) PLACE(L)
FIELD(ZEXX) VAR(ZCMD) VAL(X)
)END
/* 5647-A01 (C) COPYRIGHT IBM CORP 1982, 2000 */
/* ISPDTLC Release: 5.0.  Level: PID                                  */
/* OS/390 02.10.00.  Created - Date: 14 Jan 2000, Time: 13:02         */
./ ADD NAME=ZJES2PRM 0104-02207-03007-1048-00543-00472-00000-ITSCXB
/*-------------------------------------------------------*/
/* The parms below were copied from ZJES2PRM in          */
/* the RESCUE build PDS. It is recommended that you not  */
/* modify these parameters directly, but rather make any */
/* changes to the ZJES2PRM source, and rebuild the       */
/* RESCUE members.                                       */
/*-------------------------------------------------------*/
LOGON(1) APPLID=JES2
BUFDEF   BELOWBUF=(LIMIT=114,WARN=80)
CONDEF   AUTOCMD=50,
         BUFNUM=950,
         BUFWARN=80,
         CONCHAR=$,
         DISPLEN=65,
         DISPMAX=100,
         MASMSG=200,
         RDRCHAR=$
DEBUG    =NO
ESTBYTE  NUM=99999,
         INT=99999,
         OPT=0
ESTIME   NUM=2,
         INT=1,
         OPT=NO
ESTLNCT  NUM=5,
         INT=6000,
         OPT=0
ESTPAGE  NUM=100,
         INT=10,
         OPT=0
ESTPUN   NUM=100,
         INT=2000,
         OPT=0
FSSDEF(PRINTOFF)
INITDEF  PARTNUM=16
INIT(1) NAME=01,CLASS=QS,START=YES
INIT(2) NAME=02,CLASS=QS,START=YES
INIT(3) NAME=03,CLASS=QX,START=YES
INIT(4) NAME=04,CLASS=QT,START=YES
INIT(5) NAME=05,CLASS=Q,START=YES
INIT(6) NAME=06,CLASS=Q,START=YES
INIT(7) NAME=07,CLASS=Q,START=YES
INIT(8) NAME=08,CLASS=Q,START=YES
INIT(9) NAME=09,CLASS=Q,START=NO
INIT(10) NAME=10,CLASS=Q,START=NO
INIT(11) NAME=11,CLASS=Q,START=NO
INIT(12) NAME=12,CLASS=Q,START=NO
INIT(13) NAME=13,CLASS=Q,START=NO
INIT(14) NAME=14,CLASS=Q,START=NO
INIT(15) NAME=15,CLASS=Q,START=NO
INIT(16) NAME=16,CLASS=Q,START=NO
INIT(17) NAME=17,CLASS=Q,START=NO
INIT(18) NAME=18,CLASS=Q,START=NO
INIT(19) NAME=19,CLASS=Q,START=NO
INIT(20) NAME=20,CLASS=Q,START=NO
INIT(21) NAME=21,CLASS=Q,START=NO
INIT(22) NAME=22,CLASS=Q,START=NO
INIT(23) NAME=23,CLASS=Q,START=NO
INIT(24) NAME=24,CLASS=Q,START=NO
/*                                                                  */
INTRDR   AUTH=(JOB=YES,DEVICE=NO,SYSTEM=YES),BATCH=YES,CLASS=A,
         HOLD=NO,PRTYINC=0,PRTYLIM=15,RDINUM=30
/*                                                                   */
JOBCLASS(A) ACCT=YES,         /* SHORT JOBS                 ACCT REQ*/
            AUTH=INFO,        /* ALLOW INFO COMMANDS                */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            SWA=ABOVE,        /* SWA ABOVE 16MB                     */
            TIME=(0,15)       /* JOB STEP TIME                      */
JOBCLASS(B-D) ACCT=YES,       /* NOT USED                   ACCT REQ*/
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=(30,0)       /* JOB STEP TIME                      */
JOBCLASS(E) ACCT=YES,         /* ENDEVOR JOBS               ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            SWA=ABOVE,        /* SWA ABOVE 16MB                     */
            TIME=1200         /* JOB STEP TIME                      */
JOBCLASS(F-J) ACCT=YES,       /* ACCT # ALWAYS REQUIRED             */
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440         /* JOB STEP TIME                      */
JOBCLASS(K) ACCT=YES,         /* ACCT # ALWAYS REQUIRED             */
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440,        /* JOB STEP TIME                      */
            SWA=ABOVE         /* SWA ABOVE 16MB                     */
JOBCLASS(L) ACCT=YES,         /* ENDEVOR LIST               ACCT REQ*/
            AUTH=INFO,        /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            SWA=ABOVE,        /* SWA ABOVE 16MB                     */
            TIME=90           /* JOB STEP TIME                      */
JOBCLASS(M) ACCT=YES,         /* MEDIUM DEV JOBS            ACCT REQ*/
            AUTH=INFO,        /* ALLOW INFO COMMANDS                */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            SWA=ABOVE,        /* SWA ABOVE 16MB                     */
            TIME=(5,0)        /* JOB STEP TIME                      */
JOBCLASS(N) ACCT=YES,         /* LONG DEV JOBS              ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440         /* JOB STEP TIME                      */
JOBCLASS(Q-R) ACCT=YES,       /* PROD + VALU                ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440         /* JOB STEP TIME                      */
JOBCLASS(S) ACCT=YES,         /* ACCT # ALWAYS REQUIRED             */
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440,        /* JOB STEP TIME                      */
            SWA=ABOVE         /* SWA ABOVE 16MB                     */
JOBCLASS(T) ACCT=YES,         /* ACCT # ALWAYS REQUIRED             */
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440         /* JOB STEP TIME                      */
JOBCLASS(U) ACCT=YES,         /* ACCT # ALWAYS REQUIRED             */
            AUTH=INFO,        /* ALLOW INFO COMMANDS                */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            SWA=ABOVE,        /* SWA ABOVE 16MB                     */
            TIME=(5,0)        /* JOB STEP TIME                      */
JOBCLASS(V) ACCT=YES,         /* FAST PROD - NOT USED       ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440         /* JOB STEP TIME                      */
JOBCLASS(W) ACCT=YES,         /* SAR RELOAD JOBS            ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            RESTART=NO,       /* DEFAULT RESTART                    */
            TIME=1440         /* JOB STEP TIME                      */
JOBCLASS(X) ACCT=YES,         /* TSD SMP/E JOBS             ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440,        /* JOB STEP TIME                      */
            SWA=ABOVE         /* SWA ABOVE 16MB                     */
JOBCLASS(Y-Z) ACCT=YES,       /*                            ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            TIME=1440,        /* JOB STEP TIME                      */
            SWA=ABOVE         /* SWA ABOVE 16MB                     */
JOBCLASS(1-9) ACCT=YES,       /* SINGLE-THREADS (DEV)       ACCT REQ*/
            AUTH=ALL,         /* ALLOW ALL COMMANDS                 */
            BLP=YES,          /* PROCESS BLP                        */
            COMMAND=IGNORE,   /* IGNORE COMMANDS                    */
            JOURNAL=NO,       /* DON'T JOURNAL THIS JOB CLASS       */
            MSGLEVEL=(1,1),   /* INPUT/PROCEDURE, ALL MESSAGES      */
            REGION=6M,        /* REGION SIZE                        */
            SWA=ABOVE,        /* SWA ABOVE 16MB                     */
            TIME=1440         /* JOB STEP TIME                      */
/*                                                                   */
/*                                                                   */
JOBDEF   ACCTFLD=OPTIONAL,   /* ACCOUNTING FIELD OPTIONAL            */
         JCLERR=NO,          /* NO TERM. JOB W/JCL ERROR             */
     /*  JOBNUM=1000,  */    /* JOB QUEUE SIZE                       */
         JOBNUM=9999,        /* JOB QUEUE SIZE                       */
         JOBWARN=80,         /* WARNING THRESHOLD % FOR JQES         */
         NUMWARN=80,         /* WARN THRESHOLD % FOR JOB NUMB.       */
         PRTYHIGH=10,        /* UPPER LIMIT FOR AGING                */
         PRTYJECL=YES,       /*PRIORITY JECL SUPPORTED               */
         PRTYJOB=NO,         /* PRTY= ON JOB NOT SUP'D               */
         PRTYLOW=5,          /* LOWER LIMIT FOR AGING                */
         PRTYRATE=96,        /* PRTY AGING RATE X/DAY                */
         RANGE=(1-9999)      /* LOCAL JOB NUMBER RANGE               */
/*                                                                   */
JOBPRTY(1) PRIORITY=9,       /* JOB PRTY=9 IF                        */
          TIME=2             /*  < 2 MIN. EXEC. TIME                 */
                             /*                                      */
JOBPRTY(2) PRIORITY=8,       /* JOB PRTY=8 IF                        */
          TIME=5             /*  < 5 MIN. EXEC. TIME                 */
                             /*                                      */
JOBPRTY(3) PRIORITY=7,TIME=15 /*JOB PRTY=7 IF <15 MIN.  &RPRI2,...OC*/
                             /* ETC.                                 */
                             /*                                      */
JOBPRTY(4) PRIORITY=6,       /* JOB PRTY=6 IF NOLIM     &RPRI2,...OC*/
         TIME=1440           /* ETC.                                 */
                             /*                                      */
/*                            *--------------------------------------*
                              |    IDENTIFY JES2 APPLIDS TO VTAM     |
                              *--------------------------------------*
                                                                    */
MASDEF   SHARED=NOCHECK,     /* MULTI ACCESS SPOOL NOCHECK           */
         HOLD=100,           /* MINIMUM HOLD TIME                    */
         DORMANCY=(100,500), /* MINIMUM / MAXIMUM DORMANCY TIME      */
         LOCKOUT=1200        /* LOCK-OUT WARNING TIME                */
                             /*                                      */
/*                                                                  */
NJEDEF   DELAY=120,         /* MAX. MSG DELAY TIME                  */
         JRNUM=4,           /* NUM. OF JOB RECEIVERS                */
         JTNUM=4,           /* NUM. OF JOB XMITTERS                 */
         LINENUM=1,         /* NUM. OF LINES FOR NJE                */
         NODENUM=2000,      /* MAX. NUMBER OF NJE NODES             */
         OWNNODE=1,         /* THIS NODE'S NUMBER                   */
         PATH=1,            /* NUM. OF PATHS/ALT'NATE               */
         RESTMAX=8000000,   /* MAX. RESISTANCE TOLERANCE            */
         RESTNODE=100,      /* THIS NODE'S RESISTANCE               */
         RESTTOL=0,         /* ALT. RESISTANCE TOLERANCE            */
         SRNUM=4,           /* NUM. OF SYSOUT RECEIVERS             */
         STNUM=4            /* NUM. OF SYSOUT TRANSMITTERS          */
/*                                                                  */
/*OFFLOAD(1) DSN=SYS1.OFFLOAD  /* DATA SET NAME           DSN       */
/*                           /* NO. OF DEVICES (UNITS)  UNITCT      */
                             /*                                     */
OFFLOAD(1) DSN=SYS3.SPOOL.OFFLOAD,LABEL=SL,RETPD=7,UNIT=CART
OFF(1).JR CLASS=,           /* RELOAD ALL CLASSES                   */
         HOLD=,             /* RELOAD HELD - NON-HELD               */
         JOBNAME=,          /* RELOAD ANY JOB NAME                  */
                            /* MODIFY JOBS ON RELOAD                */
         MOD=(CLASS=,       /* - DON'T CHANGE CLASS                 */
              HOLD=,        /* - DON'T CHANGE HOLD                  */
              ROUTECDE=,    /* - DON'T CHANGE DEST'N                */
              SYSAFF=),     /* - DON'T CHANGE SYSAFF.               */
         NOTIFY=NO,         /* DON'T NOTIFY ON RELOAD               */
         RANGE=J1-32767,    /* RELOAD ALL JOB NUMBERS               */
         ROUTECDE=(),       /* RELOAD JOBS W/ANY DEST               */
         START=YES,         /* ABORTED WITH $S OFFLOAD              */
         SYSAFF=(),         /* RELOAD JOBS WITH ANY AFF             */
         WS=(/)             /* JOB SELECTION CRITERIA               */
/*                                                                  */
OFF(1).JT CLASS=,           /* SELECT NO CLASSES                    */
         DISP=DELETE,       /* PURGE AFTER OFFLOAD                  */
         HOLD=,             /* SELECT HELD - NON-HELD               */
         JOBNAME=,          /* SELECT ANY JOB NAME                  */
         NOTIFY=NO,         /* DON'T NOTIFY ON OFFLD.               */
         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS               */
         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST               */
         START=YES,         /* STARTED WITH $S OFFLOAD              */
         SYSAFF=(),         /* SELECT JOBS WITH ANY AFF             */
         VOLUME=(),         /* SELECT ANY SPOOL VOLUME              */
         WS=(/)             /* JOB SELECTION CRITERIA               */
/*                                                                  */
OFF(1).SR BURST=,         /* SELECT ANY BURST SETTING               */
         OUTDISP=(HOLD,KEEP,LEAVE,WRITE),
         FCB=,              /* SELECT ANY FCB                       */
         FLASH=,            /* SELECT ANY/NO FLASH                  */
         HOLD=,             /* SELCT HELD/NON-HLD JOBS              */
         JOBNAME=,          /* SELECT ANY JOB NAME                  */
                            /* MODIFY FOLLOWING ON RELOAD           */
         MOD=(BURST=,       /* - DON'T CHANGE BURST                 */
              OUTDISP=,     /* - DON'T CHANGE DSHOLD                */
              FCB=,         /* - DON'T CHANGE FCB                   */
              FLASH=,       /* - DON'T CHANGE FLASH                 */
              FORMS=,       /* - DON'T CHANGE FORMS                 */
              HOLD=,        /* - DON'T CHANGE HOLD                  */
              PRMODE=,      /* - DON'T CHANGE PRMODE                */
              QUEUE=,       /* - DON'T CHANGE CLASS                 */
              ROUTECDE=,    /* - DON'T CHANGE DESTN                 */
              UCS=,         /* - DON'T CHANGE UCS                   */
              WRITER=),     /* - DON'T CHANGE WRITER                */
         NOTIFY=NO,         /* DON'T NOTIFY ON RELOAD               */
         PRMODE=(),         /* SELECT ANY PRMODE                    */
         QUEUE=,            /* SELECT ANY SYSOUT CLASS              */
         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS               */
         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST               */
         START=YES,         /* STARTED WITH $S OFFLOAD              */
         UCS=,              /* SELECT ANY UCS                       */
         WRITER=,           /* SELECT ANY WRITER                    */
         WS=(/)             /* JOB SELECTION CRITERIA               */
                            /* - CLASS ONLY                         */
/*                                                                  */
OFF(1).ST BURST=,           /* SELECT ANY BURST SET'G               */
         DISP=DELETE,       /* PURGE AFTER OFFLOAD                  */
         OUTDISP=(HOLD,KEEP,LEAVE,WRITE),
         FCB=,              /* SELECT ANY FCB                       */
         FLASH=,            /* SELECT ANY/NO FLASH                  */
         HOLD=,             /* SELCT HELD-NON-HLD JOBS              */
         JOBNAME=,          /* SELECT ANY JOB NAME                  */
         LIMIT=(0-*),       /* SELECT ANY # LINES                   */
         NOTIFY=NO,         /* DON'T NOTIFY ON OFFLD.               */
         PLIM=(0-*),        /* SELECT ANY # PAGES                   */
         PRMODE=(),         /* SELECT ANY PRMODE                    */
         QUEUE=,            /* SELECT ANY SYSOUT CLASS              */
         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS               */
         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST               */
         START=YES,         /* STARTED WITH $S OFFLOAD              */
         UCS=,              /* SELECT ANY UCS                       */
         VOLUME=(),         /* SELECT ANY SPOOL VOLUME              */
         WRITER=,           /* SELECT ANY WRITER                    */
         WS=(/)             /* JOB SELECTION CRITERIA               */
                            /* - CLASS ONLY                         */
/*                                                                  */
/*********************************************************************/
                              /***** OUTPUT CLASS ATTRIBUTES ********/
OUTCLASS(A)   OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=PRINT,   /* PRINT CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
OUTCLASS(B)   OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=PUNCH,   /* PUNCH CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
OUTCLASS(C-I) OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=PRINT,   /* PRINT CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
OUTCLASS(J)   OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=PUNCH,   /* PRINT CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
OUTCLASS(K)   OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=PRINT,   /* PRINT CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
OUTCLASS(L)   OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=DUMMY,   /* PRINT CLASS                        */
              TRKCELL=NO      /* TRACK-CELL THIS CLASS              */
OUTCLASS(M-W) OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=PRINT,   /* PRINT CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
OUTCLASS(X)   OUTD=(HOLD,HOLD),  /* A HELD CLASS                    */
              OUTPUT=PRINT,   /* PRINT CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
OUTCLASS(Y-9) OUTD=(WRITE,WRITE), /* NOT A HELD CLASS               */
              OUTPUT=PRINT,   /* PRINT CLASS                        */
              TRKCELL=YES     /* TRACK-CELL THIS CLASS              */
/*                                                                  */
OUTDEF   BRODCAST=NO,       /* WHETHER SHARED BROADCASTING          */
         COPIES=255,        /* MAX. # OF COPIES ALLOWED             */
         DMNDSET=NO,        /* NO DEMAND SETUP                  DWNC*/
         JOENUM=3000,       /* MAX. # OF JOES                   MAM2*/
         JOEWARN=80,        /* WARNING THRESHOLD %                  */
         PRTYHIGH=255,      /* CEILING FOR PRTY AGING               */
         PRTYLOW=0,         /* FLOOR FOR PRTY AGING                 */
         PRTYOUT=NO,        /* NO PRTY= ON // OUTPUT                */
         STDFORM=STD,       /* DEFAULT FORMS ID                 DWNC*/
         USERSET=NO         /* NO USER DEMAND-SETUP             DWNC*/
/*                                                                  */
OUTPRTY(1) PRIORITY=144,    /* OUTPUT PRTY IS 144 IF                */
         RECORD=2000,       /*  < 2000 RECORDS (LINE)               */
         PAGE=50            /*  OR < 50 PAGES (PAGE)                */
/*                                                                  */
OUTPRTY(2) PRIORITY=128,    /* OUTPUT PRTY IS 128 IF                */
         RECORD=5000,       /*  < 5000 RECORDS (LINE)               */
         PAGE=100           /*  OR < 100 PAGES (PAGE)               */
/*                                                                  */
OUTPRTY(3) PRIORITY=112,     /* OUTPUT PRTY IS 112 IF   &XPRI1    OC*/
           RECORD=15000,     /*  <15000 RECORDS (LINE)  &XLIN1    OC*/
           PAGE=300          /*  OR <300 PAGES (PAGE)   &XPAG1    OC*/
                             /* ETC.                               OC*/
OUTPRTY(4) PRIORITY=96,      /* OUTPUT PRTY IS  96 IF   &XPRI1    OC*/
           RECORD=16677215,  /*  < MAX  RECORDS (LINE)  &XLIN1    OC*/
           PAGE=16677215     /*  OR <MAX PAGES (PAGE)   &XPAG1    OC*/
                             /* ETC.                               OC*/
/*                                                                  */
PCEDEF   CNVTNUM=2,         /* NUMBER OF CONVERTER PCES             */
         OUTNUM=2,          /* NUMBER OF OUTPUT PCES                */
         PSONUM=2,          /* NUMBER OF PSO PCES                   */
         PURGENUM=2         /* NUMBER OF PURGE PCES                 */
/*                                                                   */
PRINTDEF CCWNUM=200,        /* # CCWS / PRINT BUFFER            DWNC*/
         DBLBUFR=YES,       /* DOUBLE BUFFER LCL PRTS           DWNC*/
         FCB=6,             /* INITIAL FCB LOADED               DWNC*/
         LINECT=61,         /* 61 LINES/PAGE                        */
/*       NIFCB=8X8,    */   /* NO 3800 FCB LOADED               DWNC*/
/*       NIFLASH=****, */    /* NO 3800 FLASH LOADED             DWNC*/
                             /* NOTE: THE VALUES FOR NIFCB= AND      */
                             /*       NIFLASH=  CANNOT BE NULL OR    */
                             /*       ASTERISKS (AS SHOWN HERE).     */
                             /*       IF THE STATEMENTS ARE NOT      */
                             /*       CODED AT ALL, THEN THE DEFAULT */
                             /*       WILL BE ASTERISKS. THE         */
                             /*       STATEMENTS ARE SHOWN THIS WAY  */
                             /*       ONLY TO INCLUDE THE DEFAULT    */
                             /*       VALUES HERE.                   */
         NIUCS=0,            /* WAS GT15                         DWNC*/
         RDBLBUFR=NO,        /* SINGLE BUFFER RMT PRTS           DWNC*/
         SEPPAGE=(REMOTE=HALF,LOCAL=FULL),
         TRANS=NO,           /* PN-XLATE FOR 1403/RM.PR          DWNC*/
         UCS=0               /* BYPASS UCS-LOADING               DWNC*/
/*                                                                   */
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    LOCAL PRINTERS                    |
                              *--------------------------------------*
                                                                     */
                             /* ALTERNATE NAME FOR PRTN:             */
                             /*   PRINTERN                           */
PRT(1)  CLASS=A,         /* JOB CLASS THAT CAN BE CHOSEN         */
        UNIT=FDF,
        CKPTLINE=60,     /*  MAX LINES IN A LOGICAL PAGE          */
        CKPTPAGE=100,    /*  MAX PAGES BEFORE A CKPT              */
        START=YES,       /*  PRT1 COMES UP STARTED                */
        WS=(W,R,Q,PRM,LIM,F,FCB/UCS,P),
        TRKCELL=NO       /*  RECORDS DESPOOLED 1 AT A TIME    HWNC*/
/*                                                                  */
/*                                                                   */
PUNCHDEF CCWNUM=200,         /* # CCWS / PUNCH BUFFER            DWNC*/
         DBLBUFR=YES,        /* SINGLE BUFFER LCL PUNS           DWNC*/
         RDBLBUFR=NO         /* SINGLE BUFFER RMT PUNS           DWNC*/
/*                                                                   */
PUN(1)  CKPTLINE=100,    /* NO. OF CARDS TO PUNCH PER PAGE       */
        CLASS=BK,    /*  OUTPUT CLASS PROCESSED BY PUN        */
       WS=(W,R,Q,PRM,LIM/F,P)  /* WORK SELECTION CRITERION          */
/*                                                                   */
PUN(2)  CKPTLINE=100,    /* NO. OF CARDS TO PUNCH PER PAGE       */
        CLASS=BK,    /*  OUTPUT CLASS PROCESSED BY PUN        */
       WS=(W,R,Q,PRM,LIM/F,P)  /* WORK SELECTION CRITERION          */
/*                                                                   */
RDR(1)  AUTO,            /* RDRNN COMES UP STARTED (DRAIN)       */
        CLASS=A,        /* DEFAULT JOB CLASS                    */
        NOHOLD,         /* JOBS NOT HELD AFTER CONV.(HOLD)      */
        MSGCLASS=A     /* DEFAULT MESSAGE CLASS                */
                             /* ERRORS ARE COUNTED                   */
                             /*                                      */
/*                                                                   */
SMFDEF   BUFNUM=20,          /* NUMBER OF SMF BUFFERS            DWNC*/
         BUFWARN=80          /* WARNING THRESHOLD %                  */
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    SSI DEFINITIONS                   |
                              |    ADDED IN SP311                    |
                              *--------------------------------------*
                                                                     */
SSI(1)  TRACE=NO            /* SPECIFY WHICH SUBSYSTEM FUNCT        */
                            /* WHETHER OR NOT TRACING IS            */
                            /*  ACTIVE FOR THIS SSI FUNCTION        */
/*                                                                   */
STCCLASS TIME=(1440,00),     /* JOB STEP TIME   ...MMMMSS........... */
         REGION=6M,          /* REGION SIZE     .........CCC........ */
         COMMAND=EXECUTE,    /* EXECUTE COMMANDS............R....... */
         BLP=YES,            /* IGNORE BLP PARM .............L...... */
         AUTH=ALL,           /* ALLOW ALL CMDS  ..............AAAA.. */
         MSGLEVEL=(1,1),     /* JOB, ALL MSGS   ..................EF */
         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT              */
         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT              */
         OUTDISP=(HOLD,HOLD),      /* PURGE,HOLD TO HOLD,HOLD        */
         LOG=YES,            /* PRINT JES2 JOB LOG                   */
         MSGCLASS=K,         /* DEFAULT MESSAGE CLASS                */
         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB               */
         PERFORM=000,        /* SRM PERFORMANCE GROUP 0              */
         PROCLIB=00,         /* USE //PROC00 DD                      */
         SWA=BELOW,          /* SWA CBS BELOW 16M LINE               */
                             /*     (ADDED BY APAR OY02574)          */
                             /*     (SUPERSEDED BY APAR OY03444)     */
         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS                */
         TYPE26=YES          /* PRODUCE SMF 26 RECORDS               */
/*                                                                   */
/*                             TP (NJE/RJE) CHARACTERISTICS          */
/*    TPDEF    BELOWBUF=(LIMIT=200,SIZE=1152,WARN=80),               */
TPDEF    BELOWBUF=(LIMIT=200,SIZE=3840,WARN=80),
         MBUFSIZE=3840,      /* MULTI-LEAVING BUFFER SIZE            */
         RMTMSG=100,         /* MAX. # MSGS QUEUED TO REMOTE         */
         SESSION=20,         /* MAX. # SNA SESSIONS                  */
         AUTOINTV=120
/*                                                                   */
/*********************************************************************/
TRACE(1)  START=NO           /* SPECIFY WHICH TRACE ID               */
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    $TRACE FACILITY                   |
                              *--------------------------------------*
                                                                     */
TRACEDEF TABLES=3,           /* NUMBER OF TRACE TABLES               */
         PAGES=2,            /* NUMBER OF 4K PAGES PER TABLE     DWNC*/
         TABWARN=80,         /* WARNING THRESHOLD %                  */
         ACTIVE=NO,          /* WHETHER OR NOT TO START HE           */
                             /*  TRACE FACILITY                      */
         LOG=(START=NO,      /* WHETHER OR NOT TO FORMAT AND         */
                             /*  ADD DATA TO TRACE LOG DATASET       */
              SIZE=500,      /* MAX SIZE OF TRACE LOG DATASET        */
              CLASS=A)       /* TRACE LOG DATASET OUTPUT CLASS       */
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    TSU DEFAULTS                      |
                              *--------------------------------------*
                                                                     */
TSUCLASS TIME=(1440,00),     /* JOB STEP TIME   ...MMMMSS..........  */
         REGION=6M,          /* REGION SIZE     .........CCC.......  */
         COMMAND=EXECUTE,    /* EXECUTE COMMANDS............R......  */
         BLP=NO,             /* IGNORE BLP PARM .............L.....  */
         AUTH=ALL,           /* ALLOW ALL CMDS  ..............AAAA.  */
         MSGLEVEL=(0,0),     /* JOB, ALL MSGS   ..................EF */
         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT              */
         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT              */
         OUTDISP=(PURGE,HOLD),     /* PURGE,HOLD                     */
         LOG=YES,            /* PRINT JES2 JOB LOG                   */
         MSGCLASS=X,         /* DEFAULT MESSAGE CLASS                */
         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB               */
         PERFORM=000,        /* SRM PERFORMANCE GROUP 0              */
         PROCLIB=00,         /* USE //PROC00 DD                      */
         SWA=BELOW,          /* SWA CBS BELOW 16M LINE               */
                             /*     (ADDED BY APAR OY02574)          */
                             /*     (SUPERSEDED BY APAR OY03444)     */
         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS                */
         TYPE26=YES          /* PRODUCE SMF 26 RECORDS               */
                             /*                                      */
./ ADD NAME=ZMPFLST  0100-02207-02207-1614-00007-00007-00000-*BASE*
MPFHCF=+                     SUPRESSED MESSAGE INDICATOR IN HARDCOPY
.MSGCOLR ENTRYARA(R,N,H)
.MSGCOLR EVETACTN(B,N,N)
.MSGCOLR GENMSG(G,N,N)
.MSGCOLR IMEDACTN(Y,N,H)
.MSGCOLR INSTRERR(P,B,H)
.MSGCOLR PPMSG(T,N,N)
./ ADD NAME=ZTSO     0100-02207-02207-1614-00005-00005-00000-*BASE*
//TSO     PROC MBR=TSOKEY00
//STEP1   EXEC PGM=IKTCAS00,TIME=1440
//PARMLIB  DD  DSN=SYS1.RESCUE.PARMLIB(&MBR),DISP=SHR,FREE=CLOSE
//PRINTOUT DD  SYSOUT=*,FREE=CLOSE
//*
./ ADD NAME=ZTSOKEY  0100-02207-02207-1614-00007-00007-00000-*BASE*
USERMAX=10,                                                            +
RECONLIM=3,                                                            +
BUFRSIZE=132,                                                          +
HIBFREXT=6600,                                                         +
LOBFREXT=3300,                                                         +
CHNLEN=4,                                                              +
SCRSIZE=1920
./ ADD NAME=ZVATLST  0100-02207-02207-1614-00002-00002-00000-*BASE*
VATDEF IPLUSE(PRIVATE),SYSUSE(PRIVATE)
RESCUE,1,0,3390    ,Y
