./ ADD NAME=$$$DOC   0100-02365-02365-1141-00254-00254-00000-JMILLER
---------------------------------------------------------------------
Rescue System Execs - V2.0
---------------------------------------------------------------------
03/28/2001
John C. Miller
http://www.jmit.com/
john@jmit.com
---------------------------------------------------------------------
NOTE: See the $$$QUIK member to get started with minimum verbiage.

The Long Version:
This set of Rexx execs is used to build a single-volume (3390-3), self
contained OS/390 rescue system.  These exec are a replacement for the
older rescue assembler macros for building a rescue system based on
OS/390 version 1.3.  These exec are much better in my opinion. The
execs are smarter, and dynamically build lots of parmlib members,
PROCs, etc.  This version was developed based on OS/390 version 2.10,
and supports OMVS.  I've included TCP/IP libraries in this build.

Read the $$$ members - They contain useful information, especially if
you are having problems.  See the $$$MAINT member for maintenance issues
related to HFS and PDS-E support.  See the $$$RACF member for info on
RACF authority that you'll need to run the jobs that build the RESCUE
system.

You don't have to be an OS/390 guru to successfully use this set of
tools to build an OS/390 rescue system.  You do however need to have a
fairly solid grounding in OS/390 (MVS) in order to know what the various
jobs and piece parts do, and how to get past inevitable glitches.
Liberal use of the IBM manuals will be of help.  (See the web site below
for some handy IBM web manuals)

DISCLAIMER: You alone are responsible for any success that you have with
this software tool, as well as any damage done to your system, losses
incurred, etc.

I would greatly appreciate any bug reports, and will answer questions
via email, time permitting.

Good Luck, and remember to RTFM (Read The Fine Manuals)

---------------------------------------------------------------------
            VERY, VERY, EXTRAORDINARILY IMPORTANT NOTES:
      READ THESE NOW, OR BE TRULY AND PROFOUNDLY SORRY LATER:
---------------------------------------------------------------------
* Look at the generated jobs *before* running them, especially JOBA,
  the first job.  It is *incredibly* easy to wipe out an existing
  PRODUCTION disk volume with JOBA if you are not careful.  JOBA
  automatically varies a volume offline, and runs ICKDSF to
  initialize it.  You will need to reply to an MVS console prompt
  when JOBA runs. BEFORE replying to this message to continue, DOUBLE
  CHECK the unit address in the message, and be sure it's the disk
  pack that you want to wipe clean and use to build your rescue
  system.  Most of the remaining jobs are not as dangerous, but you
  should still review the JCL, and understand what each job is doing.
  (This is good for the soul anyway!)

* I'm making the significant assumption that you know what you're doing.

  IN SHORT: If you don't know what a job is going to do, you have
  absolutely no business running it !!!

---------------------------------------------------------------------
                       IMPORTANT NOTES:
            READ THESE NOW TO AVOID FRUSTRATION LATER
---------------------------------------------------------------------
* The good news, now that I've scared you into being careful, is that
  these execs can take some of the drudgery, tedium, and trial and error
  out of the process of building an OS/390 system from scratch.

* OS/390 is not a turnkey system, and these rescue execs are NOT, repeat
  NOT completely automatic.  They are simply a tool that can be used to
  greatly assist in building a single volume rescue system.  However:
  the parameters as delivered are what I used to build a fully
  functioning OS/390 rescue system, and so they may be pretty close to
  what you need, or at least a good start!

* So take some time to carefully review the @PARMS and @DATASET members.
  Don't rush through this part.  Expect to do some tweaking, and expect
  to have to do several system builds before you get a system that IPLs
  and works as expected.

  Once you get the @PARMS and @DATASET members set up the way you
  like, it's very easy to generate a fresh set of jobs, and then run
  the jobs to build a new system.  You'll may even learn something
  about OS/390 by studying the generated jobs.

* RACF Authorities:  See the $$$RACF member of this PDS for RACF
  privileges that are required.

* COMMAND and WAIT programs:  These programs enable the disk unit to be
  varied online and offline by a batch job. If you want this capability
  but don't have these programs on your system already, you can use the
  source in the RESCUE PDS to assemble them.  Assemble these modules to
  a linklisted APF authorized library.

  The COMMAND program is one that I pulled of a CBT tape.  I added code
  to do a RACHECK against the COMMAND profile in the APPL class looking
  for at least READ access.  This prevents undesirable miscreants and
  other unauthorized individuals from issuing MVS commands using this
  program.

  If you don't want to use the COMMAND and WAIT programs, code a null
  value for COMMANDPGM and WAITPGM in the @PARMS member, or just take
  these parms out altogether.  The JCL generated will no longer use
  these programs.

---------------------------------------------------------------------
                  Modifying the RESCUE execs:
---------------------------------------------------------------------
If you want to tweak, hack, or otherwise modify these execs, by all
means be my guest - but you're on your own.  I've tried to comment
the code sufficiently to give a saavy rexx coder the basic idea of
what's going on. I try to avoid truly ugly, oblique, obscure, or
overly terse ways of doing things in rexx when there's a simpler
way, but I don't shy away from "off the wall" techniques when they
work best (or when I can't figure out a simpler way of doing a
task!)

I've made the execs essentially modular, in that the main exec
RESCUE calls external subroutines that are named starting with '#'.
Each subroutine generally builds one job, or does one task.  To add
some new functionality of your own design, make a copy of one of the
subroutines like #initvol, for example, and make it do what you
want.

---------------------------------------------------------------------
Here's how to use these execs to build a one-pack rescue system:
---------------------------------------------------------------------
1)  Edit the ##PDS member, and change the 'pds=' parameter to the
    name of the RESCUE PDS which contains this $$$DOC member as well
    as the other RESCUE system parts.  I named the PDS
    'SYS2.RESCUE.EXEC', but name it whatever works for you.  Just
    remember to put that name in the ##PDS member.

2)  Edit the @DATASET member to include all the datasets needed to
    build a single volume OS/390 system.  The @DATASET members is
    delivered with the list of datasets that I used to create a
    OS/390 2.10 rescue system.  Your mileage may vary, and you
    will need to be sure that all needed datasets are included.

3)  Edit the @PARMS member with the values that you want.  The @PARMS
    member is delivered with an example set of parms that were
    actually used to successfully build a rescue system. You will want
    to change some of the parameters.

4a) Use the $BUILD job to run the rescue build execs under batch TSO.
    Fix the jobcard and PDS name (SYSPROC DD stmt) first.

4b) If desired you can place the PDS containing the rescue execs in your
    SYSPROC concatenation, and from TSO READY enter: %RESCUE. You may
    have to log off to let some of the jobs run, however, so this method
    may be a pain at times.

    Regardless of which option you choose, the necessary jobs and
    members will now be built, and named sequentially JOBA..JOBn, where
    n is howver many jobs end up getting generated.

  *******************************************************************
  *******************************************************************
  *** NOTE: Up until this point, nothing has been been changed on ***
  **  either the driving system or the new rescue system.  The     **
  **  steps below this box will start tweaking and building.       **
  **  If all goes as expected, the only changes made to the        **
  **  driving system are:                                          **
  **  a. The driving system mastercat will have an alias defined   **
  **     pointing to the rescue system mastercat.                  **
  **  b. RACF Profile TSORESC in TSOPROC class will be defined.    **
  **  c. RACF ID $RESCUE and group $STC will be defined.           **
  **                                                               **
  **     THAT SHOULD BE IT.  ANYTHING ELSE WAS NOT INTENDED,       **
  **     AND SHOULD BE DONE AT YOUR OWN RISK!!!                    **
  **     (Did I mention that you should review each job            **
  ***    before it is run?  Well, please do.)                     ***
  *******************************************************************
  *******************************************************************

5)  Run all the jobs (JOBA - JOBx).  Again -- reviewing and
    understanding the jobs *before* you run them would be, as they
    say, "a good thing."

    Investigate any job steps that complete with return code 8 or
    greater.

  *******************************************************************
  *******************************************************************
  ***  If everything was defined right, you should now have an    ***
  **   IPL'able OS/390 rescue system.  The steps below are some    **
  **   areas to check before trying to IPL.  You don't have to     **
  **   do these things now, but you'll probably save yourself      **
  ***  some IPLs if you do check them first.                      ***
  *******************************************************************
  *******************************************************************

6)  You will need to fix the ATCCON and ATCSTR members of VTAMLST, and
    also be sure that the necessary VTAMLST members are available on
    your rescue system.  Use COPY statements in the @DATASET member to
    specify members to copy.  You may want to code a special set of
    trimmed down VTAM parms in a private PDS, and copy them into VTAMLST
    and VTAMLIB using COPY statements.

7)  Review PARMLIB.  SYS1.RESCUE.PARMLIB is first in the PARMLIB concat,
    followed by whatever other PARMLIBS are coded in @DATASET with the
    'PARMLIB' attribute: ,,(PARMLIB).  Parmlib members are built for you
    and copied to SYS1.RESCUE.PARMLIB as follows:

    PROGA0   - APF authorized libraries (Coded in @DATASET with APF)
    PROGL0   - Linklist libraries (Coded in @DATASET with LNK)
    MSTJCL01 - Master JCL.  Includes all PROCLIBS coded in @DATASET with
               the "JES2" attribute.
    JES2PARM - JES2 parms. Member ZJES2PARM is combined with dynamically
               built SPOOLDEF and CKPTDEF statements, and then copied to
               the JES2PARM member in SYS1.RESCUE.PARMLIB.  Review
               ZJES2PRM for any changes you want to make *before*
               building the rescue jobs.  The SPOOLDEF and CKPTDEF are
               already coded for you, but you may want to change some of
               the other parameters, or replace the entire ZJES2PRM
               member with your own JES2 parms.  If you do this, be sure
               to remove the SPOOLDEF and CKPTDEF statements from the
               source that you place in ZJES2PARM, since these two
               statements are coded for you automatically.
    IGDSMS00 - SMS parms built from ZIGDSMS and ACDS/COMMDS statements
               built dynamically.

    NOTE: You'll need to be sure that one of the PARMLIB's that you're
    copying to the RESCUE system has the remainder of the members needed
    as coded in SYS1.RESCUE.PARMLIB(IEASYS00)'. Your production PARMLIB
    dataset will probably work fine.

8)  Review PROCLIB.  SYS1.RESCUE.PROCLIB is first in the PROCLIB
    concat, followed by whatever other PROCLIBs are coded in
    @DATASET with the "JES2" attribute: ,,(JES2).  Started procedures
    (PROCS) are built for you and copied to SYS1.RESCUE.PROCLIB as
    follows:
    TSO      - TSO started PROC.
    VTAM     - VTAM started PROC.  Includes libraries in the VTAMLST and
               VTAMLIB concatenation that you coded in @DATASET with the
               'VTAMLST' and 'VTAMLIB' attribute respectively.
    JES2     - JES2 Startup PROC.  Includes libraries in the PROC00
               concatenation that you coded in @DATASET with the 'JES2'
               attribute.
    TSORESC  - TSO LOGON PROC.  Includes libraries defined in @DATASET
               with attributes:  ISPPLIB, ISPMLIB, ISPSLIB, ISPTLIB,
               ISPLLIB, SYSPROC, SYSUADS.

9)  Review IPLPARM.  SYS1.IPLPARM on the RESCUE volume has member LOAD00
    built from the parameters you specified.  PARMLIB statements are
    included for libraries in the @DATASET member coded with the
    'PARMLIB' attribute.

10) IPL the new rescue volume, and see what happens.  Hopefully
    you'll be close to having a working system.  If it works the
    first time--you rock!

./ ADD NAME=$$$IDX   0100-02365-02365-1141-00053-00053-00000-JMILLER
Index of members:

Members starting with "#" are rexx subroutines.
Members starting with "Z" are input of some kind for the rescue execs.
"Z" members may need some modification based on local requirements.
Members starting with "@" are input parms that you need to code.

$$$DOC   - The documentation for the RESCUE execs, such as it is.
$$$IDX   - This member.
$$$MAINT - Info regarding OS/390 maintenance and non-SMS managed HFS.
$$$MISC  - Miscellaneous explanations, etc.
$$$QUIK  - Quickstart for the impatient - Better know what you're doin.
$$$RACF  - Info on RACF authority that you'll need to run the jobs.
$$$SARES - Info on building standalone restore tapes.  Important!
$BUILD   - Batch job to run RESCUE system build.
$SAREST  - Job to build a standalone RESCUE system restore tape.
##JOBCHR - Sub-subroutine - Gives the next sequential job char.
##PDS    - Sub-subroutine - Gives the name of the RESCUE PDS (This ds.)
#ALCNVSM - Build JCL to allocate nonVSAM datasets.
#ALTNVSM - Build JCL to remove System Secific Alias (SSA) (i.e. SYSX.)
#COPYDS  - Build JCL to copy datasets.
#COPYMEM - Build JCL to copy members specified in @DATASET member.
#DEFMCAT - Build JCL to define the master catalog.
#DEFNVSM - Build JCL to define nonVSAM catalog entries.
#DEFVSAM - Build JCL to define VSAM files: STGINDEX, PAGE, SMF, etc.
#INITVOL - Build JCL to ICKDSF init the RESCUE volume.
#MEMBERS - Build assorted members, and store them in this PDS.
#RFCOPY  - Build JCL to copy the RACF dataset.
@DATASET - Place where all the RESCUE system datasets are defined.
@PARMS   - Main setup member that defines how system will be built.
COMMAND  - "COMMAND" src - Issues MVS console commands, RACF secured.
RESCUE   - The main exec that is run to build all the JCL and members.
ZBPXPRM  - OMVS PARMLIB member.  MOUNT statments are added to this mem.
ZIEALPA  - IEALPA00 PARMLIB member source.  Updated by execs.
ZIEASYS  - IEASYS00 PARMLIB member.
ZJES2PRM - Partial JES2PARM member.  Modifiy if desired.
ZJOBNUM  - Work member - Last job number used.  Leave this alone.

Members that get built when the RESCUE exec is run:

BPXPRM00 - OMVS parms.
IGDSMS00 - SMS parms.
JES2     - JES2 started procedure.
JES2PARM - JES2 parameter deck.
JOBx     - Jobs that do the actual build of the RESCUE system.
LOAD00   - IPLPARM LOAD00 member.
MSTJCL01 - Master JCL PARMLIB member.
PROGA0   - PROG PARMLIB member with APF statements.
PROGL0   - PROG PARMLIB member with LNKLST statements.
TSORESC  - TSO LOGON procedure.
VTAM     - VTAM started procedure.
ZBPXPRM  - Entries are added to this member for OMVS datasets.
ZIEALPA  - Entries are added to this member for ICHRIN03 and ICHRDSNT
./ ADD NAME=$$$MAINT 0100-02365-02365-1141-00020-00020-00000-JMILLER
Note:

The RESCUE execs were coded on an OS/390 2.10 system with the required
PTFs applied for the support of non-SMS managed HFS and PDS-E files.
The jobs generated by these exec assume such support, and may have
problems if your driving system does not contain the necessary PTFs from
HFS/PDSE support on non-SMS volumes.  If this occurs, you will need to
apply the PTFs needed for your release, or settle for a two volume
rescue system:  One volume for the main OS/390 system, and a second, SMS
managed volume for the OMVS HFS files needed to bring up OMVS and
TCP/IP.

Before I could get DFDSS to copy HFS and PDS-E datasets to non-SMS
volumes, I had to apply the following PTFs to OS/390 2.10.  You may
need these and/or others, so check IBMLink for the particulars.

UW75133 UW73273 UW74319 UW75737 UW72235 UW75748 UW71231
UW71404 UW75737 UW76206 UW74319 UW75133 UW75690 UW75748

03/10/2001 John C. Miller
./ ADD NAME=$$$MISC  0100-02365-02365-1141-00070-00070-00000-JMILLER
---------------------------------------------------------------------
Rescue System Execs - Notes, explanations, etc.
---------------------------------------------------------------------

---------------------------------------------------------------------
SSA
---------------------------------------------------------------------
Explanation:
System Specific Aliases is a technique that has been used for many
moons by the IBM MVS software delivery groups.  An alias is defined in
the driving system master catalog that points to the new system
mastercat.  Any dataset names that might conflict with live datasets
are defined with an extra prefix (the "SSA") not found on the driving
system.  This accomplishes 2 desirable outcomes:

1) All catalog entries for RESCUE system datasets are created in the
RESCUE system master catalog, where we want them. This avoids junk in
the driving system master catalog or user catalogs.

2) RESCUE system datasets remain cataloged to the driving system until
the jobs are done manipulating them. This approach avoids the use of
STEPCAT DD statements, which according to IBM developers, will be
dropped completely at some point.

---------------------------------------------------------------------
RACF Started Task Table
---------------------------------------------------------------------
Explanation:  I use a RACF started task module ICHRIN03 instead of
using profiles in the RACF STARTED class, which would probably be much
more cool.  I take this approach to minimize changes to the driving

1) The RACF DS on the rescue system is a copy of the one on the driving
   system.  Therefore, before copying the RACFDS from the driving
   system, any needed RACF tweaking has to be done to the driving
   system's RACF environment. I prefer to minimize any changes to the
   driving systems RACF environment.  I basically add a RACF ID and a
   RACF group, and don't activate any classes, etc.  You just need to
   pick a USERID and GROUP name that don't already exist.  If you pick
   a USERID or GROUP that do already exist on the driving system, the
   generated jobs will contain whining messages to this effect.

2) Messing with the STARTED class on the driving system (Which you may
   or may not even be using) can have some dire consequences, and may
   result in the driving system becoming non-IPLable.  I prefer to not
   go there.

---------------------------------------------------------------------
TCP/IP
---------------------------------------------------------------------
TCP/IP will probably need some work by you before you can telnet in
and log on to your new rescue system.

The RESCUE execs handle some of the required TCP/IP setup like the
started task table entry for TCPIP, a RACF ID defined with a UID0 OMVS
segment, OMVS datasets being defined in the BPXPRM00 parmlib member,
and maybe some other stuff that I've programmed in but forgotten.

You'll need to be sure that the necessary PROCS and parameteter
members are set up right for your shop.  This is a non-trivial task,
and I have not yet risen to the task of automating this part.  It
should be a fairly simple task to copy over these elements as-is from
your production system, and make a few changes for things like the IP
address and domain name, and the hardware interface.

---------------------------------------------------------------------
MSTJCL01
---------------------------------------------------------------------
I name the master JCL member with the "01" suffix to prevent the master
scheduler from starting using any JCL found in SYS1.LINKLIB(MSTJCL00)
This way I can be absolutely sure that my master JCL member is used.
./ ADD NAME=$$$QUIK  0100-02365-02365-1141-00042-00042-00000-JMILLER
---------------------------------------------------------------------
Rescue System Execs - Quick Start
---------------------------------------------------------------------
Ok, so you're like me -- impatient, and don't want to read through all
the dumb comments, disclaimers, etc.  Here's the $.50 version of how to
use the RESCUE execs:

1)  Edit the ##PDS member, and change the 'pds=' parameter to the
    name of the RESCUE PDS which contains this $$$DOC member as well
    as the other RESCUE system parts.

2)  Edit the @DATASET member to include all the datasets needed to
    build a single volume OS/390 system.  The @DATASET members is
    delivered with the list of datasets that I used to create a
    OS/390 2.10 rescue system.  Your mileage may vary, and you
    will need to be sure that all needed datasets are included.

3)  Edit the @PARMS member with the values that you want.  The @PARMS
    member is delivered with an example set of parms that were actually
    used to successfully build a rescue system. You will probably want
    to change most if not all of them.

4)  Use the $BUILD job to run the rescue build execs under batch TSO.
    Fix the jobcard and PDS name (SYSPROC DD stmt) first.

5)  Run all the jobs (JOBA - JOBx).  Again, reviewing and understanding
    the jobs before you run them would be, as they say, "good."
    Investigate any steps that are return code 8 or greater.

    If you're really hot, you now have an IPL'able rescue system.

    If on the other hand you're like me, you'll have a few dozen little
    gotchas to fix, pieces that fell through the cracks.  Things like:

    a. VTAMLST members that reflect your local config.  Tweak the
    @DATASET member to auto copy members like these over.

    b. Assorted PARMLIB members missing.
    c. Some off the wall linklib that was missed somehow.
    d. You name it.

    Have Fun!
./ ADD NAME=$$$RACF  0100-02365-02365-1141-00037-00037-00000-JMILLER
---------------------------------------------------------------------
RACF authority needed:
---------------------------------------------------------------------
Below are some requirements for RACF authority that you'll need
to run the jobs generated by the RESCUE exec.  You don't need
these permissions to runs the execs which generate the JCL and
other members for the RESCUE system, but you will need them to actually
run some of the jobs.

I've probably missed some--if so, please drop me a note so I can add
them to the list for others who use this thing.  My email is in the
$$$DOC member - Thanks.

---------------------------------------------------------------------
RACF privileges needed:
---------------------------------------------------------------------
RACF SPECIAL is needed to run the IRRUT400 job, which locks the
production RACF dataset, and creates a copy.  If your ID does not have
the RACF SPECIAL attribute, extra warning notes will be included in the
jobs that are generated, indicating that RACF SPECIAL is needed to run
those jobs.

---------------------------------------------------------------------
RACF Facility profiles to which you will need at least ALTER access:
---------------------------------------------------------------------
STGADMIN.ADR.COPY.BYPASSACS
STGADMIN.ADR.COPY.PROCESS.SYS
STGADMIN.ADR.DUMP.TOLERATE.ENQF
STGADMIN.ADR.RESTORE.BYPASSACS
STGADMIN.ADR.RESTORE.TOLERATE.ENQF

I suggest defining a generic FACILITY profile such as would be defined
by the commands below, and getting ALTER access to it.

   RDEFINE FACILITY STGADMIN.ADR.** UACC(NONE)
   PERMIT  STGADMIN.ADR.** CLASS(FACILITY) ID(yourid) ACCESS(ALTER)
   SETROPTS RACLIST(FACILITY) REFRESH
./ ADD NAME=$$$SARES 0100-02365-02365-1141-00055-00055-00000-JMILLER
------------------------------------------------------------------*
Standalone Rescue Tapes ($SAREST)
------------------------------------------------------------------*
Run this job after you have a working RESCUE system built, and to
which you can log on to TSO and do useful tasks.  It will create a
set of tapes that you can use if you ever get completely hosed--i.e.
your system is flat on its back, and you have no system that you can
bring up to make repairs. I have been in this very situation, and I
can tell you that it is *immensely* satisfying to be able to resort
to the procedure described herein, and pull a rabbit out of a hat,
so to speak.

I suggest that you call the tapes created by this job RESCU1 -
RESCUn, and put a stick on label on each tape with the volser
written on it.  Since these tapes are non-labelled, the system
will not keep them straight for you!

Another very important suggestion: Before creating these tapes,
change the RACF password for the TSO ID you will be using to some
new value, and PHYSICALLY WRITE THIS DOWN on the first of the
tapes.  The RACF password that you were using when you created
the RESCUE system dump tapes will likely be long forgotten by the
time you get around to using them.  If you can't log on to TSO,
your RESCUE system will be worthless.  Some sysprogs will copy
the production RACF dataset to their RESCUE packs as part of a
weekly maintenance job.  DON'T DO THIS!  If your RACF dataset
happens to get damaged, then your RESCUE system gets damaged too.
Get the RESCUE system up and working, and then leave it alone.
It should not be touched unless you really need to, such as if
the IO configuration changes, and you need to update the IODF
file to reflect the new devices.

------------------------------------------------------------------*
Example of using the stand alone RESCUE restore tape. You would
only use this in the event that you could not IPL a workable
OS390 system, and had to restore the rescue system. If you have
a working OS/390 system, you can log on and do a normal DFDSS batch
RESTORE job using these tapes.
(In this example, the disk drive is unit 120, the tape is 380)
------------------------------------------------------------------*
 1) Mount the first tape written on the tape drive (380)
 2) At the HMC set the IPL address to 380.  If you don't have an
    HMC, then set the IPL address according to your particular CPU.
 3) Perform an IPL (LOAD CLEAR)
 4) From any attached local terminal hit the Enter key. You should be
    prompted to hit CLEAR when the program is ready to go. Do so.
 5) Specify CONSOLE for the input device.
 6) Specify CONSOLE for the output device.
 7) Enter the restore command:
       RESTORE FROMDEV(3400) FROMADDR(380) TOADDR(120) NOVFY
 8) Reply Y when prompted to restore the volume.  Make sure it's the
    right disk unit, or you may destroy some live data.
 9) Keep mounting tapes until they have all been read.
10) Change the IPL address to 120, and IPL again. You're (hopefully) up.
11) Log on to TSO, and save the day.
./ ADD NAME=$$README 0100-02365-02365-1141-00068-00068-00000-JMILLER
---------------------------------------------------
OS/390 Rescue System - Version 2.0
---------------------------------------------------
03/28/2001

Based on OS/390 version 2.10

An OS/390 system typically is spread out over several disk packs.
This set of Rexx execs builds the necessary jobs to generate a
completely self-contained IPL'able OS/390 version 2.10 system on
a single 3390-3 disk pack.  Earlier versions of OS/390 can also
be used, but the techniques used for copying OMVS datasets may
not work depending on the release and maintenance level of the
system being "cloned."

The system datasets on your existing OS/390 system are copied (or
in some cases re-created) on the one pack system, so the rescue
system will be at the same maintenance level as your production
system.  You can easily rebuild the rescue system after
maintenance is applied to the production system if so desired.

I recommend that you build a rescue system on one of your "spare"
disk volumes, and then make a tape backup of this volume that you
keep in a safe place. This way you will have your RESCUE system
on a disk pack and ready to IPL when you need it, but you can
also restore over this pack if you need it for any reason, and
restore the RESCUE system to some other volume from your backup
tape.  Job $SAREST will create a tape with stand alone DFDSS on
file 1 of the tape, and the RESCUE volume DFDSS restore image in
file 2.  This enables you to bring up a IPLable OS/390 system
from a totally inoperable environment.  (Great for disaster
recovery.)

The uses for such a system are many.  For those times when you
cannot IPL your main production system, this one pack rescue
system can be IPL'd to perform the necessary repair to the
production system.


How to transfer to MVS host:
---------------------------------------------------
- Download the RESCUE20.EXE self-extracting file to a PC.  Place
  RESCUE20.EXE in a directory by itself, and run it.  This will
  result in all required members being extracted. (These won't be
  readable on a PC  See note below)

- Create a PDS on the MVS system that will hold the RESCUE system
  execs and parameters.  CYL(1,1,15) should be big enough.
  RECFM=FB,LRECL=80,BLKSIZE=6160 are suitable DCB parameters.

- FTP all the extracted files from the PC to the MVS PDS
  allocated in the first step.  Use the FTP subcommand: "BINARY"
  or equivalent to specify a binary transfer.  This is a must.
  (These FTP'd files become members of the target PDS.)

- Read the $$$DOC member in the PDS for further instructions.

NOTE: The files that are in this self-extracting zip file are in
EBCDIC format, so they will look like garbage on the PC, even
after being extracted.  They will however be normal, readable
EBCDIC PDS members after they are extracted and transferred to an
MVS host using Binary mode.

---------------------------------------------------

John C. Miller
john@jmit.com
03/28/2001
./ ADD NAME=$BUILD   0100-02365-02365-1141-00018-00018-00000-JMILLER
//AOSGJCMA JOB (0),JMILLER,MSGCLASS=X,CLASS=A,NOTIFY=&SYSUID,REGION=6M
/*JOBPARM LINES=900000
//*---------------------------------------------------------------*
//* Execute TSO in batch to run RESCUE execs.                     *
//*---------------------------------------------------------------*
//* Before running this job, The name of the PDS containing the   *
//* RESCUE execs and members MUST be coded in these 2 places:     *
//* 1. The SYSPROC DD statement below, and                        *
//* 2. In the ##PDS member.                                       *
//*---------------------------------------------------------------*
//* 03/11/2001 John C. Miller.                                    *
//*---------------------------------------------------------------*
//TSO      EXEC PGM=IKJEFT01,REGION=4M,PARM='RESCUE'
//SYSPRINT DD SYSOUT=*
//SYSIN    DD DUMMY
//SYSTSPRT DD SYSOUT=*
//SYSPROC  DD DISP=SHR,DSN=SYS2.RESCUE.EXEC
//SYSTSIN  DD DUMMY
./ ADD NAME=$SAREST  0100-02365-02365-1141-00036-00036-00000-JMILLER
//AOSGJCMA JOB (0),JMILLER,MSGCLASS=X,CLASS=A,NOTIFY=&SYSUID,REGION=6M
//*------------------------------------------------------------------*
//* $SAREST - Build an IPL'able, stand alone restore tape for the
//* RESCUE system.
//*------------------------------------------------------------------*
//* IMPORTANT: See member $$$SARES notes and discussion.
//*------------------------------------------------------------------*
//* 03/28/2001 John C. Miller
//*------------------------------------------------------------------*
//*************************************************
//* Write standalone DFDSS image in file 1        *
//*************************************************
//SADSS   EXEC PGM=ADRDSSU,PARM='UTILMSG=YES'
//SAMODS    DD DSN=SYS1.SADRYLIB,DISP=SHR
//TAPE      DD UNIT=CART,DISP=(NEW,PASS),
//          DCB=(RECFM=FB,LRECL=80,BLKSIZE=80),
//          LABEL=(1,NL,EXPDT=98000),
//          VOL=(,RETAIN,SER=RESCU1)
//SYSPRINT  DD SYSOUT=*
//SYSIN     DD *
   BUILDSA -
       INDD(SAMODS) -
       OUTDD(TAPE)  -
       ADMINISTRATOR -
       IPL(CARD) -
       OPERCNSL(001F)
//*************************************************
//* Write volume dump image in file 2             *
//*************************************************
//DUMP     EXEC PGM=ADRDSSU,REGION=4M
//SYSPRINT  DD SYSOUT=*
//TAPE      DD UNIT=CART,DISP=(NEW,PASS),
//          LABEL=(2,NL,EXPDT=98000),
//          VOL=REF=*.SADSS.TAPE
//SYSIN     DD *
  DUMP INDYNAM(RESCUE) OUTDD(TAPE)
./ ADD NAME=##JOBCHR 0100-02365-02365-1141-00059-00059-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* ##JOBCHR - Issue the next sequential job number.        */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
ARG options .
##JOBCHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789"

/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

/*---------------------------------------------------------*/
/* Allocate jobnum file.                                   */
/*---------------------------------------------------------*/
##jobmemok = 1
IF SYSDSN("'"pds"(ZJOBNUM)'") /= OK THEN ##jobmemok = 0
##xx = msg('OFF')
"FREE  FI(INOUT) "
##xx = msg(##xx)
"ALLOC FI(INOUT) DA('"pds"(ZJOBNUM)') SHR REUS"

/*---------------------------------------------------------*/
/* Reset ZJOBNUM file back to 0.                           */
/*---------------------------------------------------------*/
IF options = 'RESET' THEN DO
   JOBNUM.0 = 1
   JOBNUM.1 = 0
   "EXECIO * DISKW INOUT (FINIS STEM JOBNUM."
   exit
END

/*---------------------------------------------------------*/
/* Get next sequential integer for job num.                */
/*---------------------------------------------------------*/
/* Read the ZJOBNUM member if it's there    */
IF SYSDSN("'"pds"(ZJOBNUM)'") = OK THEN DO
   "EXECIO * DISKR INOUT (FINIS STEM JOBNUM."
END

/* Reset the job num to 1 if we couldn't get a valid num.  */
IF DATATYPE(JOBNUM.0) /= 'NUM' THEN ##jobmemok = 0
IF \##jobmemok THEN DO
   JOBNUM.0 = 1
   JOBNUM.1 = 1
END

jnum = JOBNUM.1
jnum = jnum + 1
if jnum > length(##JOBCHARS) THEN jnum = 1
JOBNUM.1 = jnum
JOBNUM.0 = 1
"EXECIO * DISKW INOUT (FINIS STEM JOBNUM."
RETURN substr(##jobchars,jnum,1)

./ ADD NAME=##PDS    0100-02365-02365-1141-00017-00017-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* ##PDS    - Return main rescue PDS name.  I haven't      */
/* figured out a reliable way of dynamically determing the */
/* source PDS of a rexx exec.  PARSE SOURCE doesn't cut    */
/* it. I though about using Library Management facilities, */
/* but that complicates the process for running the RESCUE */
/* exec under batch.  If anyone actually reads this        */
/* comment and has a better way of doing this--do tell!    */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/* Code the name of your RESCUE PDS (This dataset) below:  */
/*---------------------------------------------------------*/
RETURN 'SYS2.RESCUE.EXEC'
./ ADD NAME=#ALCNVSM 0100-02365-02365-1141-00301-00301-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* #ALCNVSM - Initialize RESCUE volume.                    */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

call varinit          /* Read @parms and @dataset.         */

/*=========================================================*/
/* JOB: Allocate nonVSAM datasets.                         */
/*=========================================================*/
jobnum = ##jobchr()
Say "Building Job "jobnum": Allocate NONVSAM datasets."
call setout pds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "ALLOCNVS - Allocate nonVSAM datasets.                "
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//DEFNVSAM EXEC  PGM=IEFBR14"

dsctr = 0
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   zzunit = strip(zzunit,"B");zzpri = strip(zzpri,"B")
   zzsec  = strip(zzsec,"B"); zzdir = strip(zzdir,"B")
   IF zzdsn1 = "" THEN ITERATE
   /* Symbolic substitution in case &WHATVER was specified. */
   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)
   dsctr = dsctr + 1
   IF pos(zzmode,"CDGNHX") = 0 THEN DO
      say "Dataset not processed, mode must be C, D, G, N or H:"
      say DSNS.##xxx
   END
   IF zzmode = "D" THEN ITERATE
   IF zzmode = "H" THEN ITERATE
   IF zzmode = "C" THEN call allocn
   IF zzmode = "G" THEN call allocn
   IF zzmode = "N" THEN call allocn
end
call jcl "//*"
call clsout pds,'JOB'jobnum
RETURN

/* subr */
allocn:
IF zzdsn2 /= "" THEN tgtdsn = zzdsn2
ELSE tgtdsn = zzdsn1
ddname = LEFT(llq(tgtdsn),8)
call jcl "//"ddname" DD DISP=(NEW,KEEP),UNIT="devtype","
call jcl "//         VOL=SER="volser",DSN="ssa""tgtdsn","
call jcl "//         SPACE=("zzunit",("zzpri","zzsec","zzdir")),"
call jcl "//         DCB=("zzdsn1")"
call jcl "//*"
RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/
/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),RESCUE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
   IF r = "" THEN ITERATE
   INTERPRET q '= "'r'"'
END

/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */

RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
trace off
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(output) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Variable substitution - Very crude.       */
/* Handle some special variables, but        */
/* otherwise just return the var value.      */
/* This enables the user to specify &TSOPROC */
/* and the like in the @DATASET member.      */
/*-------------------------------------------*/
varsub:
ARG ####str
IF substr(####str,1,1) /= '&' THEN RETURN ####str
####str = substr(####str,2)  /* Strip off the "&" */
IF ####str = 'RESCUE' THEN RETURN ##pds()
IF SYMBOL(####str) = 'VAR' THEN RETURN VALUE(####str)
ELSE RETURN ####str
./ ADD NAME=#ALTNVSM 0100-02365-02365-1141-00304-00304-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* #ALTNVSM - Alter nonVSAM entries back to final name.    */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

call varinit          /* Read @parms and @dataset.         */

/*=========================================================*/
/* JOB: Alter NONVSAM entries back to final names.         */
/* (Remove the SYSX.)                                      */
/*=========================================================*/
jobnum = ##jobchr()
Say "Building Job "jobnum": Alter NONVSAM entries to final names."
call setout pds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "ALTERNVS - Alter NONVSAM names to final names, removing"
call jcc "           the "ssa" prefix. Since we aliased the SSA from"
call jcc "           the driving system's mastercat, we don't need to"
call jcc "           specify the RESCUE system catalog name in the "
call jcc "           ALTER statements. "
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//ALTERNVS EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD    SYSOUT=*"
call jcl "//SYSIN    DD    *"

dsctr = 0
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   /* Symbolic substitution in case &WHATVER was specified. */
   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)
   dsctr = dsctr + 1
   IF pos(zzmode,"CDGNHX") = 0 THEN DO
      say "Dataset not processed, mode must be C, D, G, N or H:"
      say DSNS.##xxx
   END
   IF zzmode = "D" THEN ITERATE
   IF zzmode = "C" THEN call altern
   IF zzmode = "G" THEN call altern
   IF zzmode = "N" THEN call altern
end
call jcl "//*"
call clsout pds,'JOB'jobnum
RETURN

/* subr */
altern:
IF zzdsn2 /= "" THEN tgtdsn = zzdsn2
ELSE tgtdsn = zzdsn1
call jcl "  ALTER "ssa""tgtdsn" -"
call jcl "        NEWNAME("tgtdsn") -"
call jcl "        CATALOG("newmcat")"
call jcl " "
RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/
/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),RESCUE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
   IF r = "" THEN ITERATE
   INTERPRET q '= "'r'"'
END

/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */

RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
trace off
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(output) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Variable substitution - Very crude.       */
/* Handle some special variables, but        */
/* otherwise just return the var value.      */
/* This enables the user to specify &TSOPROC */
/* and the like in the @DATASET member.      */
/*-------------------------------------------*/
varsub:
ARG ####str
IF substr(####str,1,1) /= '&' THEN RETURN ####str
####str = substr(####str,2)  /* Strip off the "&" */
IF ####str = 'RESCUE' THEN RETURN ##pds()
IF SYMBOL(####str) = 'VAR' THEN RETURN VALUE(####str)
ELSE RETURN ####str

./ ADD NAME=#COPYDS  0100-02365-02365-1141-00419-00419-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* #COPYDS  - Copy datasets.                               */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

call varinit          /* Read @parms and @dataset.         */

/*=========================================================*/
/* JOB: Copy datasets.                                     */
/*=========================================================*/
jobnum = ##jobchr()
Say "Building Job "jobnum": Copy datasets."
call setout pds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "COPY - Copy the datasets defined in the DATASETS member."
call jcd
call jcc mydate()" "comment

dsctr = 0
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zzparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   /* Symbolic substitution in case &WHATVER was specified. */
   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)
   dsctr = dsctr + 1
   IF pos(zzmode,"CDGNHX") = 0 THEN DO
      say "Dataset not processed, mode must be C, D, G, N or H:"
      say DSNS.##xxx
   END
   IF zzmode = "D" THEN call copydss
   IF zzmode = "C" THEN call copyieb
   IF zzmode = "G" THEN call copygen
   IF zzmode = "N" THEN call copynon
   IF zzmode = "H" THEN call copyhfs
end
call jcl "//*"
call clsout pds,'JOB'jobnum
RETURN

/* subr */
copydss:
stepname = "DSSC"RIGHT("00000"dsctr,4)
call jcd
call jcc stepname
call jcc "Copy "zzdsn1" with DFDSS."
call jcd
call jcl "//"stepname" EXEC PGM=ADRDSSU"
call jcl "//SYSPRINT  DD SYSOUT=* "
call jcl "//SYSIN     DD * "
call jcl "      COPY DATASET( - "
call jcl "         INCLUDE("zzdsn1")) -"
call jcl "         REPLACE    -"
IF attrib('RLSE',zzparms) THEN,  /* If not RLSE, do ALLDATA. */
call jcl "         ALLDATA(*) -"
call jcl "         TOL(ENQF) - "
call jcl "         BYPASSACS(**) -"
call jcl "         NULLSTORCLAS  -"
call jcl "         PROCESS(SYS1)  -"
IF zzdsn2 /= "" THEN,
call jcl "         RENAMEU("zzdsn1","zzdsn2") -"
call jcl "         RECATALOG("newmcat") -"
call jcl "         OUTDYNAM("volser") -"
call jcl "         SHARE"
call jcl "//*"
RETURN

/* subr */
copyieb:
stepname = "IEBC"RIGHT("0000"dsctr,4)
call jcd
call jcc stepname
call jcc "Copy "zzdsn1" with IEBCOPY"
call jcd
call jcl "//"stepname" EXEC PGM=IEBCOPY"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSUT1   DD DSN="zzdsn1",DISP=SHR,"
call jcl "//         UNIT=SYSALLDA,VOL=SER="
IF zzdsn2 /= "" THEN tgtdsn = zzdsn2
ELSE tgtdsn = zzdsn1
call jcl "//SYSUT2   DD DSN="ssa""tgtdsn",DISP=SHR,"
IF attrib('RLSE',zzparms) THEN, /* If RLSE, specify RLSE.     */
call jcl "//         SPACE=(CYL,(1,1,1),RLSE),"
call jcl "//         UNIT=SYSALLDA,VOL=SER="volser
call jcl "//SYSIN    DD * "
call jcl "  COPY I=SYSUT1,O=SYSUT2,LIST=NO "
call jcl "//*"
RETURN

/* subr */
copygen:
stepname = "GENR"RIGHT("0000"dsctr,4)
call jcd
call jcc stepname
call jcc "Copy "zzdsn1" with IEBGENER"
call jcd
call jcl "//"stepname" EXEC PGM=IEBGENER"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSUT1   DD DSN="zzdsn1",DISP=SHR,"
call jcl "//         UNIT=SYSALLDA,VOL=SER="
IF zzdsn2 /= "" THEN tgtdsn = zzdsn2
ELSE tgtdsn = zzdsn1
call jcl "//SYSUT2   DD DSN="ssa""tgtdsn",DISP=SHR,"
IF attrib('RLSE',zzparms) THEN, /* If RLSE, specify RLSE.     */
call jcl "//         SPACE=(CYL,(1,1,1),RLSE),"
call jcl "//         UNIT=SYSALLDA,VOL=SER="volser
call jcl "//SYSIN    DD DUMMY"
call jcl "//*"
RETURN

/* subr */
copynon:
stepname = "NOOP"RIGHT("0000"dsctr,4)
IF zzdsn2 /= "" THEN tgtdsn = zzdsn2
ELSE tgtdsn = zzdsn1
call jcd
call jcc stepname
call jcc "None: "tgtdsn" will not be copied."
call jcc "This dataset was specified as No-Copy (Allocate only.)"
call jcd
call jcl "//"stepname" EXEC PGM=IEFBR14"
call jcl "//*"
RETURN

/* subr */
copyhfs:
stepname = "HFSD"RIGHT("00000"dsctr,4)
call jcd
call jcc stepname
call jcc "Copy "zzdsn1" HFS with DFDSS DUMP and RESTORE."
IF zzdsn2 /= "" THEN,
call jcc "Target dsn is "zzdsn2"."
call jcd
call jcl "//"stepname" EXEC PGM=ADRDSSU"
call jcl "//SYSPRINT  DD SYSOUT=* "
call jcl "//TAPE      DD DISP=(,PASS),DSN=&&TAPE,UNIT=SYSALLDA,"
call jcl "//          VOL=SER="workvol",SPACE=(CYL,(350,200),RLSE)"
call jcl "//SYSIN     DD * "
call jcl "  DUMP    DATASET(  -"
call jcl "          INCLUDE("zzdsn1")) -"
call jcl "          TOL(ENQF) -"
call jcl "          OUTDD(TAPE)"
call jcl "//*"
stepnam2 = "HFSR"RIGHT("00000"dsctr,4)
call jcl "//"stepnam2" EXEC PGM=ADRDSSU,COND=(4,LT,"stepname")"
call jcl "//SYSPRINT  DD SYSOUT=* "
call jcl "//TAPE      DD DISP=(OLD,DELETE),DSN=&&TAPE"
call jcl "//SYSIN     DD * "
call jcl "  RESTORE DATASET( -"
call jcl "          INCLUDE(**)) -"
call jcl "          RECATALOG("newmcat") -"
call jcl "          BYPASSACS(**) -"
call jcl "          NULLSTORCLAS -"
IF zzdsn2 /= "" THEN,
call jcl "          RENAMEU("zzdsn1","zzdsn2") -"
call jcl "          OUTDYNAM("volser") -"
call jcl "          REPLACE TOL(ENQF) INDD(TAPE) "
call jcl "//*"
RETURN


/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/
/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),RESCUE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
   IF r = "" THEN ITERATE
   INTERPRET q '= "'r'"'
END

/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */

RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
trace off
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(output) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##attrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##parms, ##attrib
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Variable substitution - Very crude.       */
/* Handle some special variables, but        */
/* otherwise just return the var value.      */
/* This enables the user to specify &TSOPROC */
/* and the like in the @DATASET member.      */
/*-------------------------------------------*/
varsub:
ARG ####str
IF substr(####str,1,1) /= '&' THEN RETURN ####str
####str = substr(####str,2)  /* Strip off the "&" */
IF ####str = 'RESCUE' THEN RETURN ##pds()
IF SYMBOL(####str) = 'VAR' THEN RETURN VALUE(####str)
ELSE RETURN ####str

./ ADD NAME=#COPYMEM 0100-02365-02365-1141-00469-00469-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* #DEFNVSM - Define non-VSAM catalog entries              */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

call varinit            /* Read @parms and @dataset.       */
if \verpds() THEN exit  /* Make sure RESCUE.PARMLIB and    */
                        /* RESCUE.PROCLIB are there.       */

/*=========================================================*/
/* JOB: Copy members from RESCUE PDS to various places.    */
/*=========================================================*/
jobnum = ##jobchr()
Say "Building Job "jobnum": Copy generated members."
call setout pds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "COPYMEM - Copy customized members for various PROCs,   "
call jcc "          PARMLIB members, etc."
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//COPYMEM  EXEC  PGM=IEBCOPY"
call jcl "//SYSPRINT DD SYSOUT=*"

/*--------------------------------------------------------------------*/
/* Look for COPY commands in @DATASET member, and build DD statements.*/
/* The nxtdd() function returns a unique DDNAME to associate with the */
/* DSN passed to it.  It also saves the DSN/DD pair in the stem var   */
/* DD.x.  DD.x.$dsn = the dsn for entry x, DD.x.$dd is the correspond.*/
/* ddname for that entry. This enables us to look up the DDNAME for   */
/* our second pass through the COPY statements, which is when we build*/
/* the "  COPY I=INDD,O=OUTDD" statements.                            */
/*--------------------------------------------------------------------*/
DO xx = 1 TO DSNS.0
   IF WORD(DSNS.xx,1) /= 'COPY' THEN ITERATE
   IF POS('IN=',DSNS.xx) > 0 THEN DO
      PARSE VAR DSNS.xx 'IN=' inds1 . 1 'IN=' inds2 ','
      /* Parse ending with space, then with ',' -- Pick shortest one. */
      IF length(inds1) < length(inds2) THEN indsn = inds1
      ELSE indsn = inds2
      /* Do crude variable substitution.  */
      indsn = varsub(indsn)
      /* Parse ending with space, then with ',' -- Pick shortest one. */
      PARSE VAR DSNS.xx 'OUT=' outds1 . 1 'OUT=' outds2 ','
      IF length(outds1) < length(outds2) THEN outdsn = outds1
      ELSE outdsn = outds2
      /* See if we need to code a DD statement for this DSN:          */
      zdd = nxtdd(indsn)
      if zdd /= "" THEN DO
         call jcl "//"left(zdd,8)" DD DISP=SHR,DSN="indsn
      END
      wdd = nxtdd(outdsn)
      if wdd /= "" THEN DO
         call jcl "//"left(wdd,8)" DD DISP=SHR,DSN="outdsn","
         call jcl "//         UNIT=SYSALLDA,VOL=SER="volser
      END
   END
END

/* Look for COPY commands in @DATASET member, and build SYSIN stmts.  */
call jcl "//SYSIN    DD *"
DO xx = 1 TO DSNS.0
   IF WORD(DSNS.xx,1) /= 'COPY' THEN ITERATE
   /* Set current IN= and OUT= libraries. */
   IF POS('IN=',DSNS.xx) > 0 THEN DO
      /* Parse ending with space, then with ',' -- Pick shortest one. */
      PARSE VAR DSNS.xx 'IN=' inds1 . 1 'IN=' inds2 ','
      IF length(inds1) < length(inds2) THEN indsn = inds1
      ELSE indsn = inds2
      /* Do crude variable substitution.  */
      indsn = varsub(indsn)
      PARSE VAR DSNS.xx 'OUT=' outds1 . 1 'OUT=' outds2 ','
      /* Parse ending with space, then with ',' -- Pick shortest one. */
      IF length(outds1) < length(outds2) THEN outdsn = outds1
      ELSE outdsn = outds2
      /* Look up the dsns in the ddname table (DD.x)  */
      call jcl "  COPY I="getdd(indsn)",O="getdd(outdsn)
   END
   /* Handle the member statements. */
   IF POS('M=',DSNS.xx) > 0 THEN DO
   /* Parse membername, check for with and without parens. */
      PARSE VAR DSNS.xx 'M=(' mem1 ')' . 1 'M=' mem2 .
      IF mem1 /= "" THEN mem = mem1
      ELSE mem = mem2
      PARSE VAR mem m1 ',' m2 .
      /* Do crude variable substitution.  */
      m1 = varsub(m1); m2 = varsub(m2)
      /* Build S M=((x,y,R)) statements. */
      call jcl "   S M=(("m1","m2",R))"
   END
END


call clsout pds,'JOB'jobnum

RETURN

getdd:
/* Get DDNAME saved for this dsn. */
ARG ##dsn
IF VALUE("DD.0") = "DD.0" THEN DD.0 = 0
DO ##x10 = 1 TO DD.0
   IF DD.##x10.$dsn = ##dsn THEN RETURN DD.##x10.$dd
END
RETURN ""

nxtdd:
/* See if a DDNAME has been coded yet for this DSN: */
ARG ##dsn
IF VALUE("DD.0") = "DD.0" THEN DD.0 = 0
DO ##x10 = 1 TO DD.0
   IF DD.##x10.$dsn = ##dsn THEN RETURN ""
END

/* It hasn't yet, so find a unique DDNAME, and code it. */
##y10 = DD.0 + 1; DD.0 = ##y10
DD.##y10.$dsn = ##dsn
IF uniqdd(llq(##dsn)) THEN DO
   DD.##y10.$dd = llq(##dsn)
   RETURN DD.##y10.$dd
END

/* DDname was already taken and associated with a different dsn, */
/* so need to find a unique DDNAME (Like PROCLIB2 vs. PROCLIB)   */
/* ##a10 is the left 6 chars of the llq.                         */
##a10 = strip(left(llq(##dsn),6),'B')
DO ##z10 = 1 TO 99
  ##b10 = ##a10""right("00"##z10,2)    /* PARMLI01 for examle.   */
  if uniqdd(##b10) THEN DO
     DD.##y10.$dd = ##b10
     RETURN DD.##y10.$dd
  END
END
RETURN ""  /* Greater than 99 ddnames based on the bas ddn - Error. */

uniqdd:
ARG ##dd
IF VALUE("DD.0") = "DD.0" THEN DD.0 = 0
DO ##x11 = 1 TO DD.0
   IF DD.##x11.$dd = ##dd THEN RETURN 0
END
RETURN 1

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.            */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
IF VALUE("DSNS.0") = "DSNS.0" THEN DO
   SAY 'Need to call varinit before using this function.'
   RETURN 0
END
###dslst = ""
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zzparm ')' .
   zzdsn = strip(zzdsn,'B')
   IF zzdsn = "" THEN ITERATE
   IF attrib(##prm,zzparm) THEN DO
      IF zzdsn2 /= "" THEN,
      ###dslst = ###dslst" "zzdsn2
      ELSE,
      ###dslst = ###dslst" "zzdsn1
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.            */
/*---------------------------------------------------------*/
xdsthere:
ARG ##prm .
IF VALUE("DSNS.0") = "DSNS.0" THEN DO
   SAY 'Need to call varinit before using this function.'
   RETURN 0
END

do ##xxx = 1 TO DSNS.0
   IF POS(##prm,DSNS.##xxx) > 0 THEN RETURN 1
END
RETURN 0

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),RESCUE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
   IF r = "" THEN ITERATE
   INTERPRET q '= "'r'"'
END

/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */

RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(output) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*---------------------------------------------------------*/
/* Check for presence of all datasets.  If copy mode is    */
/* "N" meaning the DS is not copied bu just created, then  */
/* assume it is ok.                                        */
/*---------------------------------------------------------*/
verpds:
##ok1 = 0; ##ok2 = 0
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   IF zzdsn2 = 'SYS1.RESCUE.PARMLIB' THEN ##ok1 = 1
   IF zzdsn2 = 'SYS1.RESCUE.PROCLIB' THEN ##ok2 = 1
END

IF \##ok1 THEN DO
   SAY "SYS1.RESCUE.PARMLIB not defined in @DATASET member;"
END
IF \##ok2 THEN DO
   SAY "SYS1.RESCUE.PROCLIB not defined in @DATASET member;"
END
IF \##ok1 | \##ok2 THEN DO
   SAY "Unable to continue."
END

RETURN ##ok1 & ##ok2

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##attrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Variable substitution - Very crude.       */
/* Handle some special variables, but        */
/* otherwise just return the var value.      */
/* This enables the user to specify &TSOPROC */
/* and the like in the @DATASET member.      */
/*-------------------------------------------*/
varsub:
ARG ####str
IF substr(####str,1,1) /= '&' THEN RETURN ####str
####str = substr(####str,2)  /* Strip off the "&" */
IF ####str = 'RESCUE' THEN RETURN ##pds()
IF SYMBOL(####str) = 'VAR' THEN RETURN VALUE(####str)
ELSE RETURN ####str

./ ADD NAME=#DEFMCAT 0100-02365-02365-1141-00276-00276-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* #DEFMCAT - Define master catalog.                       */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

call varinit          /* Read @parms and @dataset.         */

/*=========================================================*/
/* JOB: Define master catalog.                             */
/*=========================================================*/
jobnum = ##jobchr()
Say "Building Job "jobnum": Define master catalog."
call setout pds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "DEFMCAT - Define new master catalog."
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//DEFMCAT  EXEC PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN    DD * "
call jcl " "
call jcl "      DEFINE USERCATALOG     ( -"
call jcl "             NAME("newmcat") -"
call jcl "             CYL(5 2) - "
call jcl "             VOL("volser") -"
call jcl "             BUFFERSPACE(8192) -"
call jcl "             BUFND(10) -"
call jcl "             BUFNI(10) -"
call jcl "             ICFCATALOG -"
call jcl "             STRNO(9) ) -"
call jcl "             CATALOG("oldmcat")"
call jcl " "
IF VALUE("ssa") /= "SSA" & ssa /= "" THEN DO
   zzssa = STRIP(ssa,"B",".")   /* Get rid of trailing "." */
   call jcl "      IF MAXCC = 0 THEN DO "
   call jcl "         DELETE "zzssa" ALIAS"
   call jcl "         SET MAXCC=0"
   call jcl " "
   call jcl "         DEFINE ALIAS(NAME("zzssa") -"
   call jcl "         RELATE("newmcat")) -"
   call jcl "         CATALOG("oldmcat")"
   call jcl "      END"
   call jcl " "
END

call clsout pds,'JOB'jobnum

RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/
/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),RESCUE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
   IF r = "" THEN ITERATE
   INTERPRET q '= "'r'"'
END

/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */

RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
trace off
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(output) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)
./ ADD NAME=#DEFNVSM 0100-02365-02365-1141-00307-00307-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* #DEFNVSM - Define non-VSAM catalog entries              */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

call varinit          /* Read @parms and @dataset.         */

/*=========================================================*/
/* JOB: Define NONVSAM catalog entries.                    */
/*=========================================================*/
jobnum = ##jobchr()
Say "Building Job "jobnum": Define NONVSAM catalog entries."
call setout pds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "NONVSAM - Define non-VSAM catalog entries for datasets      "
call jcc "          not copied by DFDSS.  We only define datasets that"
call jcc "          are not processed by DFDSS, because DFDSS catalogs"
call jcc "          as part of the COPY operation."
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//DEFNVSAM EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN    DD * "
call jcl " LISTCAT ENT("strip(ssa,"B",".")") ALIAS"
call jcl " IF LASTCC = 0 THEN DO"


dsctr = 0
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   /* Symbolic substitution in case &WHATVER was specified. */
   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)
   dsctr = dsctr + 1
   IF pos(zzmode,"CDGNHX") = 0 THEN DO
      say "Dataset not processed, mode must be C, D, G, N or H:"
      say DSNS.##xxx
   END
   IF zzmode = "D" THEN ITERATE
   IF zzmode = "C" THEN call defnvs
   IF zzmode = "G" THEN call defnvs
   IF zzmode = "N" THEN call defnvs
end
call jcl " END"
call jcl "//*"
call clsout pds,'JOB'jobnum
RETURN

/* subr */
defnvs:
IF zzdsn2 /= "" THEN tgtdsn = zzdsn2
ELSE tgtdsn = zzdsn1
call jcl "    DEFINE NONVSAM ( -"
call jcl "       NAME("ssa""tgtdsn") -"
call jcl "       DEVT("devtype") VOL("volser")) "
call jcl " "
RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/
/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),RESCUE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
   IF r = "" THEN ITERATE
   INTERPRET q '= "'r'"'
END

/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */

RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
trace off
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(output) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)


/*-------------------------------------------*/
/* Variable substitution - Very crude.       */
/* Handle some special variables, but        */
/* otherwise just return the var value.      */
/* This enables the user to specify &TSOPROC */
/* and the like in the @DATASET member.      */
/*-------------------------------------------*/
varsub:
ARG ####str
IF substr(####str,1,1) /= '&' THEN RETURN ####str
####str = substr(####str,2)  /* Strip off the "&" */
IF ####str = 'RESCUE' THEN RETURN ##pds()
IF SYMBOL(####str) = 'VAR' THEN RETURN VALUE(####str)
ELSE RETURN ####str

./ ADD NAME=#DEFVSAM 0100-02365-02365-1141-00469-00469-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* #DEFVSAM - Define VSAM files.                           */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

call varinit          /* Read @parms and @dataset.         */

/*=========================================================*/
/* JOB: Define VSAM files.                                 */
/*=========================================================*/
jobnum = ##jobchr()
Say "Building Job "jobnum": Define VSAM files."
call setout pds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "DEFVSAM - Define MANx, PAGE, STGINDEX datasets."
call jcd
call jcc "Define the datasets with the SSA prefix: "ssa", so that the"
call jcc "catalog entries are defined in our new rescue master catalog,"
call jcc newmcat". After the define, perform an IDCAMS ALTER to remove "
call jcc "the SSA prefix, and restore the file back to it's final name."
call jcc "These gyrations avoid the use of the STEPCAT DD statement  "
call jcc "which may become unsupported in the future."
call jcd
call jcc "We check for the SSA being defined before doing any defines."
call jcc "This prevents us from inadvertently storing junk in the "
call jcc "mster catalog of the driving system.                       "
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//DEFVSAM  EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//TARGET   DD DISP=SHR,UNIT=SYSALLDA,VOL=SER="volser
call jcl "//SYSIN    DD * "
call jcl " LISTCAT ALL ENTRY("strip(ssa,"B",".")") ALIAS"
call jcl " IF LASTCC = 0 THEN DO"
call jcl " "
call jcl "      DEFINE CLUSTER ( -"
call jcl "                NAME( "ssa"SYS1.STGINDEX ) -"
call jcl "                CYL(5) - "
call jcl "                VOL("volser") -"
call jcl "                BUFFERSPACE(20480) - "
call jcl "                FILE(TARGET) -"
call jcl "                KEYS(12 8) - "
call jcl "                RECORDSIZE(2041,2041) -"
call jcl "                REUSE ) - "
call jcl "             DATA ( -"
call jcl "                NAME( "ssa"SYS1.STGINDEX.DATA ) -"
call jcl "                CISZ(2048) ) - "
call jcl "             INDEX ( - "
call jcl "                NAME( "ssa"SYS1.STGINDEX.INDEX ) -"
call jcl "                CISZ(1024) )"
call jcl " "
call jcl "       IF LASTCC = 0 THEN DO "
call jcl "          ALTER "ssa"SYS1.STGINDEX -"
call jcl "             NEWNAME( SYS1.STGINDEX ) -"
call jcl "             CATALOG("newmcat")"
call jcl "          ALTER "ssa"SYS1.STGINDEX.DATA -"
call jcl "             NEWNAME( SYS1.STGINDEX.DATA ) -"
call jcl "             CATALOG("newmcat")"
call jcl "          ALTER "ssa"SYS1.STGINDEX.INDEX -"
call jcl "             NEWNAME( SYS1.STGINDEX.INDEX ) -"
call jcl "             CATALOG("newmcat")"
call jcl "       END "
call jcl " "
call jcl " "
call jcl "     DEFINE PAGESPACE ( -"
call jcl "                NAME( "ssa"PAGE.RESCUE.PLPA) -"
call jcl "                   CYL(150) - "
call jcl "                   VOL("volser") -"
call jcl "                   FILE(TARGET) - "
call jcl "                   NOSWAP - "
call jcl "                   UNIQUE )  "
call jcl " "
call jcl "       IF LASTCC = 0 THEN DO "
call jcl "          ALTER "ssa"PAGE.RESCUE.PLPA -"
call jcl "             NEWNAME( PAGE.RESCUE.PLPA ) - "
call jcl "             CATALOG("newmcat")"
call jcl "          ALTER "ssa"PAGE.RESCUE.PLPA.DATA -"
call jcl "             NEWNAME( PAGE.RESCUE.PLPA.DATA ) -"
call jcl "             CATALOG("newmcat")"
call jcl "       END "
call jcl " "
call jcl " "
call jcl "     DEFINE PAGESPACE ( - "
call jcl "                NAME( "ssa"PAGE.RESCUE.COMMON) -"
call jcl "                   CYL(150) - "
call jcl "                   VOL("volser") -"
call jcl "                   FILE(TARGET) - "
call jcl "                   NOSWAP - "
call jcl "                   UNIQUE ) - "
call jcl " "
call jcl "       IF LASTCC = 0 THEN DO "
call jcl "          ALTER "ssa"PAGE.RESCUE.COMMON -"
call jcl "             NEWNAME( PAGE.RESCUE.COMMON ) -"
call jcl "             CATALOG("newmcat")"
call jcl "          ALTER "ssa"PAGE.RESCUE.COMMON.DATA -"
call jcl "             NEWNAME( PAGE.RESCUE.COMMON.DATA ) -"
call jcl "             CATALOG("newmcat")"
call jcl "       END "
call jcl " "
call jcl " "
call jcl "     DEFINE PAGESPACE ( -"
call jcl "                NAME( "ssa"PAGE.RESCUE.LOCAL1) -"
call jcl "                   CYL(150) - "
call jcl "                   VOL("volser") -"
call jcl "                   FILE(TARGET) -"
call jcl "                   NOSWAP - "
call jcl "                   UNIQUE )  "
call jcl " "
call jcl "       IF LASTCC = 0 THEN DO "
call jcl "          ALTER "ssa"PAGE.RESCUE.LOCAL1 -"
call jcl "             NEWNAME( PAGE.RESCUE.LOCAL1 ) -"
call jcl "             CATALOG("newmcat")"
call jcl "          ALTER "ssa"PAGE.RESCUE.LOCAL1.DATA -"
call jcl "             NEWNAME( PAGE.RESCUE.LOCAL1.DATA ) -"
call jcl "             CATALOG("newmcat")"
call jcl "       END "
call jcl " "
call jcl " "

/*---------------------------------------------------------*/
/* Build defines for each SMF ds as defined in @DATASET,   */
/* i.e. dsns that have the SMF parm coded.                 */
/*---------------------------------------------------------*/
call smflist   /* Make list of SMF datasets. */

DO xx = 1 TO SMF.0
   smfds  = SMF.xx.$ds
   smfpri = SMF.xx.$pri
   smfpri = strip(smfpri,'L','0')
   call jcl "     DEFINE CLUSTER ( - "
   call jcl "                NAME( "ssa""smfds" ) -"
   call jcl "                   CYL( "smfpri" ) -"
   call jcl "                   VOL("volser") -"
   call jcl "                   CISZ(4096) - "
   call jcl "                   FILE(TARGET) - "
   call jcl "                   NONINDEXED - "
   call jcl "                   RECORDSIZE(4086 32767) - "
   call jcl "                   REUSE   SHR(2 3) - "
   call jcl "                   SPANNED  SPEED ) - "
   call jcl "             DATA ( -  "
   call jcl "                     NAME( "ssa""smfds".DATA) ) "
   call jcl " "
END

/* Closing END from highest level IF LASTCC (from alias).  */
call jcl " END "
call jcl "//*"

/*---------------------------------------------------------*/
/* Format SMF datasets.  They still have the SSA on front. */
/*---------------------------------------------------------*/
call jcd
call jcc "FMTSMF   - Format SMF datasets."
call jcc mydate()" "comment
call jcd
call jcl "//FMTSMF EXEC PGM=IFASMFDP"
call jcl "//SYSPRINT DD SYSOUT=*"
DO xx = 1 TO SMF.0
   smfds = SMF.xx.$ds
   smfds = ssa""smfds
   call jcl "//"substr(llq(smfds),1,8)" DD DSN="smfds",DISP=SHR,"
   call jcl "//         UNIT="devtype",VOL=SER="volser
END
call jcl "//SYSIN    DD *"
DO xx = 1 TO SMF.0
   smfds = SMF.xx.$ds
   call jcl "   INDD("llq(smfds)",OPTIONS(CLEAR))"
END
call jcl "//*"

/*---------------------------------------------------------*/
/* Rename SMF datasets to final name (remove SSA).         */
/*---------------------------------------------------------*/
call jcd
call jcc "RENSMF   - Rename SMF datasets."
call jcc mydate()" "comment
call jcd
call jcl "//RENSMF EXEC PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=*"
call jcl "//SYSIN    DD *"
call jcl " LISTCAT ALL ENTRY("strip(ssa,"B",".")") ALIAS"
call jcl " IF LASTCC = 0 THEN DO"
call jcl " "
DO xx = 1 TO SMF.0
   smfds = SMF.xx.$ds
   call jcl "       ALTER "ssa""smfds" -"
   call jcl "          NEWNAME( "smfds" ) -"
   call jcl "          CATALOG("newmcat")"
   call jcl "       ALTER "ssa""smfds".DATA -"
   call jcl "          NEWNAME( "smfds".DATA ) -"
   call jcl "          CATALOG("newmcat")"
   call jcl " "
END
call jcl " END"
call jcl "//*"
call clsout pds,'JOB'jobnum

RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/
/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* Make a list of SMF datasets, plus the PRI and SEC aloc. */
/*---------------------------------------------------------*/
smflist:
SMF.0 = 0
##x91 = 0
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zzparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   /* Symbolic substitution in case &WHATVER was specified. */
   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)
   zzparms = translate(zzparms,'    ','(),.')
   IF WORDPOS('SMF',zzparms) > 0 THEN DO
      ##x91 = ##x91 + 1
      SMF.##x91.$ds = zzdsn1
      SMF.##x91.$pri = zzpri
   END
end
SMF.0 = ##x91

RETURN

jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),RESCUE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
   IF r = "" THEN ITERATE
   INTERPRET q '= "'r'"'
END

/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */

RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
trace off
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(output) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Variable substitution - Very crude.       */
/* Handle some special variables, but        */
/* otherwise just return the var value.      */
/* This enables the user to specify &TSOPROC */
/* and the like in the @DATASET member.      */
/*-------------------------------------------*/
varsub:
ARG ####str
IF substr(####str,1,1) /= '&' THEN RETURN ####str
####str = substr(####str,2)  /* Strip off the "&" */
IF ####str = 'RESCUE' THEN RETURN ##pds()
IF SYMBOL(####str) = 'VAR' THEN RETURN VALUE(####str)
ELSE RETURN ####str

./ ADD NAME=#DELSSA  0100-02365-02365-1141-00255-00255-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* #DELSSA  - Delete SSA.                                  */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

call varinit          /* Read @parms and @dataset.         */

/*=========================================================*/
/* JOB: Delete the SSA (System Specific Alias)             */
/*=========================================================*/
jobnum = ##jobchr()
Say "Building Job "jobnum": Delete SSA: "ssa
call setout pds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "DELSSA  - Delete the System Specifc Alias: "ssa"."
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//DELSSA   EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN    DD * "
call jcl " DELETE "strip(ssa,"B",".")" ALIAS"
call jcl " "

call clsout pds,'JOB'jobnum

RETURN


/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/
/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),RESCUE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
   IF r = "" THEN ITERATE
   INTERPRET q '= "'r'"'
END

/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */

RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
trace off
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(output) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)
./ ADD NAME=#INITVOL 0100-02365-02365-1141-00356-00356-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* #INITVOL - Initialize RESCUE volume.                    */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

call varinit          /* Read @parms and @dataset.         */

/*=========================================================*/
/* JOB: Initialize RESCUE volume, define VVDS, VTOC, etc.  */
/*=========================================================*/
jobnum = ##jobchr()

/*---------------------------------------------------------*/
/* See if COMMANDPGM and WAITPGM are coded in parms.  If   */
/* not, then don't code the ONLINE and OFFLINE steps.      */
/*---------------------------------------------------------*/
IF VALUE("COMMANDPGM") = "COMMANDPGM" | commandpgm = "" THEN cmdpgm = 0
ELSE cmdpgm = 1

Say "Building Job "jobnum": Init disk pack."
call setout pds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "EXPORTD - Export the new mcat for good measure."
IF cmdpgm THEN,
call jcc "OFFLINE - Vary the target VOLSER offline."
call jcc "DSFINIT - Initialize the volume with ICKDSF."
IF cmdpgm THEN,
call jcc "ONLINE  - Vary the target VOLSER online."
call jcc "DEFVVDS - Define VVDS on volume."
call jcd
call jcc "NOTE: You will need to reply to the ICKDSF message ICK003D"
call jcc "on the MVS console after submitting this job.BE SURE that"
call jcc "the address specified in this message is the correct disk"
call jcc "unit.  If the wrong address is specified, and this wrong"
call jcc "address is an offline disk unit, it will be completely wiped"
call jcc "out, and will have to be recovered from a backup."

/*---------------------------------------------------------*/
/* Can't automatically do V ONLINE etc., so place notes    */
/* in JCL to that effect.                                  */
/*---------------------------------------------------------*/
IF \cmdpgm THEN DO
   call jcd
   call jcc "NOTE: The 'COMMAND' and/or 'WAIT' programs were not coded "
   call jcc "in the @PARMS member.  You will need to manually vary the "
   call jcc "disk unit for the rescue system offline, and online.      "
   call jcc " "
   call jcc "Before running this job, vary the disk unit offline from  "
   call jcc "the MVS console using the command: "
   call jcc "   V "addr",OFFLINE"
   call jcc "After replying to the the ICKDSF message to confirm the"
   call jcc "initialization of the disk pack, you will need to reply"
   call jcc "to the MVS allocation message with the address of the  "
   call jcc "new rescue volume, "addr"."
END
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//EXPORTD    EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN      DD * "
call jcl "     EXPORT "newmcat "-"
call jcl "            DISCONNECT    "
call jcl "     SET MAXCC=0  "
/*---------------------------------------------------------*/
/* If COMMAND cmd is available, us it to do the VARY.      */
/*---------------------------------------------------------*/
IF cmdpgm THEN DO
   call jcd
   call jcc   " OFFLINE"
   call jcd
   call jcl "//OFFLINE    EXEC PGM=COMMAND,PARM='V "addr",OFFLINE'"
   call jcl "//WAIT       EXEC PGM=WAIT,PARM=2"
END
call jcd
call jcc   "DSFINIT - DSF Initialize"
call jcd
call jcl "//DSFINIT  EXEC PGM=ICKDSF"
call jcl "//IPLTEXT  DD DISP=SHR,VOL=SER="sysres",UNIT=SYSALLDA,"
call jcl "//         DSN=SYS1.SAMPLIB(IPLRECS)"
call jcl "//         DD DISP=SHR,VOL=SER="sysres",UNIT=SYSALLDA,"
call jcl "//         DSN=SYS1.SAMPLIB(IEAIPL00)"
call jcl "//SYSPRINT DD     SYSOUT=* "
call jcl "//SYSIN      DD   *        "
call jcl " INIT     UNIT("addr") -   "
call jcl "          VOLID("volser") -"
call jcl "          VTOC(0,1,14) -  "
call jcl "          PURGE -  "
call jcl "          MAP -  "
call jcl "          NOVERIFY -  "
call jcl "          NOVALIDATE -  "
call jcl "          NOCHECK -  "
call jcl "          IPLDD(IPLTEXT) - "
call jcl "          NOBOOTSTRAP"
call jcl "//*"
/*---------------------------------------------------------*/
/* If COMMAND cmd is available, us it to do the VARY.      */
/*---------------------------------------------------------*/
IF cmdpgm THEN DO
   call jcd
   call jcc   " ONLINE - Vary the disk unit back online."
   call jcd
   call jcl "//ONLINE   EXEC PGM=COMMAND,PARM='V "addr",ONLINE'"
   call jcl "//WAIT     EXEC PGM=WAIT,PARM=2"
END
call jcd
call jcc   "DEFVVDS - Define VVDS."
call jcd
call jcl "//DEFVVDS  EXEC PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=*"
call jcl "//TARGET   DD DISP=SHR,UNIT=SYSALLDA,VOL=SER="volser
call jcl "//SYSIN    DD *"
call jcl " DELETE    SYS1.VVDS.V"volser" -"
call jcl "           FILE(TARGET) CLUSTER PURGE -"
call jcl "           CATALOG("oldmcat") "
call jcl " SET MAXCC=0"
call jcl " "
call jcl " DEFINE CLUSTER ( -"
call jcl "             NAME(SYS1.VVDS.V"volser") -"
call jcl "             CYL(1,1) -"
call jcl "             VOL("volser") -"
call jcl "             FILE(TARGET) - "
call jcl "             NONINDEXED - "
call jcl "             OWNER(RESCUE) ) -"
call jcl "          CATALOG("oldmcat")"
call clsout pds,'JOB'jobnum

RETURN


/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/
/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),RESCUE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
   IF r = "" THEN ITERATE
   INTERPRET q '= "'r'"'
END

/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */

RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
trace off
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(output) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)
./ ADD NAME=#MEMBERS 0100-02365-02365-1141-00823-00823-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* MEMBERS - Build various RESCUE system members.          */
/*---------------------------------------------------------*/
/* 03/08/2001 John C. Miller                               */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

call varinit           /* Read parms, initialize vars.     */

/*---------------------------------------------------------*/
/* Call routines to build various members.                 */
/*---------------------------------------------------------*/
call iodf              /* LOAD00 for IODF.                 */
call apf               /* PROGA0 for APF.                  */
call lnklst            /* PROGL0 for LNKLST.               */
call lpa               /* LPALST00.                        */
call jes2              /* PROC for JES2.                   */
call jes2parm          /* Create JES2PARM.                 */
call tsoproc           /* TSO LOGON PROC.                  */
call vtamproc          /* VTAM startup proc.               */
call mstrjcl           /* MSTRJCL00.                       */
call bpxprm            /* LOAD00 for IODF.                 */
call igdsms            /* IGDSMS00 member.                 */

exit

/*=====================================*/
/*  Build the LOAD00 member            */
/*=====================================*/
iodf:
SAY "Building LOAD00 IPLPARM member."
##iodf = "00"
##iodfsys = "SYS1"
/* See if nonstandard SYSx prefix. */
IF substr(iodf,1,3) = 'SYS' THEN DO
   PARSE VAR iodf ##iodfsys "." .
END

/* See if nonstandard IODFxx prefix. */
##y9 = POS('.IODF',iodf)
IF ##y9 > 0 THEN ##iodf = substr(iodf,##y9+5,2)
call setout pds,'LOAD00'  /* Set output member name.  */
call jcl "IODF     "##iodf" "substr(##iodfsys,1,8)"",
         substr(ioconfigid,1,9)"00"
call jcl "NUCLEUS  1"
call jcl "SYSCAT   "substr(volser,1,6)"113C"newmcat

/* Add PARMLIBs */
libs = xdslist('PARMLIB')
DO x = 1 TO WORDS(libs)
   call jcl "PARMLIB  "substr(WORD(libs,x),1,45)volser
END

call clsout pds,'JOB'jobnum
RETURN

/*=====================================*/
/*  Build the PROGA0 member (APF libs) */
/*=====================================*/
apf:
SAY "Building PROGA0 PARMLIB member."
call setout pds,'PROGA0'  /* Set output member name.  */

call jcl "/*--------------------------------------------------*/"
call jcl "/* APF entries dynamically built by RESCUE exec.    */"
call jcl "/*--------------------------------------------------*/"
call jcl "APF FORMAT(DYNAMIC)"

/* Add APF LIBs */
libs = xdslist('APF')
DO x = 1 TO WORDS(libs)
   ##z10 = "APF ADD "substr("DSNAME("WORD(libs,x)")",1,46)
   ##z10 = ##z10"VOLUME("volser")"
   call jcl ##z10
END

call clsout pds,'JOB'jobnum
RETURN

/*=====================================*/
/*  Build the PROGL0 member (LNKlist)  */
/*=====================================*/
lnklst:
SAY "Building PROGL0 PARMLIB member."
call setout pds,'PROGL0'  /* Set output member name.  */

call jcl "/*--------------------------------------------------*/"
call jcl "/* LNKLST entries dynamically built by RESCUE exec. */"
call jcl "/*--------------------------------------------------*/"
call jcl "LNKLST DEFINE NAME(LNKLST00)"

/* Add LNKLST LIBs */
libs = xdslist('LNK')
DO x = 1 TO WORDS(libs)
   ##z10 = "LNKLST ADD NAME(LNKLST00)"
   call jcl ##z10
   ##z10 = "     DSNAME("substr(WORD(libs,x)")",1,40)"VOLUME("volser")"
   call jcl ##z10
END

call jcl "LNKLST ACTIVATE NAME(LNKLST00)"
call clsout pds,'JOB'jobnum

RETURN

/*=====================================*/
/*  Build the LPALST member.           */
/*=====================================*/
lpa:
SAY "Building LPALST00 PARMLIB member."
call setout pds,'LPALST00'  /* Set output member name.  */

/* Add LPALST LIBs */
libs = xdslist('LPA')
DO x = 1 TO WORDS(libs)
   IF x < WORDS(libs) THEN,
   call jcl WORD(libs,x)","
   ELSE,
   call jcl WORD(libs,x)
END

call clsout pds
RETURN


/*=====================================*/
/*  Build the JES2 PROC.               */
/*=====================================*/
jes2:
SAY "Building JES2 PROC."
call setout pds,'JES2'  /* Set output member name.  */

call jcd
call jcc "JES2 Startup PROC."
call jcc "Built dynamically by RESCUE exec, "mydate()
call jcd
call jcl "//JES2     PROC JESPARM=JES2PARM"
call jcl "//IEFPROC  EXEC PGM=HASJES20,"
call jcl "//            DPRTY=(15,15),TIME=1440,PERFORM=9"
call jcl "//HASPPARM DD DISP=SHR,DSN=SYS1.RESCUE.PARMLIB(&JESPARM)"

/* Add PROCLIBs */
libs = xdslist('JES2')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//PROC00   DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

call jcl "//*"
call jcl "//IEFRDER  DD SYSOUT=*"
call jcl "//*"
call jcl "//HASPLIST DD DDNAME=IEFRDER"
call jcl "//*"
call clsout pds,'JOB'jobnum

RETURN

/*=====================================*/
/*  Build the JES2PARM member.         */
/*=====================================*/
jes2parm:
SAY "Building JES2 PARMS."
call setout pds,'JES2PARM'    /* Set output member name.  */
call setinp pds,'ZJES2PRM','JES2PRM.' /* Input member name.  */

call jcl "/*-------------------------------------------------------*/"
call jcl "/* JES2 Parameter deck.                                  */"
call jcl "/* Built dynamically by RESCUE exec, "mydate()"          */"
call jcl "/*-------------------------------------------------------*/"
call jcl "CKPTDEF  CKPT1=(DSNAME=SYS1.HASPCKPT,"
call jcl "         INUSE=YES,VOLSER="volser")"
call jcl "SPOOLDEF BUFSIZE=3856,"
call jcl "         DSNAME="chkpoint","
call jcl "         FENCE=NO,"
call jcl "         SPOOLNUM=32,"
call jcl "         TGBPERVL=5,"
call jcl "         TGSPACE=(MAX=16288,WARN=80),"
call jcl "         TGSIZE=33,"
call jcl "         TRKCELL=5,"
call jcl "         VOLUME="spoolvol
/*-------------------------------------*/
/*  Copy rest of parms from JES2PRM.   */
/*-------------------------------------*/
DO x = 1 TO JES2PRM.0
   call jcl JES2PRM.x
END

call clsout pds,'JES2PARM'
DROP JES2PRM.

RETURN


/*=====================================*/
/*  Build the BPXPRM00 member.         */
/*=====================================*/
bpxprm:
SAY "Building OMVS PARMLIB member BPXPRM00."
call setout pds,'BPXPRM00'    /* Set output member name.  */
call setinp pds,'ZBPXPRM','BPXPRM.' /* Input member name. */

/*--------------------------------------------------------*/
/*  Create haeader and copy main part of BPXPRM.          */
/*--------------------------------------------------------*/
call jcl "/*-------------------------------------------------------*/"
call jcl "/* OMVS parameters.                                      */"
call jcl "/* Built dynamically by RESCUE exec, "mydate()"          */"
call jcl "/*-------------------------------------------------------*/"
DO x = 1 TO BPXPRM.0
   call jcl BPXPRM.x
END
call jcl " "

/*--------------------------------------------------------*/
/*  Build MOUNT statments for OMVS libs.                  */
/*--------------------------------------------------------*/
DO x = 1 TO DSNS.0
   /*--------------------------------------------------------*/
   /* Parse out dsn1, dsn2 and the parms for each dataset in */
   /* the @DATASET member.  Any that have OMVSxxx will have  */
   /* a mount entry defined in BPXPRM00.                     */
   /*--------------------------------------------------------*/
   PARSE VAR DSNS.x . ',' . ',' . ',' . ',' . ',',
                    zzdsn1 ',' zzdsn2 ',' '(' zzparms ')' .
   /* Symbolic substitution in case &WHATVER was specified. */
   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)
   IF POS('OMVS',zzparms) = 0 THEN ITERATE
   PARSE VAR zzparms 'OMVS' omvsprm .    /* Is this an OMVS* entry? */
   IF zzdsn2 /= "" THEN zzdsn = zzdsn2   /* Use dsn2 if its there.  */
   ELSE zzdsn = zzdsn1
   /* Yes, it's an OMVS parm, so make a MOUNT command for it.*/
   IF omvsprm /= "" THEN call omvsmnt omvsprm, zzdsn
END

call clsout pds
DROP BPXPRM.
RETURN

/* subr. */
omvsmnt:
PARSE ARG ##omvsprm, ##omvsds
IF ##omvsprm = '/'    THEN DO
   call jcl "ROOT     FILESYSTEM('"##omvsds"')"
   call jcl "         TYPE(HFS)"
   call jcl "         MODE(RDWR)"
   call jcl " "
END
ELSE DO
   call jcl "MOUNT    FILESYSTEM('"##omvsds"')"
   call jcl "         MOUNTPOINT('"##omvsprm"')"
   call jcl "         TYPE(HFS)"
   call jcl "         MODE(RDWR)"
   call jcl " "
END
RETURN

/*=====================================*/
/*  Build the TSO LOGON PROC.          */
/*=====================================*/
tsoproc:
IF SYMBOL("TSOPROC") = 'LIT' THEN DO
   Say "TSOPROC name not defined in @PARMS member, no TSO PROC created."
   RETURN
END

SAY "Building TSO LOGON PROC" tsoproc"."

call setout pds,tsoproc    /* Set output member name.  */

call jcd
call jcc "TSO LOGON PROC"tsoproc"."
call jcc "Built dynamically by RESCUE exec, "mydate()
call jcd
p = substr(tsoproc,1,8)
call jcl "//"p" PROC"
call jcl "//IKJACCNT EXEC PGM=IKJEFT01,DYNAMNBR=200,PARM='%ISPALLOC'"

/* Add ISPPLIBs */
libs = xdslist('ISPPLIB')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//ISPPLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add ISPMLIBs */
libs = xdslist('ISPMLIB')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//ISPMLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add ISPSLIBs */
libs = xdslist('ISPSLIB')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//ISPSLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add ISPLLIBs */
libs = xdslist('ISPLLIB')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//ISPLLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add ISPTLIBs */
libs = xdslist('ISPTLIB')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//ISPTLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add SYSPROCs */
libs = xdslist('SYSPROC')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//SYSPROC  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add SYSHELPs */
libs = xdslist('SYSHELP')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//SYSHELP  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add SYSLBC */
libs = xdslist('SYSLBC')
IF words(libs) > 0 THEN DO
   call jcl "//SYSLBC   DD DISP=SHR,DSN="WORD(libs,1)
END

/* Add MISC LOGON statements. */

call jcl "//SYSPRINT DD TERM=TS,SYSOUT=Z"
call jcl "//SYSTERM  DD TERM=TS,SYSOUT=Z"
call jcl "//SYSIN    DD TERM=TS "

call clsout pds,'JOB'jobnum

RETURN

/*=====================================*/
/*  Build the VTAM startup PROC.       */
/*=====================================*/
vtamproc:
SAY "Building VTAM PROC."
call setout pds,'VTAM' /* Set output member name.  */

call jcd
call jcc "VTAM Started procedure."
call jcc "Built dynamically by RESCUE exec, "mydate()
call jcd
call jcl "//VTAM     EXEC PGM=ISTINM01,REGION=0M,"
call jcl "//         DPRTY=(15,15),TIME=1440,PERFORM=8"

/* Add VTAMLSTs */
libs = xdslist('VTAMLST')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//VTAMLST  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add VTAMLIBs */
libs = xdslist('VTAMLIB')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//VTAMLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END
sistclib = 'SYS1.SISTCLIB'
IF xdsthere(sistclib) THEN,
call jcl "//SISTCLIB DD DISP=SHR,DSN="sistclib

call jcl "//SYSABEND DD SYSOUT=*,HOLD=YES"

call clsout pds,'JOB'jobnum

RETURN

/*=====================================*/
/*  Build Master JCL deck (MSTJCL01)   */
/*=====================================*/
mstrjcl:
SAY "Building Master JCL member."
call setout pds,'MSTJCL01' /* Set output member name.  */

call jcl "//MSTJCL01 JOB MSGLEVEL=(1,1),TIME=1440"
call jcd
call jcc "Master JCL."
call jcc "Built dynamically by RESCUE exec, "mydate()
call jcd
call jcl "//         EXEC PGM=IEEMB860,DPRTY=(15,15)"
call jcl "//STCINRDR DD SYSOUT=(A,INTRDR)"
call jcl "//TSOINRDR DD SYSOUT=(A,INTRDR)"

/* Add PROCLIBs */
libs = xdslist('JES2')
DO x = 1 TO WORDS(libs)
   IF x = 1 THEN,
   call jcl "//IEFPDSI  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add SYSUADSs */
libs = xdslist('SYSUADS')
IF WORDS(libs) > 0 THEN,
   call jcl "//SYSUADS  DD DISP=SHR,DSN="WORD(libs,1)

/* Add SYSLBCs */
libs = xdslist('SYSLBC')
IF WORDS(libs) > 0 THEN,
   call jcl "//SYSLBC   DD DISP=SHR,DSN="WORD(libs,1)

call clsout pds,'JOB'jobnum

RETURN

/*=========================================================*/
/* Create IGDSMS member from ZIGDSMS contents plus entries */
/* for the ACDS and COMMDS files.                          */
/*=========================================================*/
igdsms:

SAY "Building IGDSMS00 SMS parmlib member."
/*---------------------------------------------------------*/
/* If no member found, set stem count to 0 for later, and  */
/* plan to write output to ZIEALPA.                        */
/*---------------------------------------------------------*/
stat = setinp(pds,'ZIGDSMS')  /* Open member ZIEALPA for input. */
IF stat = 'MEMBER NOT FOUND' THEN DO
   SAY "IGDSMS00 not created, model ZIGDSMS not found."
   RETURN
END
libs1 = xdslist('ACDS')
libs2 = xdslist('COMMDS')
IF WORDS(libs1) = 0 THEN DO
   SAY "IGDSMS00 not built -- ACDS must be defined in @DATASET."
   RETURN
END
IF WORDS(libs1) = 0 THEN DO
   SAY "IGDSMS00 not built -- COMMDS must be defined in @DATASET."
   RETURN
END

smsacds = WORD(libs1,1)  /* Pick first (hopefully only) ACDS ent. */
smscommds = WORD(libs2,1)  /* Pick first (hopefully only) COMM ent. */

/*---------------------------------------------------------*/
/* Build IGDSMS00 member.                                  */
/*---------------------------------------------------------*/
call setout pds,'IGDSMS00'           /* Write to IGDSMS00  */
/* Code ACDS and COMMDS to start member.                   */
call jcl "SMS ACDS("smsacds")"
call jcl "    COMMDS("smscommds")"

/* Finish member with ZIGDSMS contents.                    */
DO xx = 1 TO INPUT.0
   call jcl INPUT.xx
END

call clsout pds

RETURN

/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.            */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zzparm ')' .
   zzdsn = strip(zzdsn,'B')
   IF zzdsn = "" THEN ITERATE
   IF attrib(##prm,zzparm) THEN DO
      IF zzdsn2 /= "" THEN,
      ###dslst = ###dslst" "zzdsn2
      ELSE,
      ###dslst = ###dslst" "zzdsn1
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.            */
/*---------------------------------------------------------*/
xdsthere:
ARG ##prm .
do ##xxx = 1 TO DSNS.0
   IF POS(##prm,DSNS.##xxx) > 0 THEN RETURN 1
END
RETURN 0

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),RESCUE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   INTERPRET q '= "'r'"'
END
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS mem.   */
RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
trace off
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(pds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(pds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*-------------------------------------------*/
/* Variable substitution - Very crude.       */
/* Handle some special variables, but        */
/* otherwise just return the var value.      */
/* This enables the user to specify &TSOPROC */
/* and the like in the @DATASET member.      */
/*-------------------------------------------*/
varsub:
ARG ####str
IF substr(####str,1,1) /= '&' THEN RETURN ####str
####str = substr(####str,2)  /* Strip off the "&" */
IF ####str = 'RESCUE' THEN RETURN ##pds()
IF SYMBOL(####str) = 'VAR' THEN RETURN VALUE(####str)
ELSE RETURN ####str

./ ADD NAME=#MISC    0100-02365-02365-1141-00379-00379-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* #MISC    - Do various other tasks.                      */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

call varinit          /* Read @parms and @dataset.         */

/*=========================================================*/
/* JOB: Misc.                                              */
/*=========================================================*/
jobnum = ##jobchr()
Say "Building Job "jobnum": Misc. tasks."
call setout pds,'JOB'jobnum
call jobcard jobnum

call logrec           /* Initialize logrec dataset.        */
call syncuads         /* SYNC UADS ds.                     */
call dumpfmt          /* Format DUMP datasets.             */

call clsout pds,'JOB'jobnum
RETURN

/*---------------------------------------------------------*/
/* Format LOGREC dataset.                                  */
/*---------------------------------------------------------*/
logrec:
libs = xdslist('LOGREC')
IF WORDS(libs) > 0 THEN logrec = WORD(libs,1)
ELSE logrec = ""

call jcd
call jcc "Job "jobnum
call jcd
call jcc "LOGREC  - Format LOGREC dataset."
call jcd
call jcc mydate()" "comment
call jcd
/* Format LOGREC dataset if any entry in @dataset was found with */
/* the LOGREC parm coded.    */
IF logrec /= "" THEN DO
   call jcc "LOGREC  - Format the LOGREC dataset."
   call jcd
   call jcl "//LOGREC   EXEC PGM=IFCDIP00"
   call jcl "//SERERDS  DD DISP=SHR,DSN="logrec","
   call jcl "//         UNIT="devtype",VOL=SER="volser
   call jcl "//*"
END

RETURN

/*---------------------------------------------------------*/
/* SYNC UADS if SYSUADS and SYSLBC datasets were found in  */
/* @DATASET.                                               */
/*---------------------------------------------------------*/
syncuads:
libs = xdslist('SYSUADS')
IF WORDS(libs) > 0 THEN sysuads = WORD(libs,1)
ELSE sysuads = ""
libs = xdslist('SYSLBC')
IF WORDS(libs) > 0 THEN syslbc = WORD(libs,1)
ELSE syslbc = ""
IF sysuads = "" | syslbc = "" THEN DO
   Say "SYSUADS and SYSLBC datasets not defined in @DATASET-Exiting."
   RETURN
END

/* Found the SYSUADS and SYSLBC, so build the SYNC JCL. */

call jcd
call jcc "SYNCUADS - Sync UADS / Brodcast dataset."
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//SYNCUADS EXEC PGM=IKJEFT01,DYNAMNBR=15 "
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN    DD DUMMY "
call jcl "//SYSUADS  DD DISP=SHR,DSN="sysuads","
call jcl "//         UNIT="devtype",VOL=SER="volser
call jcl "//SYSLBC   DD DISP=SHR,DSN="syslbc","
call jcl "//         UNIT="devtype",VOL=SER="volser
call jcl "//SYSTSPRT DD SYSOUT=* "
call jcl "//SYSTSIN  DD * "
call jcl "  ACCOUNT       "
call jcl "  SYNC          "
call jcl "  END           "
call jcl "//*"

RETURN

/*---------------------------------------------------------*/
/* JCL to format any DUMP datasets found in @DATASET.      */
/*---------------------------------------------------------*/
dumpfmt:
libs = xdslist('DUMP')
IF WORDS(libs) = 0 THEN DO
   Say "No DUMP datasets defined in @DATASET - Exiting."
   RETURN
END

/* Found the some dump datasets, so format them.        */
call jcd
call jcc "FMTDUMP  - Format DUMP datasets."
call jcd
call jcc mydate()" "comment
call jcd

DO xx = 1 TO WORDS(libs)
   dmpds = WORD(libs,xx)
   call jcl "//DMPINT0 EXEC PGM=IEBGENER"
   call jcl "//SYSPRINT DD SYSOUT=*"
   call jcl "//SYSIN    DD DUMMY"
   call jcl "//SYSUT1   DD DUMMY,"
   call jcl "//         LRECL=4160,BLKSIZE=4160,RECFM=FB,DSORG=PS"
   call jcl "//SYSUT2   DD DSN="dmpds",DISP=SHR,"
   call jcl "//         UNIT="devtype",VOL=SER="volser
   call jcl "//*"
END

RETURN


/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.            */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zzparm ')' .
   zzdsn = strip(zzdsn,'B')
   IF zzdsn = "" THEN ITERATE
   IF attrib(##prm,zzparm) THEN DO
      IF zzdsn2 /= "" THEN,
      ###dslst = ###dslst" "zzdsn2
      ELSE,
      ###dslst = ###dslst" "zzdsn1
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),RESCUE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
   IF r = "" THEN ITERATE
   INTERPRET q '= "'r'"'
END

/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */

RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
trace off
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(output) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)
./ ADD NAME=#RFCOPY  0100-02365-02365-1141-00298-00298-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* #RACFDS - Copy RACF dataset.                            */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

call varinit          /* Read @parms and @dataset.         */

/*=========================================================*/
/* JOB: Copy the RACF dataset.                             */
/*=========================================================*/
jobnum = ##jobchr()

##runjob = 1

IF VALUE("racfds") = "RACFDS" | racfds = "" THEN DO
   Say 'RACFDS parameter not specified - RACF dataset not copied.'
   RETURN
END

/*---------------------------------------------------------*/
/* Get DS info.                                            */
/*---------------------------------------------------------*/
x = listdsi("'"racfds"'")
units = 'CYL'
IF sysunits = 'TRACK' THEN units = 'TRK'

/* If RACFVOL specified, specify it in the JCL.            */
IF VALUE("racfvol") = "RACFVOL" | racfvol = "" THEN rfvol = ""
ELSE rfvol = racfvol

/* Build SPACE= parm.                                      */
spaceprm = "SPACE=("units",("sysprimary","sysseconds"))"

/*---------------------------------------------------------*/
/* Build JCL.                                              */
/*---------------------------------------------------------*/
Say "Building Job "jobnum": Copy RACF Dataset."
call setout pds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "RFCOPY   - Copy the RACF dataset."
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//COPY     EXEC PGM=IRRUT400,PARM='LOCKINPUT,FREESPACE(20)'"
call jcl "//SYSPRINT DD SYSOUT=*"
call jcl "//INDD1    DD DSN="racfds",DISP=OLD,"
call jcl "//         UNIT=SYSALLDA,VOL=SER="rfvol
call jcl "//OUTDD1   DD DSN="ssa""racfds",DISP=(,CATLG),"
call jcl "//         UNIT=SYSALLDA,VOL=SER="volser","
call jcl "//         DCB=("racfds"),"spaceprm
call jcl "//UNLOCK   EXEC PGM=IRRUT400,PARM='UNLOCKINPUT'"
call jcl "//SYSPRINT DD SYSOUT=*"
call jcl "//INDD1    DD DSN="racfds",DISP=OLD,"
call jcl "//         UNIT=SYSALLDA,VOL=SER="rfvol
/*-------------------------------------------*/
/* Alter RF DS name to final name (dump SSA) */
/*-------------------------------------------*/
call jcd
call jcc "ALTERRF  - Change the RACF Dataset name to its final"
call jcc "           name without the "ssa" prefix."
call jcd
call jcl "//ALTERRF  EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD    SYSOUT=*"
call jcl "//SYSIN    DD    *"
call jcl "  ALTER "ssa""racfds" -"
call jcl "        NEWNAME("racfds") -"
call jcl "        CATALOG("newmcat")"
call jcl " "

call clsout pds,'JOB'jobnum

RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/
/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),RESCUE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
   IF r = "" THEN ITERATE
   INTERPRET q '= "'r'"'
END

/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */

RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
trace off
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(output) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)
./ ADD NAME=#RFDSNT  0100-02365-02365-1141-00327-00327-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* #RFDSNT - RACF Dataset Name Table (ICHRDSNT)            */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

call varinit          /* Read @parms and @dataset.         */

IF rfdsnt /= 'YES' THEN DO
   Say "RFDSNT parameter not specified - ICHRDSNT assembly not created."
   RETURN
END

call makedsnt         /* Build the DSN table.              */
call iealpa           /* Build MLPA member to use ICHRDSNT.*/

exit

/*=========================================================*/
/* JOB: RACF Dataset Name Table (ICHRDSNT)                 */
/*=========================================================*/
makedsnt:
jobnum = ##jobchr()

Say "Building Job "jobnum": Assemble ICHRDSNT table."
call setout pds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "RFDSNT   - Assemble RACF dataset name table (ICHRDSNT)"
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//STEP1    EXEC ASMACL,PARM.C='OBJECT,NODECK',"
call jcl "// PARM.L='SIZE=(320K,250K)' "
call jcl "//C.SYSLIB DD  DSN=SYS1.MACLIB,DISP=SHR "
call jcl "//         DD  DSN=SYS1.MODGEN,DISP=SHR "
call jcl "//SYSIN    DD  * "
call jcl "ICHRDSNT CSECT "
call jcl "         DC    AL1(1)             NUMBER OF RACF DATA"
call jcl "         DC    CL44'"racfds"'     RACF PRIMARY DATASET"
call jcl "         DC    CL44' '            RACF BACKUP DATASET"
call jcl "         DC    AL1(255)           RESIDENT INDEX BLKS"
call jcl "         DC    XL1'81'            DUPLICATE ALL EXCEPT"
call jcl "         END"
call jcl "//L.SYSLMOD     DD DSN=SYS1.RESCUE.LINKLIB,DISP=SHR,"
call jcl "//  UNIT=SYSALLDA,VOL=SER="volser
call jcl "//L.SYSIN       DD *"
call jcl "  NAME ICHRDSNT(R) "

call clsout pds,'JOB'jobnum
RETURN

/*=========================================================*/
/* Create IEALPA member from ZIEALPA contents plus an      */
/* entry we'll build for ICHRDSNT.                         */
/*=========================================================*/
iealpa:

/*---------------------------------------------------------*/
/* If no member found, set stem count to 0 for later, and  */
/* plan to write output to ZIEALPA.                        */
/*---------------------------------------------------------*/
stat = setinp(pds,'ZIEALPA')  /* Open member ZIEALPA for input. */
IF stat = 'MEMBER NOT FOUND' THEN DO
   SAY "Model MLPA member ZIEALPA not found, and will be created."
   INPUT.0 = 0
   outmem = 'ZIEALPA'
END
ELSE IF stat /= 'OK' THEN DO
   Say "Error opening ZIEALPA, exiting."
   RETURN
END

/*---------------------------------------------------------*/
/* If there's already an entry for this module, do nothing.*/
/*---------------------------------------------------------*/
DO xx = 1 TO INPUT.0
/* Parse out comments first. */
   PARSE VAR INPUT.xx p '/*'
   IF POS("ICHRDSNT",p) > 0 THEN DO
      SAY "ICHRDSNT entry already in MLPA model - No entry added."
      call clsinp pds,'ZIEALPA'  /* Close input file. */
      RETURN
   END
END

/*---------------------------------------------------------*/
/* No entry found, so rebuild ZIEALPA with out mod added.  */
/*---------------------------------------------------------*/
call setout pds,'ZIEALPA'
DO xx = 1 TO INPUT.0
   call jcl INPUT.xx
END
stcent = "INCLUDE LIBRARY(SYS1.RESCUE.LINKLIB) MODULES( ICHRDSNT )"
call jcl stcent
call clsout pds,'ZIEALPA'
Say "Entry ICHRDSNT added to ZIEALPA MLPA model."

RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/
/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),RESCUE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
   IF r = "" THEN ITERATE
   INTERPRET q '= "'r'"'
END

/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */

RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
trace off
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
##stat = SYSDSN("'"##ds2"("##mem2")'")
IF ##stat /= 'OK' THEN DO
   RETURN ##stat
END
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
cc = rc
IF cc = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 'OK'
END
ELSE DO
   RETURN 'ALLOC ERROR' cc
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(output) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)
./ ADD NAME=#RFSTC   0100-02365-02365-1141-00639-00639-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* #RFSTC  - RACF Started Task Table (ICHRIN03)            */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

call varinit          /* Read @parms and @dataset.         */

IF rfstc /= 'YES' THEN DO
   Say "RFSTC parameter not specified - ICHRIN03 assembly not created."
   RETURN
END

call makestc          /* Build the STC table.              */
call iealpa           /* Build MLPA member to use ICHRIN03.*/
call defids           /* Create RACF groups/IDs as needed. */

exit

/*=========================================================*/
/* JOB: RACF Started Task Table (ICHRDSNT)                 */
/*=========================================================*/
makestc:
jobnum = ##jobchr()

Say "Building Job "jobnum": Assemble ICHRIN03 table."
call setout pds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "RFDSNT   - Assemble RACF Started Task Table (ICHRIN03)"
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//STEP1    EXEC ASMACL,PARM.C='OBJECT,NODECK',"
call jcl "// PARM.L='SIZE=(320K,250K)' "
call jcl "//C.SYSLIB DD  DSN=SYS1.MACLIB,DISP=SHR "
call jcl "//         DD  DSN=SYS1.MODGEN,DISP=SHR "
call jcl "//SYSIN    DD  * "
call jcl "ICHRIN03 CSECT                                               "
call jcl "TABSTART DC    AL2(NUMENTR)              NUMBER OF ENTRIES   "

privflag = "X'8000000000000000'"
stdflag  = "X'0000000000000000'"

/*------------------------------------------------------------------*/
/* Use STC's from @PARMS.  RFSTCx = VTAM, $RESCUE, $STC             */
/* p1 = Task name, p2 = RACF ID, p3 = RACF Grp.                     */
/*------------------------------------------------------------------*/
stc.0 = 0
DO xx = 1 TO 99
   IF VALUE("RFSTC"xx) = "RFSTC"xx THEN LEAVE
   ent = VALUE("RFSTC"xx)
   PARSE VAR ent zztask ',' zzid ',' zzgrp .
   zztask = strip(zztask,"B")
   zzid = strip(zzid,"B")
   zzgrp  = strip(zzgrp,"B")
   stc.xx = substr(zztask,1,8)""substr(zzid,1,8)""substr(zzgrp,1,8)
END
stc.0 = xx-1
/*------------------------------------------------------------------*/
/* Loop through the entries we've built, and put them in DC stmts.  */
/* Assume trusted and proviledged for all defined tasks.            */
/*------------------------------------------------------------------*/
DO xx = 1 TO stc.0
   call jcl "         DC    C'"stc.xx"',"privflag
END
/*------------------------------------------------------------------*/
/* Finish up the source for the table, and the rest of the JCL.     */
/*------------------------------------------------------------------*/
call jcl "         DC    C'*       =       STC     ',"stdflag
call jcl "NUMENTR  EQU   (*-TABSTART-2)/32+X'8000'"
call jcl "         DC    C'&SYSDATE' "
call jcl "         DC    C'&SYSTIME' "
call jcl "         END "
call jcl "//L.SYSLMOD     DD DSN=SYS1.RESCUE.LINKLIB,DISP=SHR,"
call jcl "//  UNIT=SYSALLDA,VOL=SER="volser
call jcl "//L.SYSIN       DD *"
call jcl "  NAME ICHRIN03(R) "

call clsout pds,'JOB'jobnum

RETURN

/*=========================================================*/
/* Create IEALPA member from ZIEALPA contents plus an      */
/* entry we'll build for ICHRIN03.                         */
/*=========================================================*/
iealpa:

/*---------------------------------------------------------*/
/* If no member found, set stem count to 0 for later, and  */
/* plan to write output to ZIEALPA.                        */
/*---------------------------------------------------------*/
stat = setinp(pds,'ZIEALPA')  /* Open member ZIEALPA for input. */
IF stat = 'MEMBER NOT FOUND' THEN DO
   SAY "Model MLPA member ZIEALPA not found, and will be created."
   INPUT.0 = 0
   outmem = 'ZIEALPA'
END
ELSE IF stat /= 'OK' THEN DO
   Say "Error opening ZIEALPA, exiting."
   RETURN
END

/*---------------------------------------------------------*/
/* If no member read, set stem count to 0 for later.       */
/*---------------------------------------------------------*/
IF INPUT.0 = "INPUT.0" THEN DO
   SAY "Model MLPA member ZIEALPA not found."
   INPUT.0 = 0
END

/*---------------------------------------------------------*/
/* If there's already an entry for this module, do nothing.*/
/*---------------------------------------------------------*/
DO xx = 1 TO INPUT.0
/* Parse out comments first. */
   PARSE VAR INPUT.xx p '/*'
   IF POS("ICHRIN03",p) > 0 THEN DO
      SAY "ICHRIN03 entry already in MLPA model - No entry added."
      call clsinp pds,'ZIEALPA'  /* Close input file. */
      RETURN
   END
END
/*---------------------------------------------------------*/
/* No entry found, so rebuild ZIEALPA with out mod added.  */
/*---------------------------------------------------------*/
call setout pds,'ZIEALPA'
DO xx = 1 TO INPUT.0
   call jcl INPUT.xx
END
stcent = "INCLUDE LIBRARY(SYS1.RESCUE.LINKLIB) MODULES( ICHRIN03 )"
call jcl stcent
call clsout pds,'ZIEALPA'
Say "Entry ICHRIN03 added to ZIEALPA MLPA model."

RETURN

/*=========================================================*/
/* JOB: Define RACF IDs needed for RESCUE system.          */
/* JOB: ID submitting job mist have RACF SPECIAL.          */
/*=========================================================*/
defids:

jobnum = ##jobchr()
Say "Building Job "jobnum": Define RACF IDs and Groups for STCs."
call setout pds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "RFSTCDEF - Create RACF IDs and groups for started tasks."
call jcd
/*---------------------------------------------------------*/
/* Be sure we have RACF special.                           */
/*---------------------------------------------------------*/
IF \racfspec() THEN DO
   call jcc "*** NOTE: ***"
   call jcc "Userid "USERID()" was used to build this job, but does "
   call jcc "not have the RACF SPECIAL attribute.  If "USERID()" is "
   call jcc "used to run this job, it should first be granted the   "
   call jcc "SPECIAL attribute or the equivalent specific privileges "
   call jcc "needed be to run successfully. RACF violations will  "
   call jcc "result if this is not done."
   call jcd
END
ELSE DO
   call jcc "NOTE: Be sure that the ID used to run this job has the"
   call jcc "RACF SPECIAL attribute, or the equivalent specific    "
   call jcc "privileges required."
   call jcd
END
call jcc mydate()" "comment
call jcd
call jcl "//TSO      EXEC PGM=IKJEFT01,REGION=4M"
call jcl "//SYSPRINT DD SYSOUT=*"
call jcl "//SYSIN    DD DUMMY   "
call jcl "//SYSTSPRT DD SYSOUT=*"
call jcl "//SYSTSIN  DD *"

/*------------------------------------------------------------------*/
/* Delete RACF IDs and Groups.                                      */
/*------------------------------------------------------------------*/
/* Use RFSTCx parms from @PARMS to get userids to be defined.       */
/* Delete each GROUP and ID first, but only if they are not already */
/* defined to the driving system.                                   */
/* jobs to be re-run if desired.                                    */
/*------------------------------------------------------------------*/
DO xx = 1 TO 99
   IF VALUE("RFSTC"xx) = "RFSTC"xx THEN LEAVE
   ent = VALUE("RFSTC"xx)
   ent = translate(ent,' ',',')
   PARSE VAR ent zztask zzid zzgrp .
   zztask = strip(zztask,"B"); zzid = strip(zzid,"B");
   zzgrp  = strip(zzgrp,"B")
   /* Delete ID if needed. */
   IF ckstcid(zzid) THEN DO
      c1 = " DELUSER  "zzid
      IF \idthere(zzid) THEN DO
         call jcl " "
         call jcl c1
      END
      ELSE DO
      /* Comment out the commands, because the ID was already there. */
         SAY zzid" is already defined to RACF, and was not deleted."
         call jcl " "
         e1  = " "zzid" is already defined to RACF, and was"
         e2  = " not deleted.  Select an ID that does not"
         e3  = " already exist, and change the RFSTC statements"
         e4  = " in the @PARMS member and rerun the rescue execs."
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(e1,1,60)" */"
         call jcl " /*"substr(e2,1,60)" */"
         call jcl " /*"substr(e3,1,60)" */"
         call jcl " /*"substr(e4,1,60)" */"
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(c1,1,60)" */"
      END
   END
END
DO xx = 1 TO 99
   IF VALUE("RFSTC"xx) = "RFSTC"xx THEN LEAVE
   ent = VALUE("RFSTC"xx)
   ent = translate(ent,' ',',')
   PARSE VAR ent zztask zzid zzgrp .
   zztask = strip(zztask,"B"); zzid = strip(zzid,"B");
   zzgrp  = strip(zzgrp,"B")
   /* Delete group if needed. */
   IF ckstcgrp(zzgrp) THEN DO
      c1 = " DELGROUP "zzgrp
      IF \grpthere(zzgrp) THEN DO
         call jcl " "
         call jcl c1
      END
      ELSE DO
         SAY zzgrp" is already defined to RACF, and was not deleted."
         call jcl " "
         e1  = " "zzgrp" is already defined to RACF, and was"
         e2  = " not deleted.  Select a Group that does not"
         e3  = " already exist, and change the RFSTC statements"
         e4  = " in the @PARMS member and rerun the rescue execs."
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(e1,1,60)" */"
         call jcl " /*"substr(e2,1,60)" */"
         call jcl " /*"substr(e3,1,60)" */"
         call jcl " /*"substr(e4,1,60)" */"
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(c1,1,60)" */"
      END
   END
END
DROP STCID.
DROP STCGRP.

/*------------------------------------------------------------------*/
/* Define RACF IDs and Groups.                                      */
/*------------------------------------------------------------------*/
/* Use RFSTCx parms from @PARMS to get userids to be defined.       */
/* Define each group and user as needed, but only if they are not   */
/* defined yet. Code a DELGROUP and DELUSER statement to allow the  */
/* jobs to be re-run if desired.                                    */
/*------------------------------------------------------------------*/
DO xx = 1 TO 99
   IF VALUE("RFSTC"xx) = "RFSTC"xx THEN LEAVE
   ent = VALUE("RFSTC"xx)
   ent = translate(ent,' ',',')
   PARSE VAR ent zztask zzid zzgrp .
   zztask = strip(zztask,"B"); zzid = strip(zzid,"B");
   zzgrp  = strip(zzgrp,"B")
   /* Define group if needed. */
   IF ckstcgrp(zzgrp) THEN DO
      c1 = " ADDGROUP "zzgrp" OWNER(SYS1) SUP(SYS1) +"
      c2 = " OMVS(gid(0))"
      IF \grpthere(zzgrp) THEN DO
         call jcl " "
         call jcl c1
         call jcl c2
      END
      ELSE DO
         SAY zzgrp" is already defined to RACF, and was not created."
         call jcl " "
         e1  = " "zzgrp" is already defined to RACF, and was"
         e2  = " not created.  Select a Group that does not"
         e3  = " already exist, and change the RFSTC statements"
         e4  = " in the @PARMS member and rerun the rescue execs."
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(e1,1,60)" */"
         call jcl " /*"substr(e2,1,60)" */"
         call jcl " /*"substr(e3,1,60)" */"
         call jcl " /*"substr(e4,1,60)" */"
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(c1,1,60)" */"
         call jcl " /*"substr(c2,1,60)" */"
      END
   END
END
DO xx = 1 TO 99
   IF VALUE("RFSTC"xx) = "RFSTC"xx THEN LEAVE
   ent = VALUE("RFSTC"xx)
   ent = translate(ent,' ',',')
   PARSE VAR ent zztask zzid zzgrp .
   zztask = strip(zztask,"B"); zzid = strip(zzid,"B");
   zzgrp  = strip(zzgrp,"B")
   /* Define ID if needed. */
   IF ckstcid(zzid) THEN DO
      c1 = " ADDUSER  "zzid" OWNER(SYS1) DFLTGRP("zzgrp") +"
      c2 = " OPERATIONS NOPASSWORD NAME('Rescue System') + "
      c3 = " OMVS(uid(0) home('/') program('/bin/sh') )"
      IF \idthere(zzid) THEN DO
         call jcl " "
         call jcl c1
         call jcl c2
         call jcl c3
      END
      ELSE DO
      /* Comment out the commands, because the ID was already there. */
         SAY zzid" is already defined to RACF, and was not created."
         call jcl " "
         e1  = " "zzid" is already defined to RACF, and was"
         e2  = " not created.  Select an ID that does not"
         e3  = " already exist, and change the RFSTC statements"
         e4  = " in the @PARMS member and rerun the rescue execs."
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(e1,1,60)" */"
         call jcl " /*"substr(e2,1,60)" */"
         call jcl " /*"substr(e3,1,60)" */"
         call jcl " /*"substr(e4,1,60)" */"
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(c1,1,60)" */"
         call jcl " /*"substr(c1,1,60)" */"
         call jcl " /*"substr(c2,1,60)" */"
         call jcl " /*"substr(c3,1,60)" */"
      END
   END
END

/*-------------------------------------------*/
/*- Define the TSO PROC to RACF             -*/
/*-------------------------------------------*/
call jcl " "
call jcl " RDEFINE TSOPROC "tsoproc" UACC(READ)"
call jcl " RALTER  TSOPROC "tsoproc" UACC(READ)"
call jcl " SETROPTS RACLIST(TSOPROC) REFRESH"
call jcl " "

call clsout pds,'JOB'jobnum

RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
/*-ckstcid - Check if we need to process     */
/*-this stc id.  If not, return 0.  If so,   */
/*-return 1.                                 */
/*-------------------------------------------*/
ckstcid:
ARG ##id
IF STCID.0 = "STCID.0" THEN stcid.0 = 0
DO ##x = 1 TO stcid.0
   IF ##id = stcid.##x THEN RETURN 0
END
##x34 = stcid.0
##x34 = ##x34 + 1
stcid.0 = ##x34
stcid.##x34 = ##id
RETURN 1

ckstcgrp:
ARG ##grp
IF STCGRP.0 = "STCGRP.0" THEN stcgrp.0 = 0
DO ##x = 1 TO stcgrp.0
   IF ##grp = stcgrp.##x THEN RETURN 0
END
##x34 = stcgrp.0
##x34 = ##x34 + 1
stcgrp.0 = ##x34
stcgrp.##x34 = ##grp
RETURN 1

/*---------------------------------------------------------*/
/* idisthere  - Says if a RACF ID is defined.              */
/* grpisthere - Says if a RACF ID is defined.              */
/*---------------------------------------------------------*/
idthere:
ARG ##id
x = outtrap('list.',1)
"LU "##id
 cc = rc
x = outtrap('OFF')
RETURN (cc = 0)

grpthere:
ARG ##grp
x = outtrap('list.',1)
"LG "##grp
 cc = rc
x = outtrap('OFF')
RETURN (cc = 0)

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),RESCUE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
   IF r = "" THEN ITERATE
   INTERPRET q '= "'r'"'
END

/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */

RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
trace off
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
##stat = SYSDSN("'"##ds2"("##mem2")'")
IF ##stat /= 'OK' THEN DO
   RETURN ##stat
END
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
cc = rc
IF cc = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 'OK'
END
ELSE DO
   RETURN 'ALLOC ERROR' cc
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(output) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)


/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0
./ ADD NAME=@DATASET 0100-02365-02365-1141-00234-00234-00000-JMILLER
*--------------------------------------------------------------------*
*  Dataset Definitions:                                              *
*--------------------------------------------------------------------*
*  Parms for dataset entries are as follows:                         *
*  uuu,pppp,sss,ddd,m,dsn1,dsn2,(parms)                              *
*  ------------------------------                                    *
*  uuu   - Allocation unit, such as CYL,TRK, etc. (copy mode C,G,N)  *
*  pppp  - Primary allocation (copy mode C,G,N)                      *
*  sss   - Secondary allocation (copy mode C,G,N)                    *
*  dir   - Directory blocks (copy mode C,G,N)                        *
*  m     - Method of copy:                                           *
*          C - IEBCOPY                                               *
*          D - DFDSS                                                 *
*          G - IEBGENER                                              *
*          H - HFS file copy via DFDSS DUMP & RESTORE (See notes in  *
*              $$$MAINT member about maintenance needed for this.)   *
*          N - No copy, allocate only                                *
*          X - Do nothing, used as a flag for internal processing.   *
*  dsn1  - Name of dataset to be copied or defined.  If copy mode    *
*          "N" is specified, this dataset is not copied, but used    *
*          only as a model for allocating the dataset.               *
*  dsn2  - Name of dataset on the target system, if it is to be      *
*          different from dsn1.  If this parameter is omitted, the   *
*          the dataset will be named to the value specified in dsn1. *
*  parms - Flags to indicate special handling:                       *
*          OMVSxxxx  - BPXPRMxx member will mount this file at mount *
*                    - point xxxx. e.g. OMVS/etc.  OMVS/ will define *
*                    - the ROOT filesystem, and generate a ROOT stmt.*
*          APF       - Added to PROGA0 for APF authorization.        *
*          LNK       - Added to PROGL0 for linklst.                  *
*          LPA       - Added to LPALST00 PARMLIB member.             *
*          RLSE      - Excess space released after copy.  This helps *
*                      fit the system into minimum space.            *
*          ISPxLIB   - Lib added to ISPxLIB DD in TSO PROC.          *
*          SYSPROC   - Lib added to SYSPROC DD in TSO PROC.          *
*          SYSHELP   - Lib added to SYSHELP DD in TSO PROC.          *
*          SYSLBC    - Lib added to SYSLBC DD in TSO PROC.           *
*          JES2      - Lib added to PROC00 DD in JES2 PROC.          *
*          VTAMLST   - Lib added to VTAMLST DD in VTAM PROC.         *
*          VTAMLIB   - Lib added to VTAMLIB DD in VTAM PROC.         *
*          IPLPARM   - Lib where LOAD00 member will be created.      *
*          PARMLIB   - PARMLIB to be added to SYS1.IPLAPRM(LOAD00).  *
*--------------------------------------------------------------------*
*  Parms for member COPY operations are as follows:                  *
*  The source and target PDS libraries must be specified before any  *
*  member copy statements are coded.  First code a COPY with IN=     *
*                                                                    *
*  First code a COPY with IN= and OUT= parms:                        *
*  and OUT= parms:                                                   *
*     COPY IN=<source PDS>,OUT=<Target PDS>                          *
*  Then code one or more COPY member statments, as below:            *
*     COPY M=memname                                                 *
*     COPY M=(memname)                                               *
*     COPY M=(memname,newmemname)                                    *
*                                                                    *
*  Each COPY member statement uses the IN= and OUT= libraries set in *
*  the preceeding COPY IN=,OUT= statement.                           *
*                                                                    *
*  An IEBCOPY job will be created that copies the members defined in *
*  all the COPY statements.                                          *
*--------------------------------------------------------------------*
*--------------------------------------------------------------------*
*  REQUIRED - DON'T ALTER THE NEXT SET OF ENTRIES FROM HERE UNTIL    *
*     |       THE NEXT COMMENT BLOCK. THESE ARE BASIC PARTS OF THE   *
*     |       RESCUE SYSTEM BUILD PROCESS, AND THE EXEC MAY BREAK IF *
*     V       THESE STATEMENTS ARE ALTERED.                          *
*--------------------------------------------------------------------*
 CYL,0001,000,015,N,SYS1.IPLPARM,,(IPLPARM)
 CYL,0001,000,015,N,SYS1.PARMLIB,SYS1.RESCUE.CLIST,(SYSPROC)
 CYL,0002,000,015,N,SYS1.PARMLIB,SYS1.RESCUE.PARMLIB,(PARMLIB)
 CYL,0002,000,025,N,SYS1.LINKLIB,SYS1.RESCUE.LINKLIB,(APF,LNK)
 CYL,0002,000,015,N,SYS1.PROCLIB,SYS1.RESCUE.PROCLIB,(JES2)
 COPY IN=&RESCUE,OUT=SYS1.RESCUE.CLIST
    COPY M=(ZISPALOC,ISPALLOC)
 COPY IN=&RESCUE,OUT=SYS1.RESCUE.PARMLIB
    COPY M=(BPXPRM00)
    COPY M=(JES2PARM)
    COPY M=(MSTJCL01)
    COPY M=(LPALST00)
    COPY M=(PROGA0)
    COPY M=(PROGL0)
    COPY M=(ZCOMMND,COMMND00)
    COPY M=(ZIEALPA,IEALPA00)
    COPY M=(ZIEASYS,IEASYS00)
    COPY M=(ZIEFSSN,IEFSSN00)
    COPY M=(IGDSMS00)
    COPY M=(ZTSOKEY,TSOKEY00)
    COPY M=(ZVATLST,VATLST00)
 COPY IN=&RESCUE,OUT=SYS1.RESCUE.PROCLIB
    COPY M=(ZTSO,TSO)
    COPY M=(VTAM)
    COPY M=(JES2)
    COPY M=(&TSOPROC)
 COPY IN=&RESCUE,OUT=SYS1.IPLPARM
    COPY M=LOAD00
*--------------------------------------------------------------------*
*  END OF REQUIRED STATEMENTS.                                       *
*--------------------------------------------------------------------*
*--------------------------------------------------------------------*
*  OMVS Datasets:                                                    *
*--------------------------------------------------------------------*
 OMVS,,,,H,OMVS.ROOT.MAINT,OMVS.ROOT,(OMVS/)
 OMVS,,,,H,OMVS.ETC,,(OMVS/etc)
*--------------------------------------------------------------------*
*  MVS Datasets:                                                     *
*--------------------------------------------------------------------*
 CYL,0000,000,000,D,SYS1.IODF00.CLUSTER
 CYL,0000,000,000,D,SMS.ACDS,,(ACDS)
 CYL,0000,000,000,D,SMS.SCDS
 CYL,0000,000,000,D,SMS.COMMDS,,(COMMDS)
 CYL,0000,000,000,D,SMS.ACS
 CYL,0000,000,000,D,SYS1.LINKLIB,,(RLSE,APF,LNK)
 CYL,0010,001,025,D,SYS1.V2R10M0.SHASLINK,,(RLSE,LNK,APF)
 CYL,0010,001,025,D,SYS1.V2R10M0.SHASMIG,,(RLSE,LNK,APF)
 CYL,0090,000,550,D,SYS1.LPALIB,,(RLSE)
 CYL,0140,005,350,D,SYS1.MACLIB,,(RLSE)
 CYL,0020,001,250,D,SYS1.MIGLIB,,(RLSE,APF)
 CYL,0055,000,250,D,SYS1.NUCLEUS
 CYL,0002,000,050,D,SYS1.PARMLIB,,(PARMLIB)
 CYL,0002,000,050,D,SYS1.IBM.PARMLIB,,(PARMLIB)
 CYL,0002,001,150,D,SYS1.PROCLIB,,(JES2)
 CYL,0002,001,150,D,CPAC.PROCLIB,,(JES2)
 CYL,0002,001,150,D,SYS1.IBM.PROCLIB,,(JES2)
 CYL,0050,001,250,D,SYS1.SAMPLIB,,(RLSE)
 CYL,0002,001,150,D,SYS1.SVCLIB,,(RLSE)
 CYL,0002,001,150,D,SYS1.UADS,,(SYSUADS)
 CYL,0003,000,000,D,SYS1.BRODCAST,,(SYSLBC)
 CYL,0024,000,000,N,SYS1.HASPCKPT
 CYL,0060,000,000,N,SYS1.HASPACE
 CYL,0010,000,000,N,SYS1.LOGREC,,(LOGREC)
 CYL,0020,000,000,X,SYS1.MAN1,,(SMF)
 CYL,0010,000,000,X,SYS1.MAN2,,(SMF)
 CYL,0010,000,000,X,SYS1.MAN3,,(SMF)
 CYL,0060,000,000,N,SYS1.DUMP00,,(DUMP)
 CYL,0060,000,000,N,SYS1.DUMP01,,(DUMP)
 CYL,0005,001,150,D,SYS1.CSSLIB,,(RLSE,LNK)
 CYL,0000,000,000,D,EOY.SEOYLOAD,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,EOX.SEPHLOD1,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,GIM.SGIMLMD0,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,CEE.SCEERUN,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,CEE.SCEERUN2,,(LNK,APF)
 CYL,0000,000,000,D,IMO.SIMOMOD1,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,ISP.SISPSASC,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,FFST.V120ESA.SEPWMOD2,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,FFST.V120ESA.SEPWMOD4,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,SYS1.SICELINK,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,SYS1.SORTLIB,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,IOE.SIOELMOD,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,SYS1.SIOALMOD,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,CBC.SCLBDLL,,(RLSE,LNK,APF)
 CYL,0030,000,050,D,SYS1.SERBLINK,,(RLSE,LNK,APF)
 CYL,0010,000,010,D,CEE.SCEELPA,,(RLSE,LNK,APF,LPA)
 CYL,0001,000,005,D,SYS1.SERBLPA,,(RLSE,LPA)
 CYL,0005,000,150,D,SYS1.CMDLIB,,(RLSE,LNK)
 CYL,0001,000,000,D,SYS1.DAE
 CYL,0008,001,150,D,SYS1.HELP,,(RLSE,SYSHELP)
 CYL,0002,000,150,D,SYS1.IMAGELIB,,(RLSE)
*--------------------------------------------------------------------*
* HCD ISPF libraries                                                 *
*--------------------------------------------------------------------*
 CYL,0000,000,000,D,SYS1.SCBDHENU,,(RLSE,LNK,APF)
 CYL,0000,000,000,D,SYS1.SCBDCLST,,(RLSE,SYSPROC)
 CYL,0000,000,000,D,SYS1.SCBDMENU,,(RLSE,ISPMLIB)
 CYL,0000,000,000,D,SYS1.SCBDPENU,,(RLSE,ISPPLIB)
 CYL,0000,000,000,D,SYS1.SCBDTENU,,(RLSE,ISPTLIB)
*--------------------------------------------------------------------*
* ISPF Libraries                                                     *
*--------------------------------------------------------------------*
 CYL,0001,0001,125,D,ISP.SISPTENU,,(RLSE,ISPTLIB)
 CYL,0002,0001,125,D,ISP.SISPSLIB,,(RLSE,ISPSLIB)
 CYL,0003,0001,150,D,ISP.SISPMENU,,(RLSE,ISPMLIB)
 CYL,0006,0001,125,D,ISP.SISPSENU,,(RLSE,ISPSLIB)
 CYL,0008,0001,075,D,ISP.SISPLOAD,,(RLSE,LNK,ISPLLIB)
 CYL,0025,0001,200,D,ISP.SISPPENU,,(RLSE,ISPPLIB)
 CYL,0025,0001,200,D,ISP.SISPCLIB,,(RLSE,SYSPROC)
 CYL,0035,0001,075,D,ISP.SISPLPA,,(RLSE,LPA)
*--------------------------------------------------------------------*
* TCPIP datasets                                                     *
*--------------------------------------------------------------------*
 CYL,0030,000,010,D,TCPIP.SEZALPA,,(RLSE,APF,LPA)
 CYL,0060,005,010,D,TCPIP.SEZALINK,,(RLSE,APF,LNK)
 CYL,0060,005,010,D,SYS1.TCPPARMS
 CYL,0060,005,010,D,TCPIP.SEZATCP,,(RLSE)
 CYL,0060,005,010,D,TCPIP.SEZAINST,,(LNK)
 CYL,0060,005,010,D,TCPIP.SMTPNJE.HOSTINFO
 CYL,0060,005,010,D,TCPIP.SECTABLE
*--------------------------------------------------------------------*
* RACF DATASET AND ISPF LIBRARIES                                    *
*--------------------------------------------------------------------*
*  The RACF dataset is copied automatically.  Don't specify it here. *
 CYL,0002,001,150,D,SYS1.HRFCLST,,(RLSE,SYSPROC)
 CYL,0002,001,150,D,SYS1.HRFMSG,,(RLSE,ISPMLIB)
 CYL,0002,001,150,D,SYS1.HRFPANL,,(RLSE,ISPPLIB)
 CYL,0002,001,150,D,SYS1.HRFSKEL,,(RLSE,ISPSLIB)
*--------------------------------------------------------------------*
* ISMF ISPF libraries                                                *
*--------------------------------------------------------------------*
 CYL,0001,001,095,D,SYS1.DGTCLIB,,(RLSE,SYSPROC)
 CYL,0010,001,095,D,SYS1.DGTLLIB,,(RLSE,ISPLLIB)
 CYL,0002,001,095,D,SYS1.DGTMLIB,,(RLSE,ISPMLIB)
 CYL,0033,001,350,D,SYS1.DGTPLIB,,(RLSE,ISPPLIB)
 CYL,0002,001,095,D,SYS1.DGTSLIB,,(RLSE,ISPSLIB)
 CYL,0001,001,095,D,SYS1.DGTTLIB,,(RLSE,ISPTLIB)
*--------------------------------------------------------------------*
* SDSF Datasets                                                      *
*--------------------------------------------------------------------*
 CYL,0001,000,000,N,ISF.HASPINDX
 CYL,0001,001,150,D,ISF.SISFLINK,,(RLSE,LNK)
 CYL,0005,001,050,D,ISF.SISFLOAD,,(RLSE,LNK)
 CYL,0001,001,025,D,ISF.SISFLPA,,(RLSE,LPA)
 CYL,0001,001,150,D,ISF.SISFMLIB,,(RLSE,ISPMLIB)
 CYL,0002,001,150,D,ISF.SISFPLIB,,(RLSE,ISPPLIB)
 CYL,0001,001,150,D,ISF.SISFTLIB,,(RLSE,ISPTLIB)
 CYL,0001,001,150,D,ISF.SISFSLIB,,(RLSE,ISPSLIB)
 CYL,0015,001,150,D,ISF.SISFSRC,,(RLSE)
*--------------------------------------------------------------------*
* VTAM / NCP DATASETS                                                *
*--------------------------------------------------------------------*
 CYL,0005,0001,125,D,SYS1.VTAMLST,,(VTAMLST)
 CYL,0005,0001,125,D,SYS1.VTAMLIB,,(RLSE,VTAMLIB,APF)
 CYL,0050,0001,125,D,SYS1.SISTCLIB,,(RLSE,APF)
*--------------------------------------------------------------------*
* Local datasets - Assorted PDS's that you want on your rescue sys.  *
*--------------------------------------------------------------------*
*CYL,0000,0000,000,D,SYS5.HELP,,(SYSHELP)
*CYL,0000,0000,000,D,SYS5.TSSO.LOAD,,(APF,LNK)
*CYL,0000,0000,000,D,SYS5.TSSO.CLIST
*CYL,0000,0000,000,D,SYS5.TSSO.AOFTABS
*CYL,0000,0000,000,D,SYS2.LINKLIB,,(APF,LNK)
*CYL,0000,0000,000,D,SYS2.CSL86.LINKLIB,,(APF,LNK)
*CYL,0000,0000,000,D,AOSGJCM.CNTL
*CYL,0000,0000,000,D,AOSGJCM.VM.CNTL
*CYL,0000,0000,000,D,AOSGJCM.EXEC
*CYL,0000,0000,000,D,AOSGJCM.CLIST
./ ADD NAME=@PARMS   0100-02365-02365-1141-00095-00095-00000-JMILLER
/*-------------------------------------------------------------------*
/*  Rescue system parameters.                                        *
/*  To assign parms, use statements like: PARM1  = Some Value        *
/*-------------------------------------------------------------------*
/*  03/10/2001 John C. Miller.                                       *
/*-------------------------------------------------------------------*
/*-------------------------------------------------------------------*
/* Jobcard info.  "COMMENT" is placed in each job.                   *
/* Jobname must be 7 chars or less to allow job char to be added.    *
/*-------------------------------------------------------------------*
 JOBCARD1   = //AOSGJCM  JOB (0),RESCUE,MSGCLASS=X,CLASS=A,
 JOBCARD2   = //  NOTIFY=&SYSUID,REGION=6M TYPRUN=HOLD
 JOBCARD3   = /*JOBPARM L=9999
 COMMENT    = John C. Miller

/*-------------------------------------------------------------------*
/* TSO PROC and Userids to be created on the new system.             *
/* TSOPROC should NOT exist on the driving system.                   *
/*-------------------------------------------------------------------*
 TSOPROC    = TSORES                  /* TSOPROC to be built.
 TSOID1     = AOSGJCM                 /* TSO IDs to be defined on the
 TSOID2     = XJMILLR                 /* rescue system.
 TSOID3     = XKFT

/*-------------------------------------------------------------------*
/* Assorted other parms.                                             *
/*-------------------------------------------------------------------*
 ADDR       = F66                     /* Unit addr of RESCUE volume.
 DEVTYPE    = 3390                    /* Unit of RESCUE volume.
 VOLSER     = RESCUE                  /* VOLSER of RESCUE volume.

 SSA        = SYSX.                   /* Temp. dsn prefix used to
                                      /* avoid ENQ problems.
/*-------------------------------------------------------------------*
/* WORKVOL - Not needed if you have plenty of PUBLIC mounted disk.   *
/*-------------------------------------------------------------------*
 WORKVOL    = RESCU2                  /* Volser for large work files.

/*-------------------------------------------------------------------*
/* IOCONFIGID - Use HCD to be sure this value is defined as a valid  *
/* IOCONFIG ID in the IODF dataset that you specify.                 *
/*-------------------------------------------------------------------*
 IODF       = SYS1.IODF00.CLUSTER     /* IODF dataset name.
 IOCONFIGID = CSUT                    /* 8 char IO config ID for LOADxx

 SMFID      = CSUT                    /* 4 char SMF id for new system.
 NEWMCAT    = CATALOG.RESCUE          /* Rescue sys. mastercat name.
 OLDMCAT    = CATALOG.OS390J.MASTER   /* Driving sys master cat.
 SYSRES     = JRS001                  /* Driving sys sysres volume.
 COMMANDPGM = COMMAND                 /* "COMMAND" pgm is available.
 WAITPGM    = WAIT                    /* "WAIT" pgm is available.

/*-------------------------------------------------------------------*
/* JES2 Parms.  A SPOOLDEF and CKPTDEF entry will be added to the    *
/* ZJES2PRM member to create a final JES2PARM member.                *
/*-------------------------------------------------------------------*
 SPOOLVOL   = RESC                    /* SPOOLDEF prefix.
 CHKPOINT   = SYS1.HASPCKPT           /* JES2 Ckpt dataset name.
 SPOOL      = SYS1.HASPACE            /* JES2 spool ds name.

/*-------------------------------------------------------------------*
/* RACF Parms.                                                       *
/* Note: Some of the RACF actions require RACF SPECIAL to perform.   *
/* Any TSO ID can run the RESCUE execs, but the RACF ID used to run  *
/* the resulting jobs will need RACF SPECIAL, or specific privileges *
/* for various RACF operations (CLAUTH, etc.)                        *
/*-------------------------------------------------------------------*
/*-------------------------------------------------------------------*
/* RFSTCx: Defines STCs for ICHRIN03 started task table.             *
/* p1 = Task name, p2 = RACF ID, p3 = RACF group.                    *
/* Each task defined will have privileged bit set on, so these tasks *
/* should be able to bypass most RACF Access checking.  Commands     *
/* for creating the specified IDs and Groups will be generated only  *
/* if the IDs/groups DO NOT already exist.                           *
/*-------------------------------------------------------------------*
 RACFDS     = SYS1.RACFP1             /* Driving system RF ds and vol.
 RACFVOL    =                         /* "
 RFDSNT     = YES                     /* Create RACF ICHRDSNT
 RFSTC      = YES                     /* Create RACF ICHRIN03
 RFTSOPROC  = YES                     /* Define TSOPROC to TSOPROC class
/*-------------------------------------------------------------------*
/* Started task support:                                             *
/* If entries are defined below, then an ICHRIN03 module will be     *
/* built with these entries.  An MLPA entry fir this ICHRIN03        *
/* will be placed in IEALPA00.  Format of RFSTCx is:                 *
/* RFSTCx = stcname, racfid, racfgrp                                 *
/* All three parameters are required.                                *
/*-------------------------------------------------------------------*
 RFSTC1     = RACF,    $RESCUE, $STC  /* STCs to go in ICHRIN03
 RFSTC2     = JES2,    $RESCUE, $STC  /* STCs to go in ICHRIN03
 RFSTC3     = JES2BACK,$RESCUE, $STC  /* STCs to go in ICHRIN03
 RFSTC4     = VTAM,    $RESCUE, $STC  /* STCs to go in ICHRIN03
 RFSTC5     = TSO,     $RESCUE, $STC  /* STCs to go in ICHRIN03
 RFSTC6     = TCPIP,   $RESCUE, $STC  /* STCs to go in ICHRIN03
 RFSTC7     = OMVS,    $RESCUE, $STC  /* STCs to go in ICHRIN03
./ ADD NAME=COMMAND  0100-02365-02365-1141-00401-00401-00000-JMILLER
//EGTLJCMA JOB (0),JMILLER,MSGCLASS=X,CLASS=A,NOTIFY=EGTLJCM,REGION=6M
//ASMHCL   EXEC  ASMACL,PARM.L='MAP,LET,LIST,NCAL,AC=1'
//C.SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//           DD  DSN=SYS1.AMODGEN,DISP=SHR
//C.SYSIN    DD  *
COMMAND  TITLE 'C O M M A N D  --  ISSUE SYSTEM OPERATOR COMMANDS V2.0'
***********************************************************************
*                                                                     *
*                           C O M M A N D                             *
*                                                                     *
*                   ISSUE SYSTEM OPERATOR COMMANDS                    *
*                                                                     *
***********************************************************************
*                                                                     *
* NOTE: This version has RACHECK code added to be sure that the       *
* caller has at least READ access to the COMMAND profile of the       *
* APPL RACF class.  To permit use of the COMMAND command:             *
*                                                                     *
*    RDEFINE APPL COMMAND UACC(NONE)                                  *
*    PERMIT  COMMAND CLASS(APPL) ID(userid)                           *
*                                                                     *
* 03/21/2001 John C. Miller                                           *
***********************************************************************
*                                                                     *
*     THIS PROGRAM ACCEPTS SYSTEM OR JES OPERATOR COMMANDS AS         *
*     INPUT AND EXECUTES THEM USING SVC 34. IT MUST BE APF            *
*     AUTHORIZED.                                                     *
*                                                                     *
*     COMMAND CAN OPERATE IN ONE OF THREE MODES:                      *
*                                                                     *
*     1) BATCH OR CALLED PROGRAM                                      *
*        IN THIS MODE COMMAND ACCEPTS INPUT AS EITHER 80-BYTE         *
*        CARD IMAGES FROM SYSIN OR A SINGLE COMMAND FROM THE PARM     *
*        FIELD. THE RESPONSE TO THE OPERATOR COMMAND WILL             *
*        APPEAR ON ALL OPERATOR CONSOLES. FOR EXAMPLE:                *
*                                                                     *
*           //STEP1    EXEC PGM=COMMAND,PARM='VARY 017,ONLINE'        *
*                                                                     *
*           - OR -                                                    *
*                                                                     *
*           //STEP1    EXEC PGM=COMMAND                               *
*           //SYSIN    DD *                                           *
*           VARY 017,ONLINE                                           *
*           /*                                                        *
*                                                                     *
*        IF COMMANDS ARE FETCHED FROM SYSIN, A DELAY OF 2 SECONDS     *
*        WILL BE ADDED BETWEEN COMMANDS.                              *
*                                                                     *
*     2) TSO COMMAND PROCESSOR                                        *
*        IN THIS MODE COMMAND EXPECTS TO FIND THE OPERATOR COMMAND    *
*        DIRECTLY FOLLOWING ON THE TSO INPUT LINE. THE RESPONSE TO    *
*        OS COMMANDS WILL THEN BE DISPLAYED ON THE TSO TERMINAL.      *
*        RESPONSE TO JES COMMANDS WILL APPEAR ON YOUR TERMINAL        *
*        PROVIDED A LOCAL MODIFICATION IS MADE TO JES2 TO ALLOW       *
*        IT TO INTERCEPT THE COMMAND AND SET THE RESPONSE TO TSO.     *
*        OTHERWISE, JES2 COMMANDS WILL APPEAR ON ALL CONSOLES.        *
*        FOR EXAMPLE:                                                 *
*                                                                     *
*           COMMAND D T         <--- (RESPONSE WILL APPEAR ON CRT)    *
*                                                                     *
*     3) CALLABLE SUBROUTINE                                          *
*        IN THIS MODE COMMAND ACCEPTS INPUT ACCORDING TO STANDARD     *
*        OS LINKAGE CONVENTIONS. IN ADDITION TO THE COMMAND ITSELF,   *
*        A SECOND PARAMETER MAY BE PASSED WHICH CONTAINS THE          *
*        CONSOLE NUMBER WHERE YOU WISH THE RESPONSE TO APPEAR.        *
*        (THE SVC 34 WILL ALSO ASSUME THE AUTHORITY OF THAT           *
*        CONSOLE.) FOR EXAMPLE:                                       *
*                                                                     *
*           LA       R1,CMDADDR                                       *
*           LA       R15,=V(COMMAND)                                  *
*           BALR     R14,R15                                          *
*                                                                     *
*           CMDADDR  DC    A(OPERCMD)                                 *
*           CNSADDR  DC    XL1'80',AL3(CONSOLE)                       *
*           OPERCMD  DC    H(3),CL3'D T'                              *
*           CONSOLE  DC    F'5'                                       *
*                                                                     *
*        THIS WOULD MAKE IT APPEAR AS IF 'D T' WERE ISSUED FROM       *
*        CONSOLE 5. (THIS METHOD IS USED BY PROGRAM 'SPY')            *
*                                                                     *
*        COMMAND MAY BE USED TO ISSUE REPLIES TO WTORS.               *
*                                                                     *
*     AUTHOR:                                                         *
*       THE ORIGINAL VERSION OF COMMAND WAS WRITTEN BY MARK SORKIN.   *
*       THE CURRENT VERSION HAS BEEN HEAVILY MODIFIED AT SCE.         *
*       QUESTIONS AND COMMENTS MAY BE SENT TO                         *
*                                                                     *
*          STEVE LANGLEY                                              *
*          SOUTHERN CALIFORNIA EDISON                                 *
*          P.O. BOX 800                                               *
*          ROSEMEAD, CALIF. 91770                                     *
*          1-213-572-3435                                             *
*                                                                     *
*     IMPLEMENTOR:                                          *HMD 07/81*
*       THIS PROGRAM HAS BEEN REVISED AND IMPLEMENTED AT    *HMD 07/81*
*       GTE DATA SERVICES, MARINA DEL REY, CA BY:           *HMD 07/81*
*                                                           *HMD 07/81*
*          HOWARD M. DEAN                                   *HMD 07/81*
*          GTE DATA SERVICES                                *HMD 07/81*
*          4750 LINCOLN BLVD.                               *HMD 07/81*
*          MARINA DEL REY, CALIF. 90291                     *HMD 07/81*
*          PHONE - (213) - 821-0511                         *HMD 07/81*
*                                                           *HMD 07/81*
*       CHANGES MADE BY THE ABOVE ARE MARKED WITH           *HMD 07/81*
*       '*HMD XX/XX*' IN COL 61-71. XX/XX IS THE            *HMD 07/81*
*       CHANGE DATE (MONTH AND YEAR).                       *HMD 07/81*
***********************************************************************
         EJECT
COMMAND  CSECT
         SPACE 3
R0       EQU   0                  REGISTER 0
R1       EQU   1                  REGISTER 1
R2       EQU   2                  WORK REGISTER
R3       EQU   3                  WORK REGISTER
R4       EQU   4                  WORK REGISTER
R5       EQU   5                  WORK REGISTER
R6       EQU   6                  WORK REGISTER             *HMD 07/81*
R7       EQU   7                  WORK REGISTER             *HMD 07/81*
R8       EQU   8                  WORK REGISTER             *HMD 07/81*
R9       EQU   9                  WORK REGISTER             *HMD 07/81*
R10      EQU   10                 PARAMETER LIST ADDRESS REGISTER
R11      EQU   11                 SUBROUTINE LINKAGE REGISTER
R12      EQU   12                 BASE REGISTER
R13      EQU   13                 SAVE AREA ADDRESS REGISTER
R14      EQU   14                 REGISTER 14
R15      EQU   15                 REGISTER 15
         EJECT
         SAVE  (14,12)            SAVE CALLER'S REGISTERS
         LR    R12,R15            ESTABLISH
         USING COMMAND,R12        ADDRESSABILITY
         LA    R3,SAVEAREA        GET OUR SAVEAREA ADDRESS
         ST    R13,SAVEAREA+4     ESTABLISH BACK
         ST    R3,8(R13)          AND FORWARD SAVEAREA POINTERS
         LR    R13,R3             ESTABLISH OUR SAVEAREA ADDRESS
         LR    R10,R1             SAVE PARAMETER REGISTER
         SPACE 2
*********************************************************** *CKO 07/92*
* Determine whether user is authorized to the application   *CKO 07/92*
*********************************************************** *CKO 07/92*
RACHK    EQU  *                                             *CKO 07/92*
         RACHECK ENTITY=(CMDENT),CLASS=CMDCLS,ATTR=READ     *CKO 07/92*
         LTR  R15,R15             Authorized to this prog?  *CKO 07/92*
         BNZ  NOTAUTH             Nope.                     *CKO 07/92*
         SPACE 2                                            *CKO 07/92*
         L     R2,CVTPTR          R2 = ADDR OF CVT
         USING CVT,R2
         L     R3,CVTTCBP         R3 = ADDR OF MAGIC QUADWORD
         L     R4,12(R3)          R4 = ADDR OF OUR ASCB
         USING ASCB,R4
         MVC   ASID,ASCBASID      SAVE OUR ASID
         DROP  R4
         L     R4,CVTCUCB         ADDR OF 'CUCB' (UCM BASE) *HMD 07/81*
         DROP  R2                 NO NEED FOR CVT BASE NOW  *HMD 07/81*
         USING UCM,R4             ADDRESS THE UCM           *HMD 07/81*
         LR    R2,R4              R2 = R4                   *HMD 07/81*
         S     R2,=F'4'           R2 = ADDR OF ADDR OF UCMP *HMD 07/81*
         L     R2,0(R2)           R2 = ADDR OF UCM PREFIX   *HMD 07/81*
         USING UCMPRFX,R2         ADDRESS THE PREFIX        *HMD 07/81*
         L     R5,UCMVEA          R5 = ADDR OF 1ST UCM ENTRY*HMD 07/81*
         L     R6,UCMVEZ          R6 = LNGTH OF EACH ENTRY  *HMD 07/81*
         L     R7,UCMVEL          R7 = ADDR OF LAST UCM ENT.*HMD 07/81*
         SLR   R8,R8              R8 = CONSOLE COUNTER      *HMD 07/81*
UCMLOOP  LA    R8,1(R8)           R8 = CONSOLE NUMBER       *HMD 07/81*
         C     R5,UCMMCENT        IS THIS THE MASTER CON    *HMD 07/81*
         BNE   UCMNEXT            NO, CONTINUE LOOKING      *HMD 07/81*
         ST    R8,R0MASK          SAVE MSTR CONSOLE NUMBER  *HMD 07/81*
         B     INITDONE           DONE WITH THIS NOW        *HMD 07/81*
UCMNEXT  AR    R5,R6              BUMP TO NEXT UCM ENTRY    *HMD 07/81*
         CR    R5,R7              END OF UCM'S?             *HMD 07/81*
         BL    UCMLOOP            NO, CONTINUE              *HMD 07/81*
         DROP  R2,R4              GET RID OF BASES          *HMD 07/81*
         SPACE 3
INITDONE DS    0H                 CHECK OUT INPUT PARM
         MVI   CARD,C' '          CLEAR OUT COMMAND AREA    *HMD 07/81*
         MVC   CARD+1(L'CARD-1),CARD                        *HMD 07/81*
         TM    0(R10),X'80'       IS FIRST THE ONLY PARM?
         BO    ONEPARM            YES; ONLY PARM
         TM    4(R10),X'80'       IS SECOND THE LAST PARM?
         BO    TWOPARMS           YES; TWO PARMS (CALLED WITH CNXX)
***********************************************************************
*                                                                     *
*     A X'80' WAS NOT FOUND IN THE HIGH ORDER BYTE OF THE FIRST       *
*     TWO PARMS, SO WE CAN ASSUME COMMAND IS BEING CALLED AS A CP.    *
*     PLACE OUR ASID IN THE R0 MASK AND CONTINUE.                     *
*                                                                     *
***********************************************************************
         XR    R2,R2              CLEAR R2
         ICM   R2,B'0011',ASID    R2 = ASID OF CALLER
         O     R2,=XL4'00008000'  TELL SVC34 ITS AN ASID
         ST    R2,R0MASK          AND OVERRIDE THE R0 MASK
         L     R3,0(R10)          R3 = ADDR OF INPUT LINE
         LA    R4,4(R3)           R4 = ADDR OF FIRST CHAR OF INPUT
         AH    R4,2(R3)           R4 = ADDR OF FIRST CHAR PAST COMMAND
         LH    R2,0(R3)           R2 = TOTAL LENGTH OF STRING
         SH    R2,=H'4'           R2 = LENGTH MINUS HEADER  *HMD 07/81*
         SH    R2,2(R3)           R2 = LENGTH OF OPER CMD   *HMD 07/81*
         BNP   EOJ                IS NO COMMAND GOTO EOJ    *HMD 07/81*
         CH    R2,=H'100'         IS LENGTH TOO LONG?       *HMD 07/81*
         BNH   LENOK              LENGTH IS OK              *HMD 07/81*
         LA    R2,100             ONLY 1ST 100 BYTES        *HMD 07/81*
LENOK    BCTR  R2,0               R2 = R2 - 1 FOR EX MVC
         EX    R2,MOVE1           MOVE CMD INTO CARD
*************************************************************HMD 07/82*
** THE FOLLOWING CODE IS NECESSARY THE ENABLE THIS COMMAND  *HMD 07/82*
** TO WORK UNDER MVS/SP RELEASE 3. THIS IS DUE TO A CHANGE  *HMD 07/82*
** IN THE COMMAND SCHEDULER CSCB CREATION MODULE IEE0803D.  *HMD 07/82*
**                                                          *HMD 07/82*
** IN MVS/SP 3, IF AN ASID IS PRESENT IN THE XSA, THEN THE  *HMD 07/82*
** COMMAND SCHEDULER MOVES YOUR TSO USERID INTO THE NEWLY   *HMD 07/82*
** CREATED CSCB. WHY THIS IS DONE, WHO KNOWS. IT CAUSES,    *HMD 07/82*
** HOWEVER, THE STC INITIALIZATION ROUTINE IEEPRWI2 TO      *HMD 07/82*
** THINK THAT A 'SYSTEM' ADDRESS SPACE IS BEING CREATED     *HMD 07/82*
** DUE TO THE CHKEY FIELD OF THE CSCB CONTAINING YOUR       *HMD 07/82*
** USERID INSTEAD OF ZERO. BECAUSE THIS ADDRESS SPACE       *HMD 07/82*
** INITIALIZATION ROUTINE NAME FOR SYSTEM ADDRESS SPACES    *HMD 07/82*
** IS CONTAINED IN THE CHKEY FIELD, IEEPRWI2 ATTEMPT TO     *HMD 07/82*
** LINK TO YOUR TSO USERID TO INITIALIZE THE STARTED        *HMD 07/82*
** ADDRESS SPACE. THUS AN ABEND806-4 AND A RESULTING SVC    *HMD 07/82*
** DUMP.                                                    *HMD 07/82*
**                                                          *HMD 07/82*
** SINCE RESPONSE AT THE TERMINAL IS NOT REQUIRED FOR       *HMD 07/82*
** START AND MOUNT COMMANDS (AND THAT IS THE ONLY PLACE     *HMD 07/82*
** THIS CRAZY THING HAPPENS) WE WILL ISSUE THOSE COMMANDS   *HMD 07/82*
** WITH REGISTER ZERO EQUAL TO ZERO.                        *HMD 07/82*
*************************************************************HMD 07/82*
         CLC   =C'LOGON ',CARD    LOGON COMMAND?            *HMD 07/82*
         BE    EOJ                DON'T BE SILLY            *HMD 07/82*
         CLC   =C'logon ',CARD    LOGON COMMAND?            *HMD 07/82*
         BE    EOJ                DON'T BE SILLY            *HMD 07/82*
         CLC   =C'START ',CARD    IS IT A START COMMAND?    *HMD 07/82*
         BE    STARTM             YES..CLEAR R0MASK         *HMD 07/82*
         CLC   =C'S ',CARD        START COMMAND?            *HMD 07/82*
         BE    STARTM             YES, CLEAR R0MASK         *HMD 07/82*
         CLC   =C'MOUNT ',CARD    MOUNT COMMAND?            *HMD 07/82*
         BE    STARTM             YES, CLEAR R0MASK         *HMD 07/82*
         CLC   =C'M ',CARD        MOUNT COMMAND?            *HMD 07/82*
         BE    STARTM             NO COMTINUE WITH COMMANDS *HMD 07/82*
         CLC   =C'start ',CARD    L         C               *HMD 07/82*
         BE    STARTM               O          A            *HMD 07/82*
         CLC   =C's ',CARD            W            S        *HMD 07/82*
         BE    STARTM                   E             E     *HMD 07/82*
         CLC   =C'mount ',CARD            R                 *HMD 07/82*
         BE    STARTM                                       *HMD 07/82*
         CLC   =C'm ',CARD                                  *HMD 07/82*
         BNE   DOCMD              NO COMTINUE WITH COMMANDS *HMD 07/82*
STARTM   XC    R0MASK,R0MASK      CLEAR REGISTER 0 MASK     *HMD 07/82*
DOCMD    B     DOSVC34            GO DO THE COMMAND
***********************************************************************
*                                                                     *
*     X'80' WAS FOUND IN THE HIGH ORDER BYTE OF THE SECOND PARM,      *
*     SO WE HAVE BEEN CALLED AS A SUBROUTINE (MODE 3). THE SECOND     *
*     PARM CONTAINS THE CONSOLE ID WHERE THE COMMAND IS TO 'COME      *
*     FROM', SO USE THAT FOR THE R0 MASK.                             *
*                                                                     *
***********************************************************************
TWOPARMS L     R3,4(R10)          R3 = ADDR OF R0 MASK FOR SVC34
         MVC   R0MASK(4),0(R3)    SAVE R0 MASK FOR SVC34
***********************************************************************
*                                                                     *
*     ONLY ONE PARM WAS PASSED, SO WE ARE BEING CALLED IN MODE 1.     *
*     JUST ISSUE THE COMMAND FROM THE PARM STRING.                    *
*                                                                     *
***********************************************************************
ONEPARM  L     R10,0(R10)         GET PARAMETER ADDRESS
         SLR   R3,R3              CLEAR FOR ICM             *HMD 07/81*
         ICM   R3,B'0011',0(R10)  GET PARAMETER TEXT LENGTH
         BZ    USESYSIN           NO - GO GET COMMANDS FROM SYSIN
         CH    R3,=H'100'         COMMAND TOO LONG?         *HMD 07/81*
         BNH   CMDOK              NO, IS OK                 *HMD 07/81*
         LA    R3,100             ONLY DO 1ST 100 BYTES     *HMD 07/81*
CMDOK    BCTR  R3,R0              DECREMENT R3 FOR USE IN EXECUTE
         EX    R3,MOVE            EXECUTE MVC
DOSVC34  LA    R11,EOJ            GET ADDRESS FOR RETURN FROM SVC34
         B     SVC34              GO ISSUE COMMAND
         SPACE 3
***********************************************************************
*                                                                     *
*     NO PARM FIELD FOUND, SO LOOK AT SYSIN FOR INPUT                 *
*                                                                     *
***********************************************************************
USESYSIN OPEN  (SYSIN,INPUT)      OPEN SYSIN
         TM    SYSIN+DCBOFLGS-IHADCB,DCBOFOPN               *HMD 07/81*
         BZ    EOJ                IF BAD OPEN; END OF PGM   *HMD 07/81*
GETSYSIN GET   SYSIN,CARD         GET A SYSIN RECORD INTO SVC34 LIST
         MVC   CARD+72(8),CARD+80 BLANK OUT SEQUENCE FIELD IN 73-80
         CLI   CARD,C'*'          IS THIS A COMMENT?
         BE    GETSYSIN           YES;GO GET ANOTHER CARD
         LA    R11,GETSYSIN       GET ADDRESS FOR RETURN FROM SVC34
         B     SVC34              GO ISSUE COMMAND
         SPACE 3
EODSYSIN CLOSE (SYSIN)            CLOSE SYSIN
         SPACE 3
EOJ      L     R13,SAVEAREA+4     GET ADDRESS OF CALLER'S SAVEAREA
         RETURN (14,12),RC=0      RETURN TO CALLER
         SPACE 3                                            *CKO 07/92*
BADEOJ   L     R13,SAVEAREA+4     GET ADDRESS OF CALLER'S   *CKO 07/92*
         RETURN (14,12),RC=8      SAVE AREA & RETURN        *CKO 07/92*
         EJECT
***********************************************************************
*                                                                     *
*     THIS ROUTINE ACTUALLY ISSUES THE SVC 34. IT EITHER RETURNS      *
*     TO THE SYSIN-READ LOOP OR EOJ DEPENDING ON THE VALUE OF R11     *
*                                                                     *
***********************************************************************
SVC34    DS    0H
         LA    R3,CARD+L'CARD-1   POINT TO END OF TEXT      *HMD 07/81*
         LA    R4,CARD-1          POINT TO START OF TEXT    *HMD 07/81*
FINDTEXT DS    0H                 FIND LAST TEXT CHARACTER
         CR    R3,R4              ALL BLANK?
         BNH   SVC34END           YES - IGNORE IT
         CLI   0(R3),C' '         BLANK CHARACTER?
         BNE   GOTTEXT            NO - FOUND END OF TEXT
         BCT   R3,FINDTEXT        KEEP ON LOOKING
         SPACE
GOTTEXT  DS    0H                 BUILD PARAMETER LIST LENGTHS
         SR    R3,R4              COMPUTE LENGTH OF COMMAND *HMD 07/81*
         BNP   SVC34END           INVALID COMMAND           *HMD 07/81*
         LA    R3,5(R3)           TEXT AND LIST PREFIX
         STH   R3,CMDLIST         SET SVC 34 LIST LENGTH
         TESTAUTH FCTN=1          SEE IF WE ARE AUTHORIZED  *HMD 07/82*
         LTR   R15,R15            WELL, ARE WE?             *HMD 07/82*
         BZ    MODEOK             YES..JUST DO MODESET      *HMD 07/82*
         MVI   AUTHFLG,AUTHUS     INDICATE WE TURNED ON     *HMD 07/82*
* INSERT YOUR USER SVC HERE TO TURN ON APF AUTHORIZATION. A SAMPLE
* OF SUCH AN SVC IS ON THE LA MVS USER GROUP TAPE. THIS WILL ALLOW
* 'COMMAND' TO BE USED UNDER SPF OPTION 6 OR VIA THE 'CALL' COMMAND.
* ALSO, YOU WILL AVOID THE MESSY JOB OF UPDATING TABLES IN IKJEFT02.
         LTR   R15,R15            SYSTEM PROGRAMMER?        *HMD 07/82*
         BNZ   SVC34END           NOPE..DO NOT WASTE TIME   *HMD 07/82*
MODEOK   DS    0H                                           *HMD 07/82*
*        LA    R0,MSG1            ISSUE MESSAGE FOR COMMAND *BAC 05/90*
*        WTO   MF=(E,(R0))                                  *BAC 05/90*
         MVC   WTOCMD(101),CARD   MOVE IN COMMAND           *BAC 05/90*
         LA    R0,MSG2            ISSUE MESSAGE FOR COMMAND *BAC 05/90*
         WTO   MF=(E,(R0))                                  *BAC 05/90*
         MODESET KEY=ZERO         INDICATE KEY=ZERO
         SYSEVENT DONTSWAP        DONT GET SWAPPED          *HMD 07/81*
         L     R0,R0MASK          LOAD R0 FOR SVC34         *HMD 07/81*
         MGCR  CMDLIST            ISSUE OPERATOR COMMAND    *HMD 07/81*
         TM    SYSIN+DCBOFLGS-IHADCB,DCBOFOPN               *HMD 07/81*
*                                 ARE WE USING SYSIN?       *HMD 07/81*
         BZ    NOSTIMR            NO, DO NOT DELAY          *HMD 07/81*
         STIMER  WAIT,BINTVL=HOLD WAIT FOR A COMPLETION     *HMD 07/81*
NOSTIMR  SYSEVENT OKSWAP          OK TO GET SWAPPED NOW     *HMD 07/81*
         MODESET KEY=NZERO        GO BACK TO USER KEY
         CLI   AUTHFLG,AUTHUS     DID WE TURN ON AUTH?      *HMD 07/82*
         BNE   SVC34END           NO..JUST RETURN           *HMD 07/82*
* INSERT YOUR USER SVC HERE TO TURN OFF APF AUTHORIZATION, AS WE ARE
* DONE ISSUING COMMANDS.
         SPACE
SVC34END DS    0H                 END OF COMMAND ROUTINE
         BR    R11                RETURN TO MAINLINE
         SPACE 2                                            *CKO 07/92*
NOTAUTH  EQU  *                                             *CKO 07/92*
         TPUT  =CL60'Authorization failed for executing COMMAND',60
         B     BADEOJ                     Exit              *CKO 07/92*
         EJECT
SAVEAREA DC    18F'0'             OUR SAVEAREA
HOLD     DC    F'200'             WAIT FOR 2 SECONDS        *HMD 07/81*
R0MASK   DC    A(0)               R0 MASK FOR SVC34
AUTHFLG  DC    X'00'              AUTHORIZATION FLAG        *HMD 07/82*
AUTHUS   EQU   X'FF'              WE AUTHORIZED FOR SVC34   *HMD 07/82*
MOREFLG  DC    X'00'              EXTRA FILLER              *HMD 07/82*
ASID     DC    H'00'              OUR ASID
* Parms for RACHECK                                         *CKO 07/92*
CMDENT   DC    CL8'COMMAND'                                 *CKO 07/92*
CMDCLS   DC    AL1(4),C'APPL'                               *CKO 07/92*
         SPACE
         CNOP  4,8                ALIGN TO MIDDLE OF DOUBLE WORD
CMDLIST  DC    AL2(*-*,0)         SVC 34 LIST
CARD     DC    CL101' '           COMMAND TEXT
         SPACE 3
MOVE     MVC   CARD(*-*),2(R10)   MOVE PARM TEXT INTO SVC 34 LIST
MOVE1    MVC   CARD(*-*),0(R4)    MOVE PARM TEXT INTO SVC 34 LIST
         EJECT
SYSIN    DCB   DDNAME=SYSIN,DSORG=PS,LRECL=80,MACRF=(GM),RECFM=FB,     *
               EODAD=EODSYSIN
MSG1     WTO 'SYSTEMS PROGRAMMER BRIAN COURT ISSUES THE FOLLOWING COMMAX
               ND:',MF=L
MSG2     WTO '                                                         X
                                                          ',MF=L
WTOCMD   EQU MSG2+4
         EJECT
         LTORG                    BEGIN LITERAL POOL
         EJECT
***********************************************************************
*                                                                     *
*                SYSTEM CONTROL BLOCK MAPPING DSECTS                  *
*                                                                     *
*      ALL THESE MACROS CAN BE FOUND IN THE 'SYS1.AMODGEN' MACLIB     *
*                                                                     *
***********************************************************************
         CVT   DSECT=YES,LIST=YES COMMUNICATIONS VECTOR TABLE
         EJECT
         IHAASCB                  ADDRESS SPACE CONTROL BLOCK
         EJECT
         IEECUCM  FORMAT=NEW      UNIT CONTROL MODULE       *HMD 07/81*
         EJECT                                              *HMD 07/81*
         DCBD  DSORG=PS,DEVD=DA   DCB SYMBOLIC DEFN         *HMD 07/81*
         END
//L.SYSLMOD DD  DSN=SYSOSG.CSULOAD(COMMAND),DISP=SHR,UNIT=
./ ADD NAME=RESCUE   0100-02365-02365-1141-00363-00363-00000-JMILLER
/*---------------------------------------------------Rexx--*/
/*         M A I N    R E S C U E    E X E C               */
/*---------------------------------------------------------*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* Read the $$$DOC member for more information on using    */
/* the RESCUE execs.                                       */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */

call varinit          /* Read @parms and @dataset.         */
call ##jobchr reset   /* Reset job char file.              */

/*---------------------------------------------------------*/
/* Be sure all datasets are present; if not, exit.         */
/*---------------------------------------------------------*/
if  \dscheck() THEN DO
   SAY 'One or more datasets missing.  Processing terminated.'
   exit
end

/*---------------------------------------------------------*/
/* Call routines to build various JCL members.             */
/*---------------------------------------------------------*/
call #initvol         /* Init volume.                      */
call #defmcat         /* Define mastercat.                 */
call #defvsam         /* Define PAGE, MANx, etc.           */
call #defnvsm         /* Define NONVSAM catalog entries.   */
call #alcnvsm         /* Allocate non-VSAM datasets.       */
call #copyds          /* Copy datasets.                    */
call #altnvsm         /* Alter NONVSAM entries.            */
call #rfdsnt          /* Create RACF dataset name table.   */
call #rfstc           /* Create RACF started task table.   */
call #rfcopy          /* Create copy of RF dataset.        */
call #members         /* Build various members. (External) */
call #copymem         /* Copy members.                     */
call #delssa          /* Delete the System Specific Alias. */
call #misc            /* Last minute assorted stuff.       */

exit

/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.            */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
IF VALUE("DSNS.0") = "DSNS.0" THEN DO
   SAY 'Need to call varinit before using this function.'
   RETURN 0
END
###dslst = ""
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   IF pos(##prm,zzparm) > 0 THEN DO
      ###dslst = ###dslst" "zzdsn1
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.            */
/*---------------------------------------------------------*/
xdsthere:
ARG ##prm .
IF VALUE("DSNS.0") = "DSNS.0" THEN DO
   SAY 'Need to call varinit before using this function.'
   RETURN 0
END

do ##xxx = 1 TO DSNS.0
   IF POS(##prm,DSNS.##xxx) > 0 THEN RETURN 1
END
RETURN 0

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   say VALUE("JOBCARD"##x8)
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   PARSE VAR data data '/*' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   INTERPRET q '= "'r'"'
END

/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */
RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
trace off
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output) DA('"##ds5"("##mem5")')"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(output) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(pds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(pds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*---------------------------------------------------------*/
/* Check for presence of all datasets.  If copy mode is    */
/* "N" meaning the DS is not copied bu just created, then  */
/* assume it is ok.                                        */
/*---------------------------------------------------------*/
dscheck:
Say "Checking datasets in @DATASET member."
##ok = 1
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   /*--------------------------------------------------*/
   /* If a model is specified, then check only for the */
   /* existence of the model ds.                       */
   /*--------------------------------------------------*/
   stat = SYSDSN("'"zzdsn1"'")
   IF stat /= 'OK' THEN DO
      SAY 'Dataset not found: 'zzdsn1
      ##ok = 0
   END
END
RETURN ##ok

IF zzmode = "N" THEN ITERATE /* No copy-> assume ok. */
./ ADD NAME=WAIT     0100-02365-02365-1141-00157-00157-00000-JMILLER
//EGTLJCMA JOB (0),JMILLER,MSGCLASS=X,CLASS=A,NOTIFY=EGTLJCM,REGION=6M
//ASMACL   EXEC  ASMACL,PARM.L='MAP,LET,LIST,NCAL'
//C.SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//           DD  DSN=SYS1.MODGEN,DISP=SHR
//C.SYSIN    DD  *
PRC      TITLE 'WAIT - WAIT A LITTLE BIT.'
********************************************************************
*                                                                  *
* NAME - WAIT.                                                     *
*                                                                  *
* DESCRIPTION -                                                    *
*                                                                  *
*   THIS MODULE WILL WAIT THE REQUESTED NUMBER OF SECONDS.         *
*                                                                  *
* TO USE -                                                         *
*                                                                  *
*   PARM='NNNN', WHERE 0 < NNNN <= 9999, THE NUMBER OF SECONDS TO  *
*     WAIT. DEFAULT IS 10 SECONDS.                                 *
*                                                                  *
* RETURN CODES -                                                   *
*                                                                  *
*   R15 = 20, BAD PARM FIELD.                                      *
*                                                                  *
* LOG -                                                            *
*   05/30/86 L01 PTW IMPLEMENTED                                   *L01
*   09/27/88 L02 PTW IMPLEMENTED                                   *L02
*                                                                  *
********************************************************************
         LCLC  &CSECT
&CSECT   SETC  'WAIT'
&CSECT   CSECT
********************************************************************
*                                                                  *
*        I N I T I A L I Z E                                       *
*                                                                  *
********************************************************************
         PRINT NOGEN
         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME
         LR    R12,R15            ESTABLISH BASE.
         USING &CSECT,R12
         GETMAIN RU,LV=DYNLEN
         LR    R2,R13
         LR    R13,R1
         USING DYNAMIC,R13
         LR    R0,R1
         LA    R14,DYNLEN
         LA    R1,R1
         SLR   R15,R15
         MVCL  R0,R14             ZERO STORAGE.
         ST    R2,4(,R13)         BACK CHAIN.
         ST    R13,8(,R2)         FORWARD CHAIN.
         XC    RC,RC
********************************************************************
*                                                                  *
*        P A R M   P R O C E S S I N G                             *
*                                                                  *
********************************************************************
         MVC   SECONDS,=F'10'     DEFAULT.
         L     R2,4(,R13)         A(PREVIOUS SAVEAREA).
         L     R2,24(,R2)         A(A(PARM)).
         LTR   R2,R2              CHECK FOR NULL PARM.
         BZ    DOTIME
         L     R2,0(,R2)          A(PARM).
         LH    R3,0(,R2)          L'PARM.
         LTR   R3,R3              IF ZEROS +
         BZ    DOTIME               THEN EXIT.
         CH    R3,=H'4'           IF LENGTH NGT '4' +
         BH    BADTIME            FORGET NEXT.
         LA    R4,2(,R2)
VERNUM   DS    0H
         CLI   0(R4),C'0'         SCAN
         BL    BADTIME             FORWARD
         CLI   0(R4),C'9'         SCAN
         BH    BADTIME             FORWARD
         LA    R4,1(,R4)            TO FIRST
         BCT   R3,VERNUM
         LH    R3,0(,R2)
         BCTR  R3,0               MACHINE LENGTH.
         EX    R3,PACKSEC         PACK SECONDS.
         CVB   R3,DOUBLE          CONVERT TO BINARY.
         CH    R3,=H'1'           TEST SECONDS
         BL    BADTIME             FOR LIMITS.
         CH    R3,=H'9999'
         BH    BADTIME
         ST    R3,SECONDS          AND STORE.
PACKSEC  PACK  DOUBLE,2(*-*,R2)
********************************************************************
*                                                                  *
*        W A I T                                                   *
*                                                                  *
********************************************************************
DOTIME   DS    0H
         L     R2,SECONDS
         MH    R2,=H'100'
         ST    R2,SECONDS
         STIMER WAIT,BINTVL=SECONDS
         XC    RC,RC
********************************************************************
*                                                                  *
*        R E T U R N                                               *
*                                                                  *
********************************************************************
RETURN   DS    0H
         L     R2,RC                  R2 = RC.
         LR    R1,R13              PREPARE
         L     R13,4(,R13)         FOR FREEMAIN.
         FREEMAIN RU,LV=DYNLEN,A=(1)
         LR    R15,R2              AND RETURN
         RETURN (14,12),RC=(15)      WITH R15 = RC.
********************************************************************
*                                                                  *
*        E R R O R S                                               *
*                                                                  *
********************************************************************
BADTIME  DS    0H
         WTO   'WAIT: BAD PARM - SPECIFY NNNN (1-9999 SECONDS).',      X
               ROUTCDE=11,MCSFLAG=HRDCPY
         MVC   RC,=F'20'
         B     RETURN
********************************************************************
*                                                                  *
*        S T A T I C   A R E A                                     *
*                                                                  *
********************************************************************
SRCLEVEL DC    C'                                        '
         LTORG *
********************************************************************
*                                                                  *
*        D Y N A M I C   A R E A                                   *
*                                                                  *
********************************************************************
DYNAMIC  DSECT
SAVE     DS    18F .
DOUBLE   DS    D
RC       DS    F
SECONDS  DS    F
DYNLEN   EQU   *-DYNAMIC
         PRINT OFF
R0       EQU   00
R1       EQU   01
R2       EQU   02
R3       EQU   03
R4       EQU   04
R5       EQU   05
R6       EQU   06
R7       EQU   07
R8       EQU   08
R9       EQU   09
R10      EQU   10
R11      EQU   11
R12      EQU   12                 PROGRAM BASE.
R13      EQU   13                 A(SAVE AREA).
R14      EQU   14
R15      EQU   15
         PRINT ON
         END   &CSECT
//L.SYSLMOD DD  DSN=SYSOSG.CSULOAD(WAIT),DISP=SHR,UNIT=
./ ADD NAME=ZBPXPRM  0100-02365-02365-1141-00049-00049-00000-JMILLER
FILESYSTYPE TYPE(HFS)
            ENTRYPOINT(GFUAINIT)
            PARM(' ')

FILESYSTYPE TYPE(TFS)
            ENTRYPOINT(BPXTFS)

   MAXPROCSYS(900)
   MAXPROCUSER(100)
   MAXUIDS(200)
   MAXFILEPROC(2000)
   MAXPTYS(800)
   CTRACE(CTIBPX00)
   FILESYSTYPE TYPE(UDS) ENTRYPOINT(BPXTUINT)
   NETWORK DOMAINNAME(AF_UNIX)
           DOMAINNUMBER(1)
           MAXSOCKETS(2000)
           TYPE(UDS)
   FILESYSTYPE TYPE(INET) ENTRYPOINT(EZBPFINI)
   NETWORK DOMAINNAME(AF_INET)
           DOMAINNUMBER(2)
           MAXSOCKETS(64000)
           TYPE(INET)
   MAXTHREADTASKS(1000)
   MAXTHREADS(500)
   IPCMSGNIDS    (500)
   IPCMSGQBYTES  (2147483647)
   IPCMSGQMNUM   (10000)
   IPCSHMNIDS    (500)
   IPCSHMSPAGES  (262144)
   IPCSHMMPAGES  (25600)
   IPCSHMNSEGS   (500)
   IPCSEMNIDS    (500)
   IPCSEMNSEMS   (1000)
   IPCSEMNOPS    (25)
   MAXMMAPAREA(40960)
   MAXCORESIZE(4194304)
   MAXASSIZE(209715200)
   MAXCPUTIME(1000)
   MAXSHAREPAGES(131072)
   FORKCOPY(COW)
   SUPERUSER(BPXROOT)
   TTYGROUP(TTY)
   STARTUP_PROC(OMVS)
   SYSCALL_COUNTS(NO)
   MAXQUEUEDSIGS(1000)
   SYSPLEX(NO)
   SHRLIBRGNSIZE(67108864)
   SHRLIBMAXPAGES(4096)
./ ADD NAME=ZCOMMND  0100-02365-02365-1141-00008-00008-00000-JMILLER
COM='CD SET,SDUMP,NODUMP'
COM='S VLF,SUB=MSTR'
COM='S DLF,SUB=MSTR'
COM='S TSSO,SUB=MSTR'
COM='S EZAZSSI,P=NORMVS'
COM='S IRRDPTAB'
COM='S SDSF'
COM='S VTAM,,,(LIST=00)'
./ ADD NAME=ZIEALPA  0100-02365-02365-1141-00006-00006-00000-JMILLER
/*-------------------------------------------------------------*/
/* MLPA modules.  Do not specify RACF DSNT and STC tables      */
/* (ICHRIN03 and ICHRDSNT) is they are being auto-built.       */
/* MLPA entries for these modules will be build automatically  */
/* if they are omitted here.                                   */
/*-------------------------------------------------------------*/
./ ADD NAME=ZIEASYS  0100-02365-02365-1141-00042-00042-00000-JMILLER
APG=07,                       AUTOMATIC PRIORITY GROUP IS 7
CLOCK=00,                     SELECT CLOCK00
CLPA,                         ALWAYS DO CLPA
CMB=(UNITR,COMM,GRAPH,CHRDR), ADDITIONAL CMB ENTRIES
CMD=(00,01),
CON=00,                       SELECT CONSOL00
CSA=(3000,30000),             CSA RANGE
DUMP=DASD,                    PLACE SVC DUMPS ON DASD DEVICES
GRS=NONE,                     NO COORDINATION OF GRS REQUESTS
ICS=00,                       SELECT IEAICS00, CNTL SPECS FOR SRM
IPS=00,                       SELECT IEAIPS00, PERF SPECS FOR SRM
LNKAUTH=LNKLST,               AUTHORIZE LNKLST00, APFTAB IS ALTERNATE
LOGCLS=L,                     WILL NOT BE PRINTED BY DEFAULT
LOGLMT=999999,                MAX WTL MESSAGES QUEUED, MUST BE 6 DIGITS
LOGREC=SYS1.LOGREC,           ERROR RECORDING
LPA=00,                       SELECT LPALST00
MAXUSER=250,                  SYS TASKS PLUS INITS PLUS TSOUSERS
MLPA=00,                      SELECT IEALPA00, MLPA PARAMETERS
MSTRJCL=01,                   SELECT MSTJCL01, MASTER JCL
OMVS=(00),                    SELECT BPXPRM00
OPI=YES,                      ALLOW OPERATOR OVERRIDE TO IEASYS00
OPT=00,                       SELECT IEAOPT00, SRM TUNING PARAMETERS
PAGE=(PAGE.RESCUE.PLPA,
      PAGE.RESCUE.COMMON,
      PAGE.RESCUE.LOCAL1,L),
PAK=00,                       SELECT IEAPAK00
PROG=(L0,A0),                 SELECT PROGL0 AND A0 (LINKLST AND APF)
REAL=128,                     ALLOWS 2 64K OR 1 128K JOB TO RUN V=R
RSU=0,                        NO RECONFIG STORAGE UNITS
RSVNONR=5,                    RESERVED ASVT ENTRIES
RSVSTRT=5,                    RESERVED ASVT ENTRIES
SCH=00,                       SELECT SCHED00
SMF=00,                       SELECT SMFPRM00, SMF PARAMETERS
SMS=00,                       SMS PARAMETERS
SQA=(15,64),                  SQA SIZE APPROX 640K
SSN=00,                       SELECT IEFSSN00, SUBSYSTEM NAMES
SYSNAME=RESCUE,               SYSTEM NAME
PROD=00,                      SELECT IFAPRD01
SVC=00,                       SELECT IEASVC00, USER SVCS
VAL=00,                       SELECT VATLST00
VIODSN=SYS1.STGINDEX,         VIO DS
VRREGN=64                     DEFAULT REAL-STORAGE REGION SIZE
./ ADD NAME=ZIEFSSN  0100-02365-02365-1141-00012-00012-00000-JMILLER
SUBSYS SUBNAME(SMS)
   INITRTN(IGDSSIIN)
   INITPARM('ID=02,PROMPT=DISPLAY')
SUBSYS SUBNAME(JES2) PRIMARY(YES) START(YES)
SUBSYS SUBNAME(IRLM)
SUBSYS SUBNAME(JRLM)
SUBSYS SUBNAME(FFST)
SUBSYS SUBNAME(SOM)  INITRTN(GOSAMSSI)
SUBSYS SUBNAME(TNF)
SUBSYS SUBNAME(VMCF)
SUBSYS SUBNAME(CICS) INITRTN(DFHSSIN)
SUBSYS SUBNAME(TSSO) INITRTN(TSSOINIT)
./ ADD NAME=ZIGDSMS  0100-02365-02365-1141-00010-00010-00000-JMILLER
    INTERVAL(15)
    DINTERVAL(150)
    REVERIFY(NO)
    ACSDEFAULTS(NO)
    TRACE(ON)
    SIZE(128K)
    TYPE(ALL)
    JOBNAME(*)
    ASID(*)
    SELECT(ALL)
./ ADD NAME=ZISPALOC 0100-02365-02365-1141-00045-00045-00000-JMILLER
/*-------------------------------------------------------rexx--------*/
/* TSO Allocation EXEC.                                              */
/* Rescue System.                                                    */
/*                                                                   */
/* 03/17/2001 John C. Miller                                         */
/*-------------------------------------------------------------------*/
call setup

/*-------------------------------------------------------------------*/
/* Allocate ISPPROF dataset                                          */
/*-------------------------------------------------------------------*/
ispprof = USERID()".ISPF.ISPPROF"
if \alc('ISPPROF', "'"ispprof"'") THEN DO
   "alloc da('"ispprof"') f(ISPPROF) new",
   "space(1 1) cyl lrecl(80) blksize(6160) recfm(f b) dir(15)"
   cc = RC
   IF cc /= 0 THEN DO
      SAY "Unable to allocate ISPF profile dataset "ispprof";"
      SAY "Please contact systems support for assistance."
      SAY "Return code: "cc
   END
END

/*-------------------------------------------------------------------*/
/* Execute user CLIST/Exec if present (Pre-allocation)               */
/*-------------------------------------------------------------------*/
IF SYSDSN("'"ispprof"(PRE)'") = "OK" THEN DO
   "EXEC '"ispprof"(PRE)'"
   cc = RC
   IF cc /= 0 THEN exit
END

"PDF"
exit

/*--------- Allocate the concatenation ------------*/
alc:
PARSE UPPER ARG ddname, dsname
mg = MSG('OFF')                          /* Turn msg off             */
"FREE  FI("ddname")"                     /* Free the DDNAME          */
mg = MSG(mg)                             /* Restore msg level        */
"ALLOC FI("ddname") DA("dsname") SHR"    /* Allocate the files       */
cc = RC                                  /* Save return code         */
RETURN cc <= 4                           /* Return 1 if OK           */

./ ADD NAME=ZJES2PRM 0100-02365-02365-1141-00480-00480-00000-JMILLER
/*-------------------------------------------------------*/
/* The parms below were copied from ZJES2PRM in          */
/* the REACUE build PDS. It is recommended that you not  */
/* modify these parameters directly, but rather make any */
/* changes to the ZJES2PRM source, and rebuild the       */
/* RESCUE members.  03/10/2001 John C. Miller.           */
/*-------------------------------------------------------*/
OPTSDEF LOG=YES
/*                                                                   */
LOGON(1) APPLID=JES2
/*                                                                   */
BUFDEF   BELOWBUF=(LIMIT=114,WARN=80)
/*                                                                   */
CONDEF   AUTOCMD=50,
         BUFNUM=950,
         BUFWARN=80,
         CONCHAR=$,
         DISPLEN=65,
         DISPMAX=100,
         MASMSG=200,
         RDRCHAR=$
DEBUG    =NO
COMPACT  NAME=JESDATA,
         NUMBER=10,
         CHARS=(16,
           F1,F2,F3,F4,F5,F6,
           F7,F8,F9,A,E,I,D6,
           E4,40,X)
ESTBYTE  NUM=99999,
         INT=99999,
         OPT=0
ESTIME   NUM=2,
         INT=1,
         OPT=NO
ESTLNCT  NUM=5,
         INT=6000,
         OPT=0
ESTPAGE  NUM=100,
         INT=10,
         OPT=0
ESTPUN   NUM=100,
         INT=2000,
         OPT=0
FSSDEF(PRINTOFF)
INIT(1) NAME=1,CLASS=A,START=YES
INIT(2) NAME=1,CLASS=A,START=YES
INIT(3) NAME=1,CLASS=A,START=YES
INIT(4) NAME=1,CLASS=A,START=YES
INIT(5) NAME=1,CLASS=A,START=YES
INIT(6) NAME=1,CLASS=A,START=YES
INIT(7) NAME=1,CLASS=A,START=YES
INIT(8) NAME=1,CLASS=A,START=YES
INITDEF  PARTNUM=8
/*                                                                  */
INTRDR   AUTH=(JOB=YES,DEVICE=NO,SYSTEM=YES),BATCH=YES,CLASS=A,
         HOLD=NO,PRTYINC=0,PRTYLIM=15,RDINUM=20
/*                                                                   */
JOBCLASS(A) ACCT=NO,         /* ACCT# NOT REQ   B................... */
         PGMRNAME=NO,        /* PGMRNM NOT RQ   B................... */
         TIME=(0030,00),     /* JOB STEP TIME   ...MMMMSS........... */
         REGION=4096K,       /* REGION SIZE     .........CCC........ */
         COMMAND=VERIFY,     /* VERIFY CMDS     ............R....... */
         BLP=YES,            /* IGNORE BLP      .............L...... */
         AUTH=ALL,           /* ALLOW ALL CMD   ..............AAAA.. */
         MSGLEVEL=(1,1),     /* JOB, ALL MSGS   ..................EF */
         COPY=NO,            /* NOT TYPRUN=COPY                 DHWNC*/
         HOLD=NO,            /* NOT TYPRUN=HOLD                 DHWNC*/
         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT         DHWNC*/
         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT         DHWNC*/
         JOURNAL=NO,         /* JOURNAL THIS JOB CLASS          DHWNC*/
         LOG=YES,            /* PRINT JES2 JOB LOG              DHWNC*/
         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB          DHWNC*/
         PERFORM=000,        /* SRM PERFORMANCE GROUP 0         DHWNC*/
         PROCLIB=00,         /* USE //PROC00 DD                 DHWNC*/
         RESTART=NO,         /* NO REQUEUE (XEQ) ON IPL         DHWNC*/
         SCAN=NO,            /* NOT TYPRUN=SCAN                 DHWNC*/
         SWA=BELOW,          /* SWA CBS BELOW 16M LINE          DHWNC*/
         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS           DHWNC*/
         TYPE26=YES          /* PRODUCE SMF 26 RECORDS          DHWNC*/
/*                                                                   */
/*                                                                   */
JOBDEF   ACCTFLD=OPTIONAL,   /* ACCOUNTING FIELD OPTIONAL      DOHWNC*/
         JCLERR=NO,          /* NO TERM. JOB W/JCL ERROR       DOHWNC*/
     /*  JOBNUM=1000,  */    /* JOB QUEUE SIZE                     DC*/
         JOBNUM=9999,        /* JOB QUEUE SIZE                  MAM2*/
         JOBWARN=80,         /* WARNING THRESHOLD % FOR JQES   DOHWNC*/
         NUMWARN=80,         /* WARN THRESHOLD % FOR JOB NUMB. DOHWNC*/
         PRTYHIGH=10,        /* UPPER LIMIT FOR AGING          DOHWNC*/
         PRTYJECL=YES,       /*PRIORITY JECL SUPPORTED         DOHWNC*/
         PRTYJOB=NO,         /* PRTY= ON JOB NOT SUP'D         DOHWNC*/
         PRTYLOW=5,          /* LOWER LIMIT FOR AGING          DOHWNC*/
         PRTYRATE=96,        /* PRTY AGING RATE X/DAY          DOHWNC*/
         RANGE=(1-9999)      /* LOCAL JOB NUMBER RANGE          DOWNC*/
/*                                                                   */
JOBPRTY(1) PRIORITY=9,       /* JOB PRTY=9 IF                  DOHWNC*/
          TIME=2             /*  < 2 MIN. EXEC. TIME           DOHWNC*/
                             /*                                      */
JOBPRTY(2) PRIORITY=8,       /* JOB PRTY=8 IF                        */
          TIME=5             /*  < 5 MIN. EXEC. TIME                 */
                             /*                                      */
JOBPRTY(3) PRIORITY=7,TIME=15 /*JOB PRTY=7 IF <15 MIN.  &RPRI2,...OC*/
                             /* ETC.                                 */
                             /*                                      */
JOBPRTY(4) PRIORITY=6,       /* JOB PRTY=6 IF NOLIM     &RPRI2,...OC*/
         TIME=1440           /* ETC.                                 */
                             /*                                      */
/*                            *--------------------------------------*
                              |    IDENTIFY JES2 APPLIDS TO VTAM     |
                              *--------------------------------------*
                                                                    */
MASDEF   SHARED=NOCHECK,     /* MULTI ACCESS SPOOL NOCHECK           */
         HOLD=100,           /* MINIMUM HOLD TIME                    */
         DORMANCY=(100,500), /* MINIMUM / MAXIMUM DORMANCY TIME      */
         LOCKOUT=1200        /* LOCK-OUT WARNING TIME                */
                             /*                                      */
/*                                                                  */
NJEDEF   DELAY=120,         /* MAX. MSG DELAY TIME            DOHWNC*/
         JRNUM=4,           /* NUM. OF JOB RECEIVERS           DHWNC*/
         JTNUM=4,           /* NUM. OF JOB XMITTERS            DHWNC*/
         LINENUM=1,         /* NUM. OF LINES FOR NJE           DHWNC*/
         NODENUM=2000,      /* MAX. NUMBER OF NJE NODES         MAM2*/
         OWNNODE=1,         /* THIS NODE'S NUMBER              MAM  */
         PATH=1,            /* NUM. OF PATHS/ALT'NATE          DHWNC*/
         RESTMAX=8000000,   /* MAX. RESISTANCE TOLERANCE       DHWNC*/
         RESTNODE=100,      /* THIS NODE'S RESISTANCE          DHWNC*/
         RESTTOL=0,         /* ALT. RESISTANCE TOLERANCE       DHWNC*/
         SRNUM=4,           /* NUM. OF SYSOUT RECEIVERS        DHWNC*/
         STNUM=4            /* NUM. OF SYSOUT TRANSMITTERS     DHWNC*/
/*                                                                  */
/*OFFLOAD(1) DSN=SYS1.OFFLOAD  /* DATA SET NAME           DSN       */
/*                           /* NO. OF DEVICES (UNITS)  UNITCT      */
                             /*                                      */
OFFLOAD(1) DSN=SYS3.SPOOL.OFFLOAD,LABEL=SL,RETPD=7,UNIT=CART
OFF(1).JR CLASS=,           /* RELOAD ALL CLASSES             DOHWNC*/
         HOLD=,             /* RELOAD HELD - NON-HELD         DOHWNC*/
         JOBNAME=,          /* RELOAD ANY JOB NAME            DOHWNC*/
                            /* MODIFY JOBS ON RELOAD                */
         MOD=(CLASS=,       /* - DON'T CHANGE CLASS           DOHWNC*/
              HOLD=,        /* - DON'T CHANGE HOLD            DOHWNC*/
              ROUTECDE=,    /* - DON'T CHANGE DEST'N          DOHWNC*/
              SYSAFF=),     /* - DON'T CHANGE SYSAFF.         DOHWNC*/
         NOTIFY=NO,         /* DON'T NOTIFY ON RELOAD         DOHWNC*/
         RANGE=J1-32767,    /* RELOAD ALL JOB NUMBERS         DOHWNC*/
         ROUTECDE=(),       /* RELOAD JOBS W/ANY DEST         DOHWNC*/
         START=YES,         /* ABORTED WITH $S OFFLOAD         DHWNC*/
         SYSAFF=(),         /* RELOAD JOBS WITH ANY AFF       DOHWNC*/
         WS=(/)             /* JOB SELECTION CRITERIA         DLT   */
/*                                                                  */
OFF(1).JT CLASS=,           /* SELECT NO CLASSES              DOHWNC*/
         DISP=DELETE,       /* PURGE AFTER OFFLOAD            DOHWNC*/
         HOLD=,             /* SELECT HELD - NON-HELD         DOHWNC*/
         JOBNAME=,          /* SELECT ANY JOB NAME            DOHWNC*/
         NOTIFY=NO,         /* DON'T NOTIFY ON OFFLD.         DOHWNC*/
         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS         DOHWNC*/
         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST         DOHWNC*/
         START=YES,         /* STARTED WITH $S OFFLOAD     DHWNC*/
         SYSAFF=(),         /* SELECT JOBS WITH ANY AFF       DOHWNC*/
         VOLUME=(),         /* SELECT ANY SPOOL VOLUME        DOHWNC*/
         WS=(/)             /* JOB SELECTION CRITERIA         DLT   */
/*                                                                  */
OFF(1).SR BURST=,         /* SELECT ANY BURST SETTING       DOHWNC*/
         OUTDISP=(HOLD,KEEP,LEAVE,WRITE),
         FCB=,              /* SELECT ANY FCB                 DOHWNC*/
         FLASH=,            /* SELECT ANY/NO FLASH            DOHWNC*/
         HOLD=,             /* SELCT HELD/NON-HLD JOBS        DOHWNC*/
         JOBNAME=,          /* SELECT ANY JOB NAME            DOHWNC*/
                            /* MODIFY FOLLOWING ON RELOAD     DOHWNC*/
         MOD=(BURST=,       /* - DON'T CHANGE BURST           DOHWNC*/
              OUTDISP=,     /* - DON'T CHANGE DSHOLD          DOHWNC*/
              FCB=,         /* - DON'T CHANGE FCB             DOHWNC*/
              FLASH=,       /* - DON'T CHANGE FLASH           DOHWNC*/
              FORMS=,       /* - DON'T CHANGE FORMS           DOHWNC*/
              HOLD=,        /* - DON'T CHANGE HOLD            DOHWNC*/
              PRMODE=,      /* - DON'T CHANGE PRMODE          DOHWNC*/
              QUEUE=,       /* - DON'T CHANGE CLASS           DOHWNC*/
              ROUTECDE=,    /* - DON'T CHANGE DESTN           DOHWNC*/
              UCS=,         /* - DON'T CHANGE UCS             DOHWNC*/
              WRITER=),     /* - DON'T CHANGE WRITER          DOHWNC*/
         NOTIFY=NO,         /* DON'T NOTIFY ON RELOAD         DOHWNC*/
         PRMODE=(),         /* SELECT ANY PRMODE              DOHWNC*/
         QUEUE=,            /* SELECT ANY SYSOUT CLASS        DOHWNC*/
         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS         DOHWNC*/
         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST         DOHWNC*/
         START=YES,         /* STARTED WITH $S OFFLOAD         DHWNC*/
         UCS=,              /* SELECT ANY UCS                 DOHWNC*/
         WRITER=,           /* SELECT ANY WRITER              DOHWNC*/
         WS=(/)             /* JOB SELECTION CRITERIA         DOHWNC*/
                            /* - CLASS ONLY                   DOHWNC*/
/*                                                                  */
OFF(1).ST BURST=,           /* SELECT ANY BURST SET'G         DOHWNC*/
         DISP=DELETE,       /* PURGE AFTER OFFLOAD            DOHWNC*/
         OUTDISP=(HOLD,KEEP,LEAVE,WRITE),
         FCB=,              /* SELECT ANY FCB                 DOHWNC*/
         FLASH=,            /* SELECT ANY/NO FLASH            DOHWNC*/
         HOLD=,             /* SELCT HELD-NON-HLD JOBS        DOHWNC*/
         JOBNAME=,          /* SELECT ANY JOB NAME            DOHWNC*/
         LIMIT=(0-*),       /* SELECT ANY # LINES             DOHWNC*/
         NOTIFY=NO,         /* DON'T NOTIFY ON OFFLD.         DOHWNC*/
         PLIM=(0-*),        /* SELECT ANY # PAGES             DOHWNC*/
         PRMODE=(),         /* SELECT ANY PRMODE              DOHWNC*/
         QUEUE=,            /* SELECT ANY SYSOUT CLASS        DOHWNC*/
         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS         DOHWNC*/
         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST         DOHWNC*/
         START=YES,         /* STARTED WITH $S OFFLOAD         DHWNC*/
         UCS=,              /* SELECT ANY UCS                 DOHWNC*/
         VOLUME=(),         /* SELECT ANY SPOOL VOLUME        DOHWNC*/
         WRITER=,           /* SELECT ANY WRITER              DOHWNC*/
         WS=(/)             /* JOB SELECTION CRITERIA         DLT   */
                            /* - CLASS ONLY                   DOHWNC*/
/*                                                                   */
/*********************************************************************/
OUTCLASS(A) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(B) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* NO TRACK-CELL                      WC*/
/*                                                                  */
OUTCLASS(C) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(D) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(H) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(HOLD,HOLD),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
/*                                                                  */
OUTCLASS(J) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=PRINT,      /* SPECIAL PRINT CLASS                WC*/
         TRKCELL=NO        /* NO TRACK-CELL                      WC*/
/*                                                                 */
OUTCLASS(K) BLNKTRNC=YES,  /* TRUNCATE TRAILING BLANKS             */
         OUTDISP=(HOLD,HOLD),                 /*               MAM */
         OUTPUT=PRINT,      /* PRINT CLASS                     MAM */
         TRKCELL=YES        /* TRACK-CELL THIS CLASS               */
/*                                                                 */
OUTCLASS(L) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(KEEP,KEEP),
         OUTPUT=PRINT,      /* PRINT CLASS FOR LWTR               WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(M) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                 */
OUTCLASS(O) BLNKTRNC=YES,  /* TRUNCATE TRAILING BLANKS             */
         OUTDISP=(HOLD,HOLD),                 /*               MAM */
         OUTPUT=PRINT,      /* PRINT CLASS                     MAM */
         TRKCELL=YES        /* TRACK-CELL THIS CLASS               */
/*                                                                 */
OUTCLASS(P) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(HOLD,HOLD),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(Q) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(T) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(HOLD,HOLD),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
/*                                                                  */
OUTCLASS(X) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(HOLD,HOLD),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(Y) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(HOLD,HOLD),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(Z) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=DUMMY,      /* DUMMY PRINT CLASS                  WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(5) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(PURGE,PURGE),
         OUTPUT=DUMMY,      /* DUMMY PRINT CLASS                  WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTDEF   BRODCAST=NO,       /* WHETHER SHARED BROADCASTING     DOWNC*/
         COPIES=255,        /* MAX. # OF COPIES ALLOWED       DOHWNC*/
         DMNDSET=NO,        /* NO DEMAND SETUP                  DWNC*/
         JOENUM=3000,       /* MAX. # OF JOES                   MAM2*/
         JOEWARN=80,        /* WARNING THRESHOLD %            DOHWNC*/
         PRTYHIGH=255,      /* CEILING FOR PRTY AGING         DOHWNC*/
         PRTYLOW=0,         /* FLOOR FOR PRTY AGING           DOHWNC*/
         PRTYOUT=NO,        /* NO PRTY= ON // OUTPUT          DOHWNC*/
         STDFORM=STD,       /* DEFAULT FORMS ID                 DWNC*/
         USERSET=NO         /* NO USER DEMAND-SETUP             DWNC*/
/*                                                                  */
OUTPRTY(1) PRIORITY=144,    /* OUTPUT PRTY IS 144 IF          DOHWNC*/
         RECORD=2000,       /*  < 2000 RECORDS (LINE)         DOHWNC*/
         PAGE=50            /*  OR < 50 PAGES (PAGE)          DOHWNC*/
/*                                                                  */
OUTPRTY(2) PRIORITY=128,    /* OUTPUT PRTY IS 128 IF          DOHWNC*/
         RECORD=5000,       /*  < 5000 RECORDS (LINE)         DOHWNC*/
         PAGE=100           /*  OR < 100 PAGES (PAGE)         DOHWNC*/
/*                                                                  */
OUTPRTY(3) PRIORITY=112,     /* OUTPUT PRTY IS 112 IF   &XPRI1    OC*/
           RECORD=15000,     /*  <15000 RECORDS (LINE)  &XLIN1    OC*/
           PAGE=300          /*  OR <300 PAGES (PAGE)   &XPAG1    OC*/
                             /* ETC.                               OC*/
OUTPRTY(4) PRIORITY=96,      /* OUTPUT PRTY IS  96 IF   &XPRI1    OC*/
           RECORD=16677215,  /*  < MAX  RECORDS (LINE)  &XLIN1    OC*/
           PAGE=16677215     /*  OR <MAX PAGES (PAGE)   &XPAG1    OC*/
                             /* ETC.                               OC*/
/*                                                                  */
PCEDEF   CNVTNUM=2,         /* NUMBER OF CONVERTER PCES        DHWNC*/
         OUTNUM=2,          /* NUMBER OF OUTPUT PCES           DHWNC*/
         PSONUM=2,          /* NUMBER OF PSO PCES              DHWNC*/
         PURGENUM=2         /* NUMBER OF PURGE PCES            DHWNC*/
/*                                                                   */
PRINTDEF CCWNUM=200,        /* # CCWS / PRINT BUFFER            DWNC*/
         DBLBUFR=YES,       /* DOUBLE BUFFER LCL PRTS           DWNC*/
         FCB=6,             /* INITIAL FCB LOADED               DWNC*/
         LINECT=61,         /* 61 LINES/PAGE                  DOHWNC*/
/*       NIFCB=8X8,    */   /* NO 3800 FCB LOADED               DWNC*/
/*       NIFLASH=****, */    /* NO 3800 FLASH LOADED             DWNC*/
                             /* NOTE: THE VALUES FOR NIFCB= AND      */
                             /*       NIFLASH=  CANNOT BE NULL OR    */
                             /*       ASTERISKS (AS SHOWN HERE).     */
                             /*       IF THE STATEMENTS ARE NOT      */
                             /*       CODED AT ALL, THEN THE DEFAULT */
                             /*       WILL BE ASTERISKS. THE         */
                             /*       STATEMENTS ARE SHOWN THIS WAY  */
                             /*       ONLY TO INCLUDE THE DEFAULT    */
                             /*       VALUES HERE.                   */
         NIUCS=0,            /* WAS GT15                         DWNC*/
         RDBLBUFR=NO,        /* SINGLE BUFFER RMT PRTS           DWNC*/
         SEPPAGE=(REMOTE=HALF,LOCAL=FULL),
         TRANS=NO,           /* PN-XLATE FOR 1403/RM.PR          DWNC*/
         UCS=0               /* BYPASS UCS-LOADING               DWNC*/
/*                                                                   */
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    LOCAL PRINTERS                    |
                              *--------------------------------------*
                                                                     */
                             /* ALTERNATE NAME FOR PRTN:             */
                             /*   PRINTERN                           */
PRT(1)  CLASS=AJ,        /* JOB CLASS THAT CAN BE CHOSEN   DOHWNC*/
        UNIT=00E,
        CKPTLINE=60,     /*  MAX LINES IN A LOGICAL PAGE    DOHWNC*/
        CKPTPAGE=100,    /*  MAX PAGES BEFORE A CKPT        DOHWNC*/
        START=YES,       /*  PRT1 COMES UP STARTED          DOHWNC*/
        WS=(W,R,Q,PRM,LIM,F,FCB/UCS,P),
        TRKCELL=NO       /*  RECORDS DESPOOLED 1 AT A TIME    HWNC*/
/*                                                                  */
PRT(2)  CLASS=AJ,        /* JOB CLASS THAT CAN BE CHOSEN   DOHWNC*/
        UNIT=60F,
        CKPTLINE=60,     /*  MAX LINES IN A LOGICAL PAGE    DOHWNC*/
        CKPTPAGE=100,    /*  MAX PAGES BEFORE A CKPT        DOHWNC*/
        START=YES,       /*  PRT2 COMES UP STARTED          DOHWNC*/
        WS=(W,R,Q,PRM,LIM,F,FCB/UCS,P),
        TRKCELL=NO       /*  RECORDS DESPOOLED 1 AT A TIME    HWNC*/
/*                                                                   */
/*                                                                   */
PUNCHDEF CCWNUM=200,         /* # CCWS / PUNCH BUFFER            DWNC*/
         DBLBUFR=YES,        /* SINGLE BUFFER LCL PUNS           DWNC*/
         RDBLBUFR=NO         /* SINGLE BUFFER RMT PUNS           DWNC*/
/*                                                                   */
PUN(1)  CKPTLINE=100,    /* NO. OF CARDS TO PUNCH PER PAGE DOHWNC*/
        CLASS=BK,    /*  OUTPUT CLASS PROCESSED BY PUN  DOHWNC*/
       WS=(W,R,Q,PRM,LIM/F,P)  /* WORK SELECTION CRITERION    DOHWNC*/
/*                                                                   */
PUN(2)  CKPTLINE=100,    /* NO. OF CARDS TO PUNCH PER PAGE DOHWNC*/
        CLASS=BK,    /*  OUTPUT CLASS PROCESSED BY PUN  DOHWNC*/
       WS=(W,R,Q,PRM,LIM/F,P)  /* WORK SELECTION CRITERION    DOHWNC*/
/*                                                                   */
RDR(1)  AUTO,            /* RDRNN COMES UP STARTED (DRAIN) DOHWNC*/
        CLASS=A,        /* DEFAULT JOB CLASS              DOHWNC*/
        NOHOLD,         /* JOBS NOT HELD AFTER CONV.(HOLD)DOHWNC*/
        MSGCLASS=A     /* DEFAULT MESSAGE CLASS          DOHWNC*/
                             /* ERRORS ARE COUNTED                   */
                             /*                                      */
/*                                                                   */
SMFDEF   BUFNUM=20,          /* NUMBER OF SMF BUFFERS            DWNC*/
         BUFWARN=80          /* WARNING THRESHOLD %            DOHWNC*/
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    SSI DEFINITIONS                   |
                              |    ADDED IN SP311                    |
                              *--------------------------------------*
                                                                     */
SSI(1)  TRACE=NO            /* SPECIFY WHICH SUBSYSTEM FUNCT  DOHWNC*/
                            /* WHETHER OR NOT TRACING IS      DOHWNC*/
                            /*  ACTIVE FOR THIS SSI FUNCTION        */
/*                                                                   */
STCCLASS TIME=(0010,00),     /* JOB STEP TIME   ...MMMMSS........... */
         REGION=0K,          /* REGION SIZE     .........CCC........ */
         COMMAND=EXECUTE,    /* EXECUTE COMMANDS............R....... */
         BLP=YES,            /* IGNORE BLP PARM .............L...... */
         AUTH=ALL,           /* ALLOW ALL CMDS  ..............AAAA.. */
         MSGLEVEL=(1,1),     /* JOB, ALL MSGS   ..................EF */
         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT         DHWNC*/
         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT         DHWNC*/
         OUTDISP=(HOLD,HOLD),      /* PURGE,HOLD TO HOLD,HOLD        */
         LOG=YES,            /* PRINT JES2 JOB LOG              DHWNC*/
         MSGCLASS=K,         /* DEFAULT MESSAGE CLASS           DHWNC*/
         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB          DHWNC*/
         PERFORM=000,        /* SRM PERFORMANCE GROUP 0         DHWNC*/
         PROCLIB=00,         /* USE //PROC00 DD                 DHWNC*/
         SWA=BELOW,          /* SWA CBS BELOW 16M LINE          DHWNC*/
                             /*     (ADDED BY APAR OY02574)          */
                             /*     (SUPERSEDED BY APAR OY03444)     */
         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS           DHWNC*/
         TYPE26=YES          /* PRODUCE SMF 26 RECORDS          DHWNC*/
/*                                                                   */
/*                             TP (NJE/RJE) CHARACTERISTICS          */
/*    TPDEF    BELOWBUF=(LIMIT=200,SIZE=1152,WARN=80),               */
TPDEF    BELOWBUF=(LIMIT=200,SIZE=3840,WARN=80),
         MBUFSIZE=3840,      /* MULTI-LEAVING BUFFER SIZE       DHWNC*/
         RMTMSG=100,         /* MAX. # MSGS QUEUED TO REMOTE   DOHWNC*/
         SESSION=20,         /* MAX. # SNA SESSIONS             DHWNC*/
         AUTOINTV=120
/*                                                                   */
/*********************************************************************/
TRACE(1)  START=NO           /* SPECIFY WHICH TRACE ID          DOWNC*/
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    $TRACE FACILITY                   |
                              *--------------------------------------*
                                                                     */
TRACEDEF TABLES=3,           /* NUMBER OF TRACE TABLES          DOWNC*/
         PAGES=2,            /* NUMBER OF 4K PAGES PER TABLE     DWNC*/
         TABWARN=80,         /* WARNING THRESHOLD %             DOWNC*/
         ACTIVE=NO,          /* WHETHER OR NOT TO START HE      DOWNC*/
                             /*  TRACE FACILITY                      */
         LOG=(START=NO,      /* WHETHER OR NOT TO FORMAT AND    DOWNC*/
                             /*  ADD DATA TO TRACE LOG DATASET       */
              SIZE=500,      /* MAX SIZE OF TRACE LOG DATASET   DOWNC*/
              CLASS=A)       /* TRACE LOG DATASET OUTPUT CLASS  DOWNC*/
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    TSU DEFAULTS                      |
                              *--------------------------------------*
                                                                     */
TSUCLASS TIME=(1440,00),     /* JOB STEP TIME   ...MMMMSS..........  */
         REGION=0K,          /* REGION SIZE     .........CCC.......  */
         COMMAND=EXECUTE,    /* EXECUTE COMMANDS............R......  */
         BLP=NO,             /* IGNORE BLP PARM .............L.....  */
         AUTH=ALL,           /* ALLOW ALL CMDS  ..............AAAA.  */
         MSGLEVEL=(0,0),     /* JOB, ALL MSGS   ..................EF */
         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT         DHWNC*/
         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT         DHWNC*/
         OUTDISP=(PURGE,HOLD),     /* PURGE,HOLD                     */
         LOG=YES,            /* PRINT JES2 JOB LOG              DHWNC*/
         MSGCLASS=Z,         /* DEFAULT MESSAGE CLASS           DHWNC*/
         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB          DHWNC*/
         PERFORM=000,        /* SRM PERFORMANCE GROUP 0         DHWNC*/
         PROCLIB=00,         /* USE //PROC00 DD                 DHWNC*/
         SWA=BELOW,          /* SWA CBS BELOW 16M LINE          DHWNC*/
                             /*     (ADDED BY APAR OY02574)          */
                             /*     (SUPERSEDED BY APAR OY03444)     */
         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS           DHWNC*/
         TYPE26=YES          /* PRODUCE SMF 26 RECORDS          DHWNC*/
                             /*                                      */
./ ADD NAME=ZJOBNUM  0100-02365-02365-1141-00001-00001-00000-JMILLER
15
./ ADD NAME=ZTSO     0100-02365-02365-1141-00005-00005-00000-JMILLER
//TSO     PROC MBR=TSOKEY00
//STEP1   EXEC PGM=IKTCAS00,TIME=1440
//PARMLIB  DD  DSN=SYS1.RESCUE.PARMLIB(&MBR),DISP=SHR,FREE=CLOSE
//PRINTOUT DD  SYSOUT=*,FREE=CLOSE
//*
./ ADD NAME=ZTSOKEY  0100-02365-02365-1141-00007-00007-00000-JMILLER
USERMAX=10,                                                            +
RECONLIM=3,                                                            +
BUFRSIZE=132,                                                          +
HIBFREXT=6600,                                                         +
LOBFREXT=3300,                                                         +
CHNLEN=4,                                                              +
SCRSIZE=1920
./ ADD NAME=ZVATLST  0100-02365-02365-1141-00002-00002-00000-JMILLER
VATDEF IPLUSE(PRIVATE),SYSUSE(PRIVATE)
RESCUE,1,0,3390    ,Y
