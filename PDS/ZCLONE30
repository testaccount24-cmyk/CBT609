./ ADD NAME=$$$$DOC  0101-10057-10057-1938-00763-00760-00000-COMPJM
---------------------------------------------------------------------
zCLONE System Execs - V3.0
---------------------------------------------------------------------
07/18/2009
John C. Miller
john@jmit.com
---------------------------------------------------------------------
NOTE: See the $$$QUIK member to get started with minimum verbiage.
Read this member for the more verbose instructions.

Please email me with errors that you find or suggestions for improvement
so that I can make this tool more useable.

------------------------------------------------------------------------
                              CONTENTS
------------------------------------------------------------------------

Introduction--what is zClone?....................................1.0
  Modifying the ZCLONE execs.....................................1.1

Using the execs to build a system................................2.0
  Notes on building a system.....................................2.1
  Steps to build a system with these execs.......................2.2

Parameters coded in the @PARMS member............................3.0

Parameters coded in the @DATASET member..........................4.0
  DATASET ALLOC statement........................................4.1
  MEMCOPY statement..............................................4.2


---------------------------------------------------------------------
1.0 - Introduction
---------------------------------------------------------------------

zCLONE started out originally as a set of assembler macros designed to
create a single volume MVS XA rescue system.  The macros were patterned
after the old 2-stage MVS sysgen model.

As MVS/XA evolved into MVS/ESA and then OS/390 and z/OS, it became
increasingly difficult and then impossible to build a single volume
(3390-3) one-pack rescue system with OMVS and all the trimmings.

I subsequently rewrote the code in rexx for greater maintainability, and
expanded the execs to enable cloning systems occupying any number of
volumes.

These execs are designed as a generalized system cloning facility, and
enable one to create an IPLable z/OS system that resides on as many
volumes as desired. This makes zCLONE useful for general z/OS cloning
operations, in addition to building rescue systems.

The exec build a set of batch jobs that when run build a z/OS system
from scratch.  Some PROCs and PARMLIB members are automatically
generated based on the

---------------------------------------------------------------------
1.1 - Modifying the ZCLONE execs
---------------------------------------------------------------------

If you want to tweak, hack, or otherwise modify these execs, by all
means be my guest - but you're on your own.  I've tried to comment
the code sufficiently to give a saavy rexx coder the basic idea of
what's going on. I try to avoid truly ugly, oblique, obscure, or
overly terse ways of doing things in rexx when there's a simpler
way, but I don't shy away from "off the wall" techniques when they
work best (or when I can't figure out a simpler way of doing a
task!)

I've made the execs essentially modular, in that the main exec
ZCLONE calls external subroutines that are named starting with '#'.
Each subroutine generally builds one job, or does one task.  To add
some new functionality of your own design, make a copy of one of the
subroutines like #initvol, for example, and make it do what you
want.  Then add a call to your new module from the ZCLONE member.

---------------------------------------------------------------------
2.0 - Using the execs to build a system
---------------------------------------------------------------------

The process for building a system is to:
1. Customize the @PARMS and @DATASET members;
2. Run the $BUILD job to generate the JCL;
3. Submit the generated batch jobs one at a time to create the new
   system.

You can re-do the above steps over and over until you are happy with
the resulting system.  The execs and the generated batch jobs clean up
after themselves, so you can just start from step 1 as often as needed
without doing anything special.  The only thing you might need to do is
customize and enter the MVS commands in member $CATCLSE to unallocate
and close your catalogs, so that your new catalog volume will come
offline.

You don't have to be an MVS guru to successfully use this set of tools
to build an z/OS system.  Much of the knowlege needed to build an
IPL'able system from the ground up are embedded in the execs.

You do however need to have a fairly solid grounding in z/OS (MVS) in
order to know what the various jobs and piece parts do, and how to get
past inevitable glitches.  Liberal use of the IBM manuals will be of
help.  Study the generated batch jobs to see all the steps involved
in building a z/OS system from the scratch.

DISCLAIMER: You alone are responsible for any success that you have with
this software tool, as well as any damage done to your system, losses
incurred, etc.

I would greatly appreciate any bug reports, and will answer questions
via email, time permitting.

Good Luck, and remember to RTFM (Read The Fine Manuals)

---------------------------------------------------------------------
2.1 - Important Notes:
---------------------------------------------------------------------

            VERY, VERY, EXTRAORDINARILY IMPORTANT NOTES:
      READ THESE NOW, OR BE TRULY AND PROFOUNDLY SORRY LATER:

* Look at the generated jobs *before* running them, especially JOBA,
  the first job.  It is *incredibly* easy to wipe out an existing
  PRODUCTION disk volume with JOBA if you are not careful.  JOBA
  automatically varies a volume offline, and runs ICKDSF to
  initialize it.  You will need to reply to an MVS console prompt
  when JOBA runs. BEFORE replying to this message to continue, DOUBLE
  CHECK the unit address in the message, and be sure it's the disk
  pack that you want to wipe clean and use to build your new z/OS
  system.  Most of the remaining jobs are not as dangerous, but you
  should still review the JCL, and understand what each job is doing.
  (This is good for the soul anyway!)

* I'm making the significant assumption that you basically know what
  you're doing on MVS.

  IN SHORT: If you don't know what a job is going to do, you have
  absolutely no business running it.  First figure out what it's doing.


                       IMPORTANT NOTES:
            READ THESE NOW TO AVOID FRUSTRATION LATER

* The good news, now that I've scared you into being careful, is that
  these execs can take some of the drudgery, tedium, and trial and error
  out of the process of building an zOS system from scratch.

* zOS is not a turnkey system, and these clone execs are NOT, repeat
  NOT completely automatic.  They are simply a tool that can be used to
  greatly assist in building a cloned system.  However:  the parametersq
  as delivered are what I used to build a fully functioning zOS system,
  and so they may be pretty close to what you need, or at least a good
  start!

* Do take some time to carefully review the @PARMS and @DATASET members.
  Don't rush through this part.  Expect to do some tweaking, and expect
  to have to do several system builds before you get a system that IPLs
  and works as expected.

  Once you get the @PARMS and @DATASET members set up the way you
  like, it's very easy to generate a fresh set of jobs, and then run
  the jobs to build a new system.  You'll may even learn something
  about zOS by studying the generated jobs.

* RACF Authority:  See the $$$RACF member of this PDS for RACF
  privileges that are required.

* COMMAND and WAIT programs:  These programs enable the disk unit to be
  varied online and offline by a batch job. If you want this capability
  but don't have these programs on your system already, you can use the
  source in the ZCLONE PDS to assemble them.  Assemble these modules to
  a linklisted APF authorized library.

  The COMMAND program is one that I pulled from the CBT tape.  I added
  code to do a RACHECK against the COMMAND profile in the RACF APPL
  class looking for at least READ access.  This prevents undesirable
  miscreants and other unauthorized individuals from issuing MVS
  commands using this program.

  If you don't want to use the COMMAND and WAIT programs, code a null
  value for COMMANDPGM and WAITPGM in the @PARMS member, or just take
  these parms out altogether.  The JCL generated will then no longer use
  these programs.

---------------------------------------------------------------------
2.2 - Steps to build a z/OS system with these execs
---------------------------------------------------------------------

1)  Edit the @DATASET member to include all the datasets needed to build
    your new zOS system. A sample @DATASET member is provided as an
    example of how to use the zClone execs.  This @DATASET member is the
    one I used to create a zOS 1.8 two pack system.  Your mileage may
    vary, and you will need to be sure that all needed datasets are
    included.  The @DATASET member contains documentation on how to code
    the various values.

2)  Edit the @PARMS member with the values that you want.  The @PARMS
    member is delivered with an example set of parms that were actually
    used to successfully build a two pack rescue system. You will want
    to change some of the parameters.  The @PARMS member contains
    comments describing the various values.

3)  Customize the $BUILD job:
    - Make sure the jobcard is valid.
    - Change the SYSPROC DD statement to point to the ZCLONE
      distribution PDS.
    - Change the INPDS parameter near the bottom of the JCL to likewise
      reflect the ZCLONE distribution pds (i.e. the pds containing the
      zClone execs).
    - Change the OUTPDS parameter near the bottom of the JCL to reflect
      the name of an empty PDS that you have allocated to contain the
      JCL and other members generated by the zClone execs.

4)  Now submit the job in $BUILD, and the necessary jobs and members
    will now be built and stored into the output PDS that you specified
    in the OUTPDS parameter in the $BUILD job. The jobs will be named
    sequentially JOBA..JOBn, where n is however many jobs end up getting
    generated.

   *****************************************************************
  *******************************************************************
  *** NOTE: Up until this point, nothing has been been changed on ***
  **  either the driving system or the new cloned system.  The     **
  **  steps below this box will start tweaking and building.       **
  **  If all goes as expected, the only changes made to the        **
  **  driving system are:                                          **
  **  a. The driving system mastercat will have an alias defined   **
  **     pointing to the cloned system mastercat.                  **
  **  b. The driving system mastercat will have the clone system   **
  **     master catalog connected as a usercat.                    **
  **  c. RACF Profile TSOZCLO in TSOPROC class will be defined.    **
  **  d. RACF ID $ZCLONE and group $STC will be defined.           **
  **                                                               **
  **     THAT SHOULD BE IT.  ANYTHING ELSE WAS NOT INTENDED,       **
  **     AND SHOULD BE DONE AT YOUR OWN RISK!!!                    **
  **     (Did I mention that you should review each job            **
  ***    before it is run?  Well, please do.)                     ***
  *******************************************************************
   *****************************************************************

5)  Run all the jobs (JOBA - JOBx).  Again -- reviewing and
    understanding the jobs *before* you run them would be, as they
    say, "a good thing."   It's possible that you could have coded
    values in @PARMS and @DATASET such that the generated jobs could
    damage your system -- so make sure each job does what you are
    expecting.

    Investigate any job steps that complete with return code 8 or
    greater.  Return code 4 and 0 are fine.

6)  You will need to fix the ATCCON and ATCSTR members of VTAMLST, and
    also be sure that the necessary VTAMLST members are available on
    your cloned system.  Use COPY statements in the @DATASET member to
    specify members to copy.  You may want to code a special set of
    trimmed down VTAM parms in a private PDS, and copy them into VTAMLST
    and VTAMLIB using COPY statements.

7)  Review PARMLIB.  SYS1.ZCLONE.PARMLIB is first in the PARMLIB concat,
    followed by whatever other PARMLIBS are coded in @DATASET with the
    'PARMLIB' attribute: ,,(PARMLIB).  Parmlib members are built for you
    and copied to SYS1.ZCLONE.PARMLIB as follows:

    BPXPRM00 - OMVS parmlib member that contains generated MOUNT stmts
               for all OMVS libraries specified in the @DATASET member.
    COUPLE00 - COUPLExx member generated to reflect couple datasets
               defined in @DATASET.
    IEASYS00 - Main parmlib member is copied from the zClone library
               member ZIEASYS, and then updated with PAGE=, LOGREC=,
               and SYSNAME= parameters.
    IGDSMS00 - SMS parms built from ZIGDSMS and ACDS/COMMDS statements
               built dynamically.
    JES2PARM - JES2 parms. Member ZJES2PARM in the ZCLONE distribution
               PDS is combined with dynamically built SPOOLDEF and
               CKPTDEF statements, and then copied to the JES2PARM
               member in SYS1.ZCLONE.PARMLIB.  Review ZJES2PRM for any
               changes you want to make *before* building the ZCLONE
               jobs.  The SPOOLDEF and CKPTDEF are already coded for
               you, but you may want to change some of the other
               parameters, or replace the entire ZJES2PRM member with
               your own JES2 parms.  If you do this, be sure to remove
               the SPOOLDEF and CKPTDEF statements from the source that
               you place in ZJES2PARM, since these two statements are
               coded for you automatically.

    MSTJCL01 - Master JCL.  Includes all PROCLIBS coded in @DATASET with
               the "JES2" attribute.
    PROGA0   - APF authorized libraries (Coded in @DATASET with APF)
    PROGL0   - Linklist libraries (Coded in @DATASET with LNK)
    VATLST00 - A basic VATLST PARMLIB member is generated.

    NOTE: You'll need to be sure that one of the PARMLIB's that you're
    copying to the cloned system has the remainder of the members needed
    as coded in SYS1.ZCLONE.PARMLIB(IEASYS00)'. Your production PARMLIB
    dataset will probably work fine.

8)  Review PROCLIB.  SYS1.ZCLONE.PROCLIB is first in the PROCLIB
    concat, followed by whatever other PROCLIBs are coded in
    @DATASET with the "JES2" attribute: ,,(JES2).  Started procedures
    (PROCS) are built for you and copied to SYS1.cloned.PROCLIB as
    follows:
    TSO      - TSO started PROC.
    VTAM     - VTAM started PROC.  Includes libraries in the VTAMLST and
               VTAMLIB concatenation that you coded in @DATASET with the
               'VTAMLST' and 'VTAMLIB' attribute respectively.
    JES2     - JES2 Startup PROC.  Includes libraries in the PROC00
               concatenation that you coded in @DATASET with the 'JES2'
               attribute.
    TSORES   - TSO LOGON PROC. The name of this LOGON PROC is set in the
               @PARMS member with the "TSOPROC = " parameter.  This
               dynamically generated PROC includes libraries defined in
               @DATASET with attributes:  ISPPLIB, ISPMLIB, ISPSLIB,
               ISPTLIB, ISPLLIB, SYSPROC, SYSUADS.

9)  Review IPLPARM.  SYS1.IPLPARM on the cloned volume has member LOAD00
    built from the parameters you specified.  PARMLIB statements are
    included for libraries in the @DATASET member coded with the
    'PARMLIB' attribute.

   *****************************************************************
  *******************************************************************
  ***  If everything was defined right, you should now have an    ***
  **   IPL'able z/OS system.  The steps below are some areas that  **
  **   should be checked before trying to IPL.  You don't have to  **
  **   do these things now, but you'll probably save yourself      **
  ***  some IPLs if you do check them first.                      ***
  *******************************************************************
   *****************************************************************

10) IPL the new system, and see what happens.  Hopefully you'll be close
    to having a working system.  If it works the first time--you rock!


---------------------------------------------------------------------
3.0 - Parameters coded in the @PARMS member.
---------------------------------------------------------------------

The @PARMS member of the ZCLONE distribution PDS is the heart of the
definitions used to build the cloned system.  You can name this member
whatever you want, just be sure specify this member name in the PARMS()
parameter in the $BUILD job.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
User variables:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   You may find it useful to define your own variables.  Any variables
   that you define in the @PARMS member can be subsequently used in the
   @PARMS member, and in the @DATASET member.  Items like VOLSERs, and
   dataset names or qualifiers can be defined and later referred to.

   For example, you may want to add a qualifier to one or more datasets
   to identify the system that you are building.  Let's say you are
   planning to build several system images, each with a unique name.  To
   simplify the process, you could define a variable called "SYSTM" and
   give it a value.  e.g. in the @PARMS member, you would code:

   SYSTM = CLONE01

   and then in the @DATASET member you could then code such entries as:

   DATASET ALLOC DSN(PAGE.&SYSTM.PLPA) -
           VOLUME(&PAGVL1) SPACE(CYL,(200)) PARM(PGPLPA)

   DATASET ALLOC DSN(PAGE.&SYSTM.LOCAL1) -
           VOLUME(&PAGVL1) SPACE(CYL,(200)) PARM(PGPLPA)

   Any variables that you define should:
   - Start with an alpha character  (no special characters)
   - NOT start with "z"
   - Contain only characters and numbers.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Jobcard info:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   JOBCARD1 through JOBCARDn are used as the model Jobcard for all
   generated jobs.  Each jobname is created by appending one character
   onto the jobname that you code.  e.g.  using the jobcard example
   below, the actual generated jobnames would be TSOJCMA, TSOJCMB, etc.

   Whatever you code in the COMMENT parm will be added to the comments
   in each job.  Comments are currently limited to what you can fit on
   one line.

   e.g.:

   JOBCARD1   = //TSOJCM  JOB (990030,135,60,100),JMILLER,CLASS=A,
   JOBCARD2   = //   NOTIFY=TSOJCM,MSGCLASS=X,REGION=6M
   JOBCARD3   = /*JOBPARM LINES=999999
   COMMENT    = John C. Miller

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@DATASET:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

   @DATASET specifies the member name of the ZCLONE distribition PDS
   that contains your dataset copy and allocation definitions.  If
   omitted, this parm defaults to @DATASET.

   e.g.:

   @DATASET   = @DATATS1

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
USESYM:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

   USESYM = YES means that indirect volume addressing will be used for
   NONVSAM datasets. &SYSR2-&SYSRn will be defined, since &SYSR1 is
   reserved, and already defined by z/OS.

   Note:  Some datasets can be defined with indirect volsers, but should
   not be defined this way because doing do will cause the IPL to fail,
   e.g.  PARMLIBs, and PROCLIBS in Master JCL.  To prevent a specific
   dataset from being cataloged with an indirect volser, code
   PARM(NOSYM) on the DATASET COPY or ALLOC statement in the @DATASET
   member.  This will cause that dataset to be cataloged with the actual
   volser rather than a symbolic.

   e.g.:

   USESYM     = YES                    /* Use indirect volsers.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
VALIDPARMS:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  Set VALIDPARMS to NO if you want to bypass validation checking
  for the @PARMS and @DATASET members.  This may be useful if you
  are using the execs just to generate JCL for certain parts of the
  system build process, and don't care about having an IPL'able
  system.  If set to YES, the execs do some validity checking of
  @PARMS and @DATASET values, check to see if source datasets
  exist, and check to see that certain key system datasets have
  been defined.

  e.g.:

  VALIDPARMS = YES                    /* Validate parms and datasets.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TSOPROC:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   This is optional.  If coded, the ZCLONE execs will construct a TSO
   PROC by this name.  If coded, this TSO PROC should not exist on the
   driving system.  The TSO PROC is built using datasets that you
   defined in @DATASET as ISPF, SYSPROC, or SYSEXEC libraries.

   If you already have a TSOPROC that you know will work,
   then you can leave the TSOPROC value blank.

   e.g.:

   TSOPROC    = TSO911                  /* TSOPROC to be built.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TSOPROC:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Define TSO userids that you want on the new system.  As many TSO ids
   as desired can be specified here.  If the system you are cloning
   already has all the TSO USERIDS that you need, then you can leave
   TSOIDx blank.

   e.g.:
   TSOID1     = TSO001
   TSOID2     = TSO002
   TSOID3     = TSOTST

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
DEVTYPE:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Defines the device type of the DASD that will contain the new
   system.  This applies to all target volumes.

   e.g.:

   DEVTYPE    = 3390                  /* Device type of target volumes.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
VOLSERx  and ADDRx:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Define the VOLSERs of that will contain the new system.  You must
   specify at least VOLSER1 and ADDR1.  You can specify up to 99
   VOLSERx/ADDRx pairs for up to 99 target volumes.  Each VOLSERx coded
   must have a correspoding ADDRx parm coded, and vice-versa.

   e.g.:
   VOLSER1    = Z8RES1
   VOLSER2    = Z8RES2
   ADDR1      = 5001
   ADDR2      = 5002

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Optional volume aliases:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Optional volume aliases.  This is an example of using user
   defined variables.  This allows us to use logical volume names
   as the target for datasets, rather than the actual volser.  For
   example, below we are defining CATVOL, JUNKVOL, and USERVOL as
   logical names all pointing to one actual volser.  In the
   @DATASET member, we can then specify VOL(&CATVOL) for example,
   to refer this volser, instead of hard-coding the volser.  This
   allows us to logically group datasets without tying them
   directly to volsers.  At some point we might want to change
   which volume the datasets go to that are defined with
   VOL(&CATVOL).  We can do this my changing one parm here,
   instead of potentially many parms in the @DATASET member.  Of
   course, you can avoid all this, and just code VOL(&VOLSERn) in
   the @DATASET member if you want to keep it simple.

   e.g.:

   SYSR1      = &VOLSER1                /* Volume alias.
   SYSR2      = &VOLSER2                /* Volume alias.
   HFSVOL     = &VOLSER2                /* Volume alias.
   CATVOL     = &VOLSER3                /* Volume alias.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
WORKVOL:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Work space for building the new system.  Not needed if you have
   plenty of PUBLIC mounted disk.  No data is permanently left on this
   volume.

   e.g.:

   WORKVOL    = Z18T01                  /* Volser for large work files.

*-------------------------------------------------------------------*
* IOCONFIGID - Use HCD to be sure this value is defined as a valid  *
* IOCONFIG ID in the IODF dataset that you specify.  This value is  *
* inserted in the SYS1.IPLPARM(LOADxx) member.                      *
* SMFID is the new SMF id to be assigned to the new system.         *
*-------------------------------------------------------------------*
 IOCONFIGID = UCRPROD                 /* 8 char IO config ID for LOADxx
 SMFID      = UCRP                    /* 4 char SMF id for new system.

*-------------------------------------------------------------------*
* OLDMCAT - Old master catalog name (mastercat of driving system)   *
*-------------------------------------------------------------------*
 OLDMCAT    = CATALOG.Z18T.MASTER     /* Driving sys master cat.

*-------------------------------------------------------------------*
* New catalogs: New mastercat and optionally a new usercatalog.     *
* Both the master catalog and the user catalog can have an SSA      *
* specified for them.  The SSA is a prefix that is pre-pended to    *
* each dataset name.  This does two things:  1) It provides an easy *
* way to force dataset entries to be cataloged in the desired cat,  *
* and 2) it prevents ENQ issues with allocated datasets on the      *
* driving system.  Datasets are renamed back to the desired names   *
* (Without the SSA on front) as part of the system build process.   *
*-------------------------------------------------------------------*
 NEWMCAT    = CATALOG.MST18P          /* New sys. mastercat name.
 NEWMCATVOL = &CATVOL                 /* New sys. mastercat vol.
 SSA        = SYSZC.                  /* Temp. dsn prefix.

 NEWUCAT    = CATALOG.SYS18P          /* New sys. usercat name.
 NEWUCATVOL = &CATVOL                 /* New sys. usercat vol.
 SSAU       = SYSUC.                  /* Temp DSN prefix.
 UCATALIAS1 = SMS

 SYSRES     = Z18RS1                  /* Driving sys sysres volume.
 COMMANDPGM = COMMAND                 /* "COMMAND" pgm is available.
 WAITPGM    = WAIT                    /* "WAIT" pgm is available.

*-------------------------------------------------------------------*
* JES2 Parms.  A SPOOLDEF and CKPTDEF entry will be added to the    *
* ZJES2PRM member to create a final JES2PARM member.  You must      *
* define a SPOOL and at least one CKPT dataset in the @DATASET      *
* member.  The CKPT dataset(s) should have the parm of HASPCKPT,    *
* and the spool dataset should have the parm HASPACE.               *
* SPOOLPRF is the length of the SPOOLDEF VOLUME= parm.  If it is    *
* set to 4, for example, and the volser where the spool dataset is  *
* allocated is RESCUE, then the SPOOLDEF VOLUME=RESC is coded.      *
*-------------------------------------------------------------------*
 SPOOLPRF   = 5                       /* Length of SPOOLDEF prefix.

*-------------------------------------------------------------------*
* RACF Parms.                                                       *
* Note: Some of the RACF actions require RACF SPECIAL to perform.   *
* Any TSO ID can run the RESCUE execs, but the RACF ID used to run  *
* the resulting jobs will need RACF SPECIAL, or specific privileges *
* for various RACF operations (CLAUTH, etc.)                        *
*-------------------------------------------------------------------*
*-------------------------------------------------------------------*
* RFSTCx: Defines STCs for ICHRIN03 started task table.             *
* p1 = Task name, p2 = RACF ID, p3 = RACF group.                    *
* Each task defined will have privileged bit set on, so these tasks *
* should be able to bypass most RACF Access checking.  Commands     *
* for creating the specified IDs and Groups will be generated only  *
* if the IDs/groups DO NOT already exist.                           *
*-------------------------------------------------------------------*
 RFDSNT     = NO                      /* Create RACF ICHRDSNT
 RFSTC      = NO                      /* Create RACF ICHRIN03
 RFTSOPROC  = NO                      /* Define TSOPROC to TSOPROC class

Started task support:
  If entries are defined below, then an ICHRIN03 module will be built
  with these entries.  An MLPA entry for this ICHRIN03 will be placed
  in IEALPA00.  Format of RFSTCx is:  RFSTCx = stcname, racfid,
  racfgrp All three parms are required.  This option may be most
  useful when building a single pack rescue system.  You may want to
  comment out or delete these statements if the profiles in your RACF
  STARTED class or in your existing ICHRIN03 module are sufficient for
  your needs.

*RFSTC1     = RACF,    $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC2     = JES2,    $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC3     = VTAM,    $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC4     = TSO,     $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC5     = TCPIP,   $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC6     = OMVS,    $RESCUE, $STC  /* STCs to go in ICHRIN03

SYSPLEX     = UCRP     /* Name of this sysplex

---------------------------------------------------------------------
4.0 - Parameters coded in the @@DATASET member.
---------------------------------------------------------------------

The @DATASET member refers to the member containing the dataset
definitions for the system being clones.  The actual member name
is determined by the "@DATASET = " parm in the @PARMS member, or
whatever parms member you are using.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4.1 - DATASET:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

The DATASET verb defines a dataset to be copied to the new system,
or a dataset to be allocated only for the new system.

DATASET COPY  parameters - Copy a dataset using parameters.

DATASET ALLOC parameters - Allocate a new dataset using parameters.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4.1.1 - Value for PARM() on DATASET Statements:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

   HASPACE  - The dataset is a JES2 spool dataset, and is defined in
              JES2PARMS in the SPOOLDEF statement.

   HASPCKPT - The dataset is a JES2 checkpoint dataset, and is specified
              in JES2PARMS.

   SYSUADS  - The dataset is the UADS dataset, and a SYNC operation is
              done on this dataset.

   SYSLBC   - The dataset is the BRODCAST dataset and is initialized.

   ISPPLIB  - ISPF panel lib to be added to ISPPLIB concat in the
              TSOPROC created (if any) for the new system.

   ISPMLIB  - ISPF panel lib to be added to ISPMLIB concat in the
              TSOPROC created (if any) for the new system.

   ISPSLIB  - ISPF panel lib to be added to ISPSLIB concat in the
              TSOPROC created (if any) for the new system.

   ISPTLIB  - ISPF panel lib to be added to ISPTLIB concat in the
              TSOPROC created (if any) for the new system.

   SYSPROC  - ISPF panel lib to be added to SYSPROC concat in the
              TSOPROC created (if any) for the new system.

   VTAMLST  - Lib to be included in VTAMLST concatention in the VTAM
              started procedure.

   VTAMLIB  - Lib to be included in VTAMLIB concatention in the VTAM
              started procedure.

   APF      - Load lib to be APF authorized.

   LNK      - Load lib to be added to LNKLSTxx.

   LPA      - Load lib to be added to LPALSTxx.

   ACDS     - Dataset is the SMS ACDS.

   COMMDS   - Dataset is the SMS COMMDS.

- RLSE      Space should be released after copy.
- SMF       MANx VSAM file tb formatted as SMF dataset.

The following should be coded once and only once, and are used
by the ZCLONE execs to build various system components.
- ZLINKLIB  Dataset is the ZCLONE utility LINKLIB.
- ZPROCLIB  Dataset is the ZCLONE utility PROCLIB.
- ZPARMLIB  Dataset is the ZCLONE utility PARMLIB.
- ZSYSPROC  Dataset is the ZCLONE utility SYSPROC (clist) lib.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4.1.1 - DATASET ALLOC Statement
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Example:

   DATASET ALLOC DSN(SYS1.PRD99.MACLIB) MODEL(SYS1.MACLIB) -
      SPACE(CYL,(100,,75))

   Parameters:
   -----------

   DSN(datatsetname)

      Name of dataset being cloned.  For DATASET ALLOC operations,
      DSN defines the name of the dataset on the new system.

   MODEL(modeldsn)

      Creates the new dataset with the same DCB parameters as the
      specified model dataset.

   VOL(volser)

      A literal value can be specified for volser, but it is recommended
      that you use variables for volser.  You can either specify VOLSERn
      or some other user variable that resolves to a valid volser.

   SPACE(spaceparms)

      Only used for DATASET ALLOC operations.  Code the spaceparms value
      the same way you would code SPACE=() on a JCL card.

      e.g.:

      SPACE(CYL,(150))

   PARM(usageparms)

      Usage parameters for this dataset.  The values specified in
      PARM() determine what additional processing is done for the
      dataset.  See the section below on DATASET PARMS

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4.2 - MEMCOPY Statement
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
The MEMCOPY verb allows you to specify a member that you want copied
from one PDS to another, optionally with a new name.  The parameters
accepted on the MEMCOPY statement are:

- IN:   The input PDS, where the desired member resides.  This can be
        any of the following:
        - A static member that you create in your own PDS;
        - The ZCLONE main exec PDS--for this code: IN(&IPDS)
        - The ZCLONE output PDS where certain dynamic members are built,
          in which case you would code: IN(&OPDS)

        The actual dataset name can be partly or wholly made up of
        symbolic variables, as the zClone execs do a basic level of
        symbolic substitution for you.  For example, let's say you have
        a PARMLIB member from a running system that you want to copy
        to the new system you are building.  if you code the following
        statement in the @PARMS member:

        SYSNAM = RESC01

        Then you might use the &SYSNAM variable in defining dataset
        names in the IN and OUT parms of MEMCOPY, like this:

        MEMCOPY IN(SYS1.&SYSNAM.PARMLIB) OUT(SYS1.PARMLIB) M(LNKLST00)        00

        You can use any symbolic variables defined in the @PARMS
        member.

- OUT:  The output PDS where the member will be copied.  The same
        principles for the IN parm apply to the OUT parm.

./ ADD NAME=$$$BUGS
- The syntax checking of the @DATASET member is not very robust.  So if
  for example you leave an extra continuation character on the end of a
  DATASET statement, you'll get a generic IKJ error message on the PARSE
  statement, which is not very helpful.  If this happens you will need
  to scan the @DATASET member manually, and look for stuff like that.
  This is the main typo sort of error that I've found to be a problem.
  Improved syntax checking is on the drawing board but don't hold your
  breath.

./ ADD NAME=$$$IDX   0100-10057-10057-1930-00053-00053-00000-COMPJM
Index of members:

Members starting with "#" are rexx subroutines.
Members starting with "Z" model members used by the ZCLONE execs.
"Z" members may need some modification based on local requirements.
Members starting with "@" are input parms that you need to code.

$$$DOC   - The documentation for the ZCLONE execs, such as it is.
$$$IDX   - This member.
$$$MISC  - Miscellaneous explanations, etc.
$$$QUIK  - Quickstart for the impatient - Better know what you're doin.
$$$RACF  - Info on RACF authority that you'll need to run the jobs.
$$$SARES - Info on building standalone restore tapes.  Helpful.
$BUILD   - Batch job to run ZCLONE system build.
$CATCLSE - Commands to unallocate and close ICF catalogs.
$SAREST  - Job to build a standalone RESCUE system restore tape.
#ALCNVSM - Build JCL to allocate nonVSAM datasets.
#ALTNVSM - Build JCL to remove System Secific Alias (SSA) (i.e. SYSX.)
#COPYDS  - Build JCL to copy datasets.
#COPYMEM - Build JCL to copy members specified in @DATASET member.
#DEFMCAT - Build JCL to define the master catalog.
#DEFNVSM - Build JCL to define nonVSAM catalog entries.
#DEFVSAM - Build JCL to define VSAM files: STGINDEX, PAGE, SMF, etc.
#INITVOL - Build JCL to ICKDSF init the cloned sysres volume.
#MEMBERS - Build assorted members, and store them in this PDS.
#RFCOPY  - Build JCL to copy the RACF dataset.
@DATASET - Place where all the target system datasets are defined.
@PARMS   - Main setup member that defines how system will be built.
COMMAND  - "COMMAND" src - Issues MVS console commands, RACF secured.
ZCLONE   - The main exec that is run to build all the JCL and members.
WAIT     - "WAIT" assembler source.  Optional but may be helpful.
ZBPXPRM  - OMVS PARMLIB member.  MOUNT statments are added to this mem.
ZCOUPLE  - XCF parmlib member.  Set to sysplex local, change if desired.
ZIEALPA  - IEALPA00 PARMLIB member source.  Updated by execs.
ZIEASYS  - IEASYS00 PARMLIB member.
ZJES2PRM - Partial JES2PARM member.  Modify if desired.
ZJOBNUM  - Work member - Last job number used.  Leave this alone.

Members that get built and stored in the output PDS (OUTPDS in $BUILD)
when the ZCLONE exec is run:

BPXPRM00 - OMVS parms.
COUPLE00 - XCF parms.
IGDSMS00 - SMS parms.
JES2     - JES2 started procedure.
JES2PARM - JES2 parameter deck.
JOBn     - Jobs that do the actual build of the cloned system.
LOAD00   - IPLPARM LOAD00 member.
MSTJCL01 - Master JCL PARMLIB member.
PROGA0   - PROG PARMLIB member with APF statements.
PROGL0   - PROG PARMLIB member with LNKLST statements.
TSORESC  - TSO LOGON procedure.
VTAM     - VTAM started procedure.
./ ADD NAME=$$$MISC  0100-10057-10057-1916-00078-00078-00000-COMPJM
---------------------------------------------------------------------
ZCLONE System Execs - Notes, explanations, etc.
---------------------------------------------------------------------

---------------------------------------------------------------------
SSA
---------------------------------------------------------------------
Explanation:
System Specific Aliases is a technique that has been used for many
moons by the IBM MVS software delivery groups.  An alias is defined in
the driving system master catalog that points to the new system
mastercat.  Any dataset names that might conflict with live datasets
are defined with an extra prefix (the "SSA") not found on the driving
system.  This accomplishes 2 desirable outcomes:

1) All catalog entries for cloned system datasets are created in the
cloned system master catalog, where we want them. This avoids junk in
the driving system master catalog or user catalogs.

2) Cloned system datasets remain cataloged to the driving system until
the jobs are done manipulating them. This approach avoids the use of
STEPCAT DD statements, which as of z/OS 1.7 no longer work.

---------------------------------------------------------------------
XCF
---------------------------------------------------------------------
For the sake of simplicity and stand-alone-ness, the cloned system
gets built configured for sysplex-local. If I get ambitious I may
add support at some point for building parallel sysplex images.

---------------------------------------------------------------------
RACF Started Task Table
---------------------------------------------------------------------
Explanation:  I use a RACF started task module ICHRIN03 instead of
using profiles in the RACF STARTED class, which would be much
more cool.  I take this approach to minimize changes to the driving
system.

1) The RACF DS on the cloned system is a copy of the one on the driving
   system.  Therefore, before copying the RACFDS from the driving
   system, any needed RACF tweaking has to be done to the driving
   system's RACF environment. I prefer to minimize any changes to the
   driving systems RACF environment.  I basically add a RACF ID and a
   RACF group, and don't activate any classes, etc.  You just need to
   pick a USERID and GROUP name that don't already exist.  If you pick
   a USERID or GROUP that do already exist on the driving system, the
   generated jobs will contain whining messages to this effect.

2) Messing with the STARTED class on the driving system (Which you may
   or may not even be using) can have some unexpected and unpleasant
   consequences, and may result in the driving system becoming
   non-IPLable.  I prefer to not go there.

---------------------------------------------------------------------
TCP/IP
---------------------------------------------------------------------
TCP/IP will probably need some work by you before you can telnet in
and log on to your new cloned system.

The ZCLONE execs handle some of the required TCP/IP setup like the
started task table entry for TCPIP, a RACF ID defined with a UID0 OMVS
segment, OMVS datasets being defined in the BPXPRM00 parmlib member,
and maybe some other stuff that I've programmed in but forgotten.

You'll need to be sure that the necessary PROCS and parameteter
members are set up right for your shop.  This is a non-trivial task,
and I have not yet risen to the task of completely automating this part.
It should be a fairly simple task to copy over these elements as-is from
your production system, and make a few changes for things like the IP
address and domain name, and the hardware interface.

---------------------------------------------------------------------
MSTJCL01
---------------------------------------------------------------------
I name the master JCL member with the "01" suffix to prevent the master
scheduler from starting using any master JCL that might be laying about
in SYS1.LINKLIB(MSTJCL00) This way I can be reasonably sure that my
master JCL member is the one used.
./ ADD NAME=$$$QUIK
---------------------------------------------------------------------
ZCLONE System Execs - Quick Start
---------------------------------------------------------------------
Ok, so you're like me -- impatient, and don't want to read through all
the dumb comments, disclaimers, etc.  Here's the $.50 version of how to
use the ZCLONE execs to build a one-pack RESCUE system.

1)  You should have the zClone execs in one PDS.  Create a second empty
    PDS (LRECL=80, BLKSIZE=whatever) to contain the generated JCL.  The
    PDS containing the zClone execs needs to be coded in the $BUILD
    member on the INPDS paramter, and the empty output PDS that you
    created should be specified in $BUILD in the OUTPDS parameter.

2)  Edit the @DATASET member to include all the datasets needed to build
    your system.  The @DATASET member is delivered with the exact
    configuration of datasets that I used to create a z/OS 1.8 one pack
    rescue system.  Your mileage may vary, and you will need to be sure
    that all needed datasets are included.

3)  Edit the @PARMS member with the values that you want.  The @PARMS
    member is delivered with an example set of parms that were actually
    used to successfully build a one pack z/OS 1.8 system. You will
    need to change a lot of these values, especially the ones that
    describe your driving system.

4)  Use the $BUILD job to run the ZCLONE build execs under batch TSO.
    Fix the jobcard and PDS name (SYSPROC DD stmt) first.

5)  Run all the jobs (JOBA - JOBx).  Again, reviewing and understanding
    the jobs before you run them would be, as they say, "good."
    Investigate any steps that are return code 8 or greater.

    If you're really hot, you'll have an IPL'able system on the first
    try.  If you're like me, then you'll need a few iterations to get
    it right, to fix such things as:

    a. VTAMLST members that reflect your local config.  Tweak the
    @DATASET member to auto copy members like these over.

    b. Assorted PARMLIB members missing.
    c. Some off the wall LINKLIB that was missed somehow.
    d. You name it.

    Have Fun!
./ ADD NAME=$$$RACF
---------------------------------------------------------------------
ACF2
---------------------------------------------------------------------
If your system uses ACF2, then you will need to make some adaptations,
mainly to the jobs for replicating the ACF2 database, and the security
commands used to set up the TSO userids.

---------------------------------------------------------------------
RACF Started Task Table versus STARTED class.
---------------------------------------------------------------------
The ZCLONE execs as shipped create a basic ICHRIN03 started task table
module that will be sufficient to IPL the new system.  This approach is
taken because it requires fewer changes to the RACF dataset on the
driving system.  Once the new system is up, you can adjust the profiles
in the STARTED class, and get rid of the ICHRIN03 module.

If you prefer, you can copy your own custom ICHRIN03 module from an
existing linklib to the new system's SYS1.LINKLIB by changing the
MEMCOPY statement in the @DATASET member that copies ICHRIN03.

---------------------------------------------------------------------
RACF authority needed:
---------------------------------------------------------------------
Below are some requirements for RACF authority that you'll need
to run the jobs generated by the ZCLONE execs.  You don't need
these permissions to runs the execs which generate the JCL and
other members for the cloned system, but you will need them to actually
run some of the jobs.

---------------------------------------------------------------------
RACF privileges needed:
---------------------------------------------------------------------
RACF SPECIAL is needed to run the IRRUT400 job, which locks the
production RACF dataset, and creates a copy.  If your ID does not have
the RACF SPECIAL attribute, extra warning notes will be included in the
jobs that are generated, indicating that RACF SPECIAL is needed to run
those jobs.

---------------------------------------------------------------------
RACF Facility profiles to which you will need at least ALTER access:
---------------------------------------------------------------------
STGADMIN.ADR.COPY.BYPASSACS
STGADMIN.ADR.COPY.PROCESS.SYS
STGADMIN.ADR.DUMP.TOLERATE.ENQF
STGADMIN.ADR.RESTORE.BYPASSACS
STGADMIN.ADR.RESTORE.TOLERATE.ENQF

You may want to define a generic FACILITY profile such as would be
defined by the commands below, and getting ALTER access to it.

   RDEFINE FACILITY STGADMIN.ADR.** UACC(NONE)
   PERMIT  STGADMIN.ADR.** CLASS(FACILITY) ID(yourid) ACCESS(ALTER)
   SETROPTS RACLIST(FACILITY) REFRESH
./ ADD NAME=$$$SARES
------------------------------------------------------------------*
Standalone Rescue Tapes ($SAREST)
------------------------------------------------------------------*
A rescue z/OS system can be a lifesaver.  The $SAREST job creates
an IPL tape that allows you to restore a z/OS rescue system for
disaster recovery purposes.

Run this job after you have a working RESCUE system built, and to
which you can log on to TSO and do useful tasks.  It will create a
set of tapes that you can use if you ever get completely hosed--i.e.
your system is flat on its back, and you have no system that you can
bring up to make repairs. I have been in this very situation, and I
can tell you that it is *immensely* satisfying to be able to resort
to the procedure described herein, and pull a rabbit out of a hat,
so to speak.

I suggest that you call the tapes created by this job RESCU1 -
RESCUn, and put a stick on label on each tape with the volser
written on it.  Since these tapes are non-labelled, the system
will not keep them straight for you!

Another very important suggestion: Before creating these tapes,
change the RACF password for the TSO ID you will be using to some
new value, and PHYSICALLY WRITE THIS DOWN on the first of the
tapes.  The RACF password that you were using when you created
the RESCUE system dump tapes will likely be long forgotten by the
time you get around to using them.  If you can't log on to TSO,
your RESCUE system will be worthless.  Some sysprogs will copy
the production RACF dataset to their RESCUE packs as part of a
weekly maintenance job.  DON'T DO THIS!  If your RACF dataset
happens to get damaged, then your RESCUE system gets damaged too.
Get the RESCUE system up and working, and then leave it alone.
It should not be touched unless you really need to, such as if
the IO configuration changes, and you need to update the IODF
file to reflect the new devices.

------------------------------------------------------------------*
Example of using the stand alone RESCUE restore tape:
------------------------------------------------------------------*
You would only use this in the event that you could not IPL a
workable z/OS system, and had to restore the rescue system. If you
have a working z/OS system, you can log on and do a normal DFDSS
batch RESTORE job using these tapes.  (In this example, the disk
drive is unit 120, the tape is 380)
------------------------------------------------------------------*
 1) Mount the first tape written on the tape drive 380.
 2) At the HMC set the IPL address to 380.  If you don't have an
    HMC, then set the IPL address according to your particular CPU.
 3) Perform an IPL (LOAD CLEAR)
    If IPLing from a VM Virtual Machine, use the CP command: IPL 380
 4) From any attached local terminal hit the Enter key. You should be
    prompted to hit CLEAR when the program is ready to go. Do so.
 5) Specify CONSOLE for the input device.
 6) Specify CONSOLE for the output device.
 7) Enter the restore command:
       RESTORE FROMDEV(3400) FROMADDR(380) TOADDR(120) NOVFY
 8) Reply Y when prompted to restore the volume.  Make sure it's the
    right disk unit, or you may destroy some live data.
 9) Keep mounting tapes until they have all been read.
10) Change the IPL address to 120, and IPL again. You're (hopefully) up.
11) Log on to TSO, and save the day.

Note: If the RESCUE pack was built on a different system from the one
on which it is being restored, then you may need to make certain changes
to the restored system before it is IPLable:
- IODF devices definitions and NIPCONS definitions
- SYS1.PARMLIB(CONSOLxx)
- SYS1.VTAMLST local VTAM terminal definitions.
- SYS1.IPLPARM(LOADxx) system name must match and IODF system name.
Ideally these items should be addressed before the RESCUE system is
dumped to tape.  Otherwise the system will be unusable until the above
items are fixed.

OR - If you are really in a bind, (and you are running a zSeries box
with ICC) and you know the IODF on the RESCUE system doesn't match the
IOCDS of the processor, and the VTAMLST and CONSOLxx members won't work,
you are in for a bit of hassle, but you can still use a RESCUE system:

- From the Service Element create a bare bones IOCDS that includes the
  addresses for all the connected DASD that you care about, and also
  the addresses for any MVS consoles and VTAM terminals you plan to use
  on the RESCUE system.  POR with this IOCDS.
- Modify some of the ICC definitions to match your CONSOLxx and VTAMLST
  local terminal addresses.
- Now IPL your RESCUE system and save the day.

./ ADD NAME=$BUILD   0100-10057-10057-1925-00027-00027-00000-COMPJM
//COMPJMX JOB (990030,135,60,100),JMILLER,CLASS=A,
//        NOTIFY=&SYSUID,MSGCLASS=X,REGION=6M
/*JOBPARM LINES=90000
//*---------------------------------------------------------------*
//* Execute TSO in batch to run ZCLONE execs.                     *
//* Make sure you are not editing the ZCLONE input pds, and that  *
//* you don't have it allocated in any other way.                 *
//*---------------------------------------------------------------*
//* The SYSPROC DD statment should be changed to the name of the  *
//* PDS containing the ZCLONE execs and members.  The INPDS       *
//* parameter should also be set to the same ZCLONE PDS.          *
//*---------------------------------------------------------------*
//* OUTPDS should be est to indicate an empty PDS where generated *
//* JCL and parameter members can be stored.                      *
//*---------------------------------------------------------------*
//* 10/11/2009 John C. Miller.                                    *
//*---------------------------------------------------------------*
//TSO      EXEC PGM=IKJEFT01,REGION=4M
//SYSPRINT DD SYSOUT=*
//SYSIN    DD DUMMY
//SYSTSPRT DD SYSOUT=*
//SYSPROC  DD DISP=SHR,DSN=COMPJM.ZCLONE  <-- Change to ZCLONE PDS
//SYSTSIN  DD *
 %ZCLONE  INPDS(COMPJM.ZCLONE) +     <-- Change to ZCLONE PDS name
          OUTPDS(COMPJM.CJOBS) +     <-- Change to name of empty PDS
          PARMS(@PARMS)              <-- Change to you parm member
/*
./ ADD NAME=$BUILD2  0100-10057-10057-1926-00026-00026-00000-COMPJM
//COMPJMA JOB (0),JMILLER,CLASS=A,NOTIFY=&SYSUID,MSGCLASS=X,REGION=64M
/*JOBPARM LINES=90000
//*---------------------------------------------------------------*
//* Execute TSO in batch to run ZCLONE execs.                     *
//* Make sure you are not editing the ZCLONE input pds, and that  *
//* you don't have it allocated in any other way.                 *
//*---------------------------------------------------------------*
//* The SYSPROC DD statment should be changed to the name of the  *
//* PDS containing the ZCLONE execs and members.  The INPDS       *
//* parameter should also be set to the same ZCLONE PDS.          *
//*---------------------------------------------------------------*
//* OUTPDS should be est to indicate an empty PDS where generated *
//* JCL and parameter members can be stored.                      *
//*---------------------------------------------------------------*
//* 10/11/2009 John C. Miller.                                    *
//*---------------------------------------------------------------*
//TSO      EXEC PGM=IKJEFT01,REGION=4M
//SYSPRINT DD SYSOUT=*
//SYSIN    DD DUMMY
//SYSTSPRT DD SYSOUT=*
//SYSPROC  DD DISP=SHR,DSN=COMPJM.ZCLONE  <-- Change to ZCLONE PDS
//SYSTSIN  DD *
 %ZCLONE  INPDS(COMPJM.ZCLONE)  +    <-- Change to ZCLONE PDS name
          OUTPDS(COMPJM.CJOBS2) +    <-- Change to name of empty PDS
          PARMS(@PARMS2)             <-- Change to you parm member
/*
./ ADD NAME=$BUILD3  0101-10016-10057-1927-00026-00021-00000-COMPJM
//COMPJMA JOB (0),JMILLER,CLASS=A,NOTIFY=&SYSUID,MSGCLASS=X,REGION=64M
/*JOBPARM LINES=90000
//*---------------------------------------------------------------*
//* Execute TSO in batch to run ZCLONE execs.                     *
//* Make sure you are not editing the ZCLONE input pds, and that  *
//* you don't have it allocated in any other way.                 *
//*---------------------------------------------------------------*
//* The SYSPROC DD statment should be changed to the name of the  *
//* PDS containing the ZCLONE execs and members.  The INPDS       *
//* parameter should also be set to the same ZCLONE PDS.          *
//*---------------------------------------------------------------*
//* OUTPDS should be est to indicate an empty PDS where generated *
//* JCL and parameter members can be stored.                      *
//*---------------------------------------------------------------*
//* 10/11/2009 John C. Miller.                                    *
//*---------------------------------------------------------------*
//TSO      EXEC PGM=IKJEFT01,REGION=4M
//SYSPRINT DD SYSOUT=*
//SYSIN    DD DUMMY
//SYSTSPRT DD SYSOUT=*
//SYSPROC  DD DISP=SHR,DSN=COMPJM.ZCLONE  <-- Change to ZCLONE PDS
//SYSTSIN  DD *
 %ZCLONE  INPDS(COMPJM.ZCLONE)  +    <-- Change to ZCLONE PDS name
          OUTPDS(COMPJM.CJOBS3) +    <-- Change to name of empty PDS
          PARMS(@PARMS3)             <-- Change to you parm member
/*
./ ADD NAME=$CATCLSE 0100-10057-10057-1935-00012-00012-00000-COMPJM
/*$VS,'F CATALOG,CLOSE(CATALOG.MASTER)'
/*$VS,'F CATALOG,UNALLOCATE(CATALOG.MAST18)'
/*$VS,'F CATALOG,CLOSE(CATALOG.SYST18)'
/*$VS,'F CATALOG,UNALLOCATE(CATALOG.SYST18)'
//COMPJMA JOB (0),JMILLER,CLASS=A,NOTIFY=&SYSUID,MSGCLASS=X,REGION=6M
//*---------------------------------------------------------------
//* Use these commands to unallocate and close the master and user
//* catalogs of the newly generated system.  You may need to do this
//* if you need to start the system build process over, to enable the
//* volumes containing your catalogs to come offline.
//*---------------------------------------------------------------
// EXEC PGM=IEFBR14
./ ADD NAME=$SAREST
//AOSGJCMA JOB (0),JMILLER,MSGCLASS=X,CLASS=A,NOTIFY=&SYSUID,REGION=6M
//*------------------------------------------------------------------*
//* $SAREST - Build an IPL'able, stand alone restore tape for the
//* RESCUE system.  This job assumes that your rescue IPL volume
//* is labelled "RECUE".  If your RESCUE system includes more than
//* a single volume, then repeat this jobstream substituting the
//* volser for any other volumes that you want to standalone restore.
//*------------------------------------------------------------------*
//* IMPORTANT: See member $$$SARES notes and discussion.
//*------------------------------------------------------------------*
//* 03/28/1997 John C. Miller
//*------------------------------------------------------------------*
//*************************************************
//* Write standalone DFDSS image in file 1        *
//*************************************************
//SADSS   EXEC PGM=ADRDSSU,PARM='UTILMSG=YES'
//SAMODS    DD DSN=SYS1.SADRYLIB,DISP=SHR
//TAPE      DD UNIT=CART,DISP=(NEW,PASS),
//          DCB=(RECFM=FB,LRECL=80,BLKSIZE=80),
//          LABEL=(1,NL,EXPDT=98000),
//          VOL=(,RETAIN,SER=RESCU1)
//SYSPRINT  DD SYSOUT=*
//SYSIN     DD *
   BUILDSA -
       INDD(SAMODS) -
       OUTDD(TAPE)  -
       ADMINISTRATOR -
       IPL(CARD) -
       OPERCNSL(001F)
//*************************************************
//* Write volume dump image in file 2             *
//*************************************************
//DUMP     EXEC PGM=ADRDSSU,REGION=4M
//SYSPRINT  DD SYSOUT=*
//TAPE      DD UNIT=CART,DISP=(NEW,PASS),
//          LABEL=(2,NL,EXPDT=98000),
//          VOL=REF=*.SADSS.TAPE
//SYSIN     DD *
  DUMP INDYNAM(RESCUE) OUTDD(TAPE)
./ ADD NAME=#ALCNVSM
/*---------------------------------------------------Rexx--*/
/* ZCLONE  - Build JCL and other elements for cloning a    */
/*           z/OS system.                                  */
/*---------------------------------------------------------*/
/* #ALCNVSM - Allocate NONVSAM files.                      */
/*                                                         */
/* Processes entries in @DATASET member, ignoring those    */
/* datasets with operation types of "D" and "H", which are */
/* datasets that will be copied using DFDSS, and hence do  */
/* not need to be pre-allocated.                           */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
ARG jobnum ipds opds zzprms .
IF \varinit() THEN RETURN 1 /* Read parms, initialize vars. */
call parse_dataset

/*=========================================================*/
/* JOB: Allocate nonVSAM datasets.                         */
/*=========================================================*/
Say "Building Job "jobnum": Allocate NONVSAM datasets."
call setout opds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "ALLOCNVS - Allocate nonVSAM datasets.                "
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//DEFNVSAM EXEC  PGM=IEFBR14"

/*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */
/* Loop through DS. stem var and punch alloc dd statements.*/
/*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */
DO ###yy = 1 TO DS.0
   zzEXCEPTIONS = "SMF STGINDEX PGPLPA PGCOMMON PGLOCAL XCF LOGR WLM"
   zbEXC = hasParms(zzEXCEPTIONS,DS.###yy.PARM)
   IF zbEXC THEN ITERATE
   /*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */
   /* If ALLOC option then punch alloc DD statements.      */
   /*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */
   IF DS.###yy.verb = "DATASET" & DS.###yy.option = "ALLOC" THEN DO
      IF POS("SMF",DS.###yy.PARM) > 0 THEN ITERATE
      call allocdn
   END
END
call clsout opds,'JOB'jobnum
RETURN

allocdn:
IF SYMBOL("DS."###yy".NEWNAME") = "VAR" THEN tgtdsn = DS.###yy.NEWNAME
ELSE                                         tgtdsn = DS.###yy.DSN
volser = DS.###yy.VOL
ddname = LEFT(llq(tgtdsn),8)
spa = DS.###yy.SPACE
IF SYMBOL("DS."###yy".MODEL") = "VAR" THEN DO
   mod = DS.###yy.MODEL
   space_cont = ","
   model_present = 1
END
ELSE DO
   model_present = 0
   space_cont = ""
END
mod = DS.###yy.MODEL
zssa = getssa(tgtdsn) /* Look up appropriate SSA */

call jcl "//"ddname" DD DISP=(NEW,KEEP),UNIT="devtype","
call jcl "//         VOL=SER="volser",DSN="zssa""tgtdsn","
call jcl "//         SPACE=("spa")"space_cont
IF model_present THEN,
call jcl "//         DCB=("mod")"
call jcl "//*"
RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions - v3.8 ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
IF isblank('@DATASET') THEN zzdsmem = '@DATASET'
ELSE zzdsmem = @DATASET
call setinp ipds,zzdsmem,'D.'
DO ###xx = 1 TO D.0
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN zcontin = 1
   ELSE zcontin = 0
   zrest = STRIP(zrest,"T")
   zrest = STRIP(zrest,"T","-")
   zrest = STRIP(zrest,"T","+")
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */
/*---------------------------------------------------------*/
dsdefined:
ARG #x##dsn2
DO #x#x2 = 1 TO DS.0
   IF DS.#x#x2.verb /= "DATASET" THEN ITERATE
   IF SYMBOL("DS."#x#x2".NEWNAME") = "VAR" THEN,
      #x##dsn = DS.#x#x2.NEWNAME
   ELSE #x##dsn = DS.#x#x2.DSN
   IF #x##dsn2 = #x##dsn THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.  The list  */
/* returned is a space delimited list of dsn+volume pairs, */
/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */
/* The parse_dataset routine must have already be run for  */
/* this routine to work.                                   */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ###xx = 1 TO DS.0
   IF DS.###xx.verb /= "DATASET" THEN ITERATE
   IF attrib(##prm,DS.###xx.PARM) THEN DO
      IF SYMBOL("DS."###xx".NEWNAME") = "VAR" THEN,
      ###dslst = ###dslst" "DS.###xx.NEWNAME DS.###xx.VOL
      ELSE,
      ###dslst = ###dslst" "DS.###xx.DSN DS.###xx.VOL
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* dstype - Return dataset type.                           */
/*---------------------------------------------------------*/
dstype:
ARG ##ds
##x = OUTTRAP('##y.',25)
"LISTD '"##ds"'"
##rc = rc
##x = OUTTRAP('OFF')
IF ##rc > 0 THEN RETURN "ERROR"
ELSE RETURN WORD(##y.3,WORDS(##y.3))

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),ZCLONE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
IF \setinp(ipds,zzprms,'PARMS.') THEN DO
   SAY "Error: Unable to allocate parms member:"ipds"("zzprms")."
   RETURN 0
END
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/* ' .     /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
/* IF r = "" THEN ITERATE */
   r = varsub(r)
   INTERPRET q '= "'r'"'
END
RETURN 1

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem, ##mode
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
IF ##mode = "" THEN ##mode = "SHR"
"ALLOC FI(output) DA('"##ds"("##mem")') "##mode
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
IF SYSDSN("'"##ds2"("##mem2")'") /= "OK" THEN RETURN 0
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(opds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(opds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str ##str2 '.' .
RETURN ##str2

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*---------------------------------------------------------*/
/* nonblank - Determine if a variable is blank or undef.   */
/*---------------------------------------------------------*/
isblank:
PARSE ARG #prm
IF VALUE(#prm) = "" THEN RETURN 1
IF SYMBOL(#prm) = = "LIT" THEN RETURN 1
RETURN 0

/*-------------------------------------------*/
/* Variable substitution.  Return a string   */
/* with all variables interpolated.  Vars    */
/* either be vars coded in the rexx exec     */
/* itself, or parms coded in the @PARMS file.*/
/*-------------------------------------------*/
varsub:
PARSE ARG ####str
####i = POS("&",####str)
DO WHILE ####i > 0
   ####str0 = SUBSTR(####str,1,####i-1)
   ####str2 = SUBSTR(####str,####i)
   ####str2 = TRANSLATE(####str2,"               "," &./()*&%$#@:<>")
   ####str2 = WORD(####str2,1)
   ####l = LENGTH(####str2)+1
   ####str3 = SUBSTR(####str,####i+####l)
   IF ####str2 = ZCLONE THEN ####str2 = ipds
   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)
   ####str = ####str0""####str2""####str3
   ####i = POS("&",####str)
END
RETURN ####str

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Add a text line to a queue.  (actually a  */
/* stem variable.)  This allows us to manage */
/* the output from various processes and     */
/* give the user a more orderly output.      */
/* The "queue" names must be numbers, due to */
/* the vagaries of the rexx interpreter.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* To store a line in queue #1:              */
/*   call qu 1,'Hello World!!'               */
/* To print all lines from queue #1:         */
/*   DO x = 1 TO q.1.0                       */
/*      SAY q.1.x                            */
/*   END                                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qu:
PARSE ARG #q,#data
#ctr = VALUE(q.#q.0)
IF DATATYPE(#ctr) /= 'NUM' THEN DO
   q.#q.0 = 0
   #ctr = 0
END
#ctr=#ctr+1; q.#q.0=#ctr
q.#q.#ctr = #data
return
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Print out all lines of a queue.           */
/* #q   = Queue number to print (1..n)       */
/* #box = 1 -> print line within box chars.  */
/* #box = 0 -> print line w/no box chars.    */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qup:
PARSE ARG #q,#box
IF #box /= 1 THEN #box = 0
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN
DO ##x = 1 TO q.#q.0
   IF #box THEN say box(q.#q.##x)
   ELSE            say q.#q.##x
END
RETURN

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Queue has lines: 0|1                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/
quhaslines:
PARSE ARG #q
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0
ELSE RETURN 1

/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Get volume for a given dataset.           */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getvol:
PARSE ARG ####d
DO ####x=1 TO DS.0
   IF \isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME
   ELSE                               ####d2 = DS.####x.DSN
   IF ####d = ####d2 THEN RETURN DS.####x.VOL
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* InsertIntoMember:  Insert some text into  */
/* a member, but only if a search string is  */
/* found/not found.  If ##negative is set to */
/* 1, then only insert if the search string  */
/* is not found.  Otherwise, only insert the */
/* string if the search string IS found.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
insertIntoMember:
PARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative

IF setinp(##ds, ##mem) THEN DO
   ##foun=0
   DO ##xx = 1 TO INPUT.0
      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1
   END
   IF ##negative  = 1 &  ##foun THEN RETURN 0
   IF ##negative /= 1 & \##foun THEN RETURN 0
   call clsinp ##ds, ##mem
   call setout ##ods, ##omem
   DO ##xx = 1 TO INPUT.0
      call jcl INPUT.##xx
   END
END
ELSE DO
   call setout ##ods, ##omem
END
call jcl ##txt
call clsout ##ds, ##mem
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* hasParms - True if any of the coded parms */
/* are present for a dataset.                */
/*- - - - - - - - - - - - - - - - - - - - - -*/
hasParms:
PARSE ARG ##prms, ##dsprms
##dsprms = TRANSLATE(##dsprms,' ',',')
DO ####hp = 1 TO WORDS(##prms)
   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* vsam_part:  Return name of DATA or INDEX  */
/* component of a VSAM file.                 */
/*- - - - - - - - - - - - - - - - - - - - - -*/
vsam_part:
ARG ##part,##ds
##x = OUTTRAP('##y.',25)
"LISTC ENT('"ds"')"
##rc = rc
##x = OUTTRAP('OFF')
DO ##x = 1 TO ##y.0
   say ##y.##x
   PARSE VAR ##y.##x (##part) "------- " zzdsn .
   IF zzdsn /= "" THEN RETURN zzdsn
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* volsym:  If USESYM=YES in @PARMS, then    */
/* substitute "&SYSRn" for the volser passed.*/
/* Otherwise, just spit back the volser.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
volsym:
PARSE ARG ##volser
IF isblank("USESYM") THEN RETURN ##volser
IF USESYM /= "YES" & USERSYM /= "1" THEN RETURN ##volser

DO ##zz = 1 TO 99
   IF \isblank("VOLSER"##zz) & \isblank("ADDR"##zz) THEN DO
      ###zvolser = VALUE("VOLSER"##zz)
      IF ##volser = ###zvolser THEN RETURN "&SYSR"##zz
   END
END

RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getssa: Return the appropriate SSA for a  */
/* dataset.  If usercat is defined and an    */
/* alias to the usercat would be applied to  */
/* this dataset, then return the SSAU value. */
/* Else, return the SSA value (for the mcat).*/
/*- - - - - - - - - - - - - - - - - - - - - -*/
getssa:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN SSA

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) & \isblank("NEWUCAT") THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN SSAU
   END
END

RETURN SSA

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getcat: Return the appropriate catalog in */
/* which to catalog a dataset--either the    */
/* mastercat or usercat.                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getcat:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN NEWMCAT

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT
   END
END

RETURN NEWMCAT

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- end low level functions -------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
./ ADD NAME=#ALTER
/*---------------------------------------------------Rexx--*/
/* ZCLONE  - Build JCL and other elements for cloning a    */
/*           z/OS system.                                  */
/*---------------------------------------------------------*/
/* #ALTER   - Alter catalog entries to remove the SSA.     */
/*---------------------------------------------------------*/
/* V3.1 - 10/10/2007 John C. Miller                        */
/*---------------------------------------------------------*/
ARG ssa catalog .

/*-   -   -   -   -   -   -   -   -   -   -   -   -   -   -*/
/* Do a listcat on the cloned system mastercat, and loop   */
/* through the entries, building ALTER stmts as needed.    */
/*-   -   -   -   -   -   -   -   -   -   -   -   -   -   -*/
zzlevel = STRIP(ssa,'B','.')
##x = OUTTRAP('lc.',99999)
   "LISTCAT LEVEL("zzlevel") CATALOG('"catalog"')"
##x = OUTTRAP('OFF')

cc = 0

DO ##x = 1 TO lc.0
   IF POS("IN-CAT ---",lc.##x) > 0 THEN ITERATE  /* Discard junk. */
   PARSE VAR lc.##x zztype zzdummy zzdsn .
   IF SUBSTR(zzdsn,1,length(ssa)) /= ssa THEN ITERATE /* Not ssa.* */
   PARSE VAR zzdsn (ssa) zzdsn2
   say ,
   "ALTER '"zzdsn"' NEWNAME('"zzdsn2"') CATALOG('"catalog"')"
   "ALTER '"zzdsn"' NEWNAME('"zzdsn2"') CATALOG('"catalog"')"
    IF rc > cc THEN cc = rc
END

IF cc = 0 THEN DO
   SAY ,
   "DELETE '"zzlevel"' ALIAS"
END
ELSE DO
   SAY "System specific alias (SSA) "zzlevel" not deleted."
END

RETURN
./ ADD NAME=#ALTERJC
/*---------------------------------------------------Rexx--*/
/* ZCLONE  - Build JCL and other elements for cloning a    */
/*           z/OS system.                                  */
/*---------------------------------------------------------*/
/* #ALTERJC - Alter catalog entries back to final name.    */
/*---------------------------------------------------------*/
/* V3.1 - 03/08/2007 John C. Miller                        */
/*---------------------------------------------------------*/
ARG jobnum ipds opds zzprms .
IF \varinit() THEN RETURN 1 /* Read parms, initialize vars. */
call parse_dataset

/*=========================================================*/
/* JOB: Alter catalog entries back to final names.         */
/* (Remove the SYSX.)                                      */
/*=========================================================*/
Say "Building Job "jobnum": Alter catalog entries to final names."
call setout opds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "ALTER - Alter dataset names to final names, removing"
call jcc "        the "ssa" prefix.                           "
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//ALTER    EXEC PGM=IKJEFT01,REGION=4M"
call jcl "//SYSPRINT DD SYSOUT=*"
call jcl "//SYSIN    DD DUMMY"
call jcl "//SYSTSPRT DD SYSOUT=*"
call jcl "//SYSPROC  DD DISP=SHR,DSN="ipds
call jcl "//SYSTSIN  DD *"
call jcl " #ALTER "ssa"  "newmcat
call jcl " #ALTER "ssau" "newucat
call jcl "//*"
call clsout opds,'JOB'jobnum
RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions - v3.8 ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
IF isblank('@DATASET') THEN zzdsmem = '@DATASET'
ELSE zzdsmem = @DATASET
call setinp ipds,zzdsmem,'D.'
DO ###xx = 1 TO D.0
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN zcontin = 1
   ELSE zcontin = 0
   zrest = STRIP(zrest,"T")
   zrest = STRIP(zrest,"T","-")
   zrest = STRIP(zrest,"T","+")
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */
/*---------------------------------------------------------*/
dsdefined:
ARG #x##dsn2
DO #x#x2 = 1 TO DS.0
   IF DS.#x#x2.verb /= "DATASET" THEN ITERATE
   IF SYMBOL("DS."#x#x2".NEWNAME") = "VAR" THEN,
      #x##dsn = DS.#x#x2.NEWNAME
   ELSE #x##dsn = DS.#x#x2.DSN
   IF #x##dsn2 = #x##dsn THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.  The list  */
/* returned is a space delimited list of dsn+volume pairs, */
/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */
/* The parse_dataset routine must have already be run for  */
/* this routine to work.                                   */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ###xx = 1 TO DS.0
   IF DS.###xx.verb /= "DATASET" THEN ITERATE
   IF attrib(##prm,DS.###xx.PARM) THEN DO
      IF SYMBOL("DS."###xx".NEWNAME") = "VAR" THEN,
      ###dslst = ###dslst" "DS.###xx.NEWNAME DS.###xx.VOL
      ELSE,
      ###dslst = ###dslst" "DS.###xx.DSN DS.###xx.VOL
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* dstype - Return dataset type.                           */
/*---------------------------------------------------------*/
dstype:
ARG ##ds
##x = OUTTRAP('##y.',25)
"LISTD '"##ds"'"
##rc = rc
##x = OUTTRAP('OFF')
IF ##rc > 0 THEN RETURN "ERROR"
ELSE RETURN WORD(##y.3,WORDS(##y.3))

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),ZCLONE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
IF \setinp(ipds,zzprms,'PARMS.') THEN DO
   SAY "Error: Unable to allocate parms member:"ipds"("zzprms")."
   RETURN 0
END
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/* ' .     /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
/* IF r = "" THEN ITERATE */
   r = varsub(r)
   INTERPRET q '= "'r'"'
END
RETURN 1

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem, ##mode
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
IF ##mode = "" THEN ##mode = "SHR"
"ALLOC FI(output) DA('"##ds"("##mem")') "##mode
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
IF SYSDSN("'"##ds2"("##mem2")'") /= "OK" THEN RETURN 0
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(opds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(opds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str ##str2 '.' .
RETURN ##str2

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*---------------------------------------------------------*/
/* nonblank - Determine if a variable is blank or undef.   */
/*---------------------------------------------------------*/
isblank:
PARSE ARG #prm
IF VALUE(#prm) = "" THEN RETURN 1
IF SYMBOL(#prm) = = "LIT" THEN RETURN 1
RETURN 0

/*-------------------------------------------*/
/* Variable substitution.  Return a string   */
/* with all variables interpolated.  Vars    */
/* either be vars coded in the rexx exec     */
/* itself, or parms coded in the @PARMS file.*/
/*-------------------------------------------*/
varsub:
PARSE ARG ####str
####i = POS("&",####str)
DO WHILE ####i > 0
   ####str0 = SUBSTR(####str,1,####i-1)
   ####str2 = SUBSTR(####str,####i)
   ####str2 = TRANSLATE(####str2,"               "," &./()*&%$#@:<>")
   ####str2 = WORD(####str2,1)
   ####l = LENGTH(####str2)+1
   ####str3 = SUBSTR(####str,####i+####l)
   IF ####str2 = ZCLONE THEN ####str2 = ipds
   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)
   ####str = ####str0""####str2""####str3
   ####i = POS("&",####str)
END
RETURN ####str

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Add a text line to a queue.  (actually a  */
/* stem variable.)  This allows us to manage */
/* the output from various processes and     */
/* give the user a more orderly output.      */
/* The "queue" names must be numbers, due to */
/* the vagaries of the rexx interpreter.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* To store a line in queue #1:              */
/*   call qu 1,'Hello World!!'               */
/* To print all lines from queue #1:         */
/*   DO x = 1 TO q.1.0                       */
/*      SAY q.1.x                            */
/*   END                                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qu:
PARSE ARG #q,#data
#ctr = VALUE(q.#q.0)
IF DATATYPE(#ctr) /= 'NUM' THEN DO
   q.#q.0 = 0
   #ctr = 0
END
#ctr=#ctr+1; q.#q.0=#ctr
q.#q.#ctr = #data
return
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Print out all lines of a queue.           */
/* #q   = Queue number to print (1..n)       */
/* #box = 1 -> print line within box chars.  */
/* #box = 0 -> print line w/no box chars.    */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qup:
PARSE ARG #q,#box
IF #box /= 1 THEN #box = 0
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN
DO ##x = 1 TO q.#q.0
   IF #box THEN say box(q.#q.##x)
   ELSE            say q.#q.##x
END
RETURN

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Queue has lines: 0|1                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/
quhaslines:
PARSE ARG #q
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0
ELSE RETURN 1

/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Get volume for a given dataset.           */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getvol:
PARSE ARG ####d
DO ####x=1 TO DS.0
   IF \isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME
   ELSE                               ####d2 = DS.####x.DSN
   IF ####d = ####d2 THEN RETURN DS.####x.VOL
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* InsertIntoMember:  Insert some text into  */
/* a member, but only if a search string is  */
/* found/not found.  If ##negative is set to */
/* 1, then only insert if the search string  */
/* is not found.  Otherwise, only insert the */
/* string if the search string IS found.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
insertIntoMember:
PARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative

IF setinp(##ds, ##mem) THEN DO
   ##foun=0
   DO ##xx = 1 TO INPUT.0
      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1
   END
   IF ##negative  = 1 &  ##foun THEN RETURN 0
   IF ##negative /= 1 & \##foun THEN RETURN 0
   call clsinp ##ds, ##mem
   call setout ##ods, ##omem
   DO ##xx = 1 TO INPUT.0
      call jcl INPUT.##xx
   END
END
ELSE DO
   call setout ##ods, ##omem
END
call jcl ##txt
call clsout ##ds, ##mem
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* hasParms - True if any of the coded parms */
/* are present for a dataset.                */
/*- - - - - - - - - - - - - - - - - - - - - -*/
hasParms:
PARSE ARG ##prms, ##dsprms
##dsprms = TRANSLATE(##dsprms,' ',',')
DO ####hp = 1 TO WORDS(##prms)
   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* vsam_part:  Return name of DATA or INDEX  */
/* component of a VSAM file.                 */
/*- - - - - - - - - - - - - - - - - - - - - -*/
vsam_part:
ARG ##part,##ds
##x = OUTTRAP('##y.',25)
"LISTC ENT('"ds"')"
##rc = rc
##x = OUTTRAP('OFF')
DO ##x = 1 TO ##y.0
   say ##y.##x
   PARSE VAR ##y.##x (##part) "------- " zzdsn .
   IF zzdsn /= "" THEN RETURN zzdsn
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* volsym:  If USESYM=YES in @PARMS, then    */
/* substitute "&SYSRn" for the volser passed.*/
/* Otherwise, just spit back the volser.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
volsym:
PARSE ARG ##volser
IF isblank("USESYM") THEN RETURN ##volser
IF USESYM /= "YES" & USERSYM /= "1" THEN RETURN ##volser

DO ##zz = 1 TO 99
   IF \isblank("VOLSER"##zz) & \isblank("ADDR"##zz) THEN DO
      ###zvolser = VALUE("VOLSER"##zz)
      IF ##volser = ###zvolser THEN RETURN "&SYSR"##zz
   END
END

RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getssa: Return the appropriate SSA for a  */
/* dataset.  If usercat is defined and an    */
/* alias to the usercat would be applied to  */
/* this dataset, then return the SSAU value. */
/* Else, return the SSA value (for the mcat).*/
/*- - - - - - - - - - - - - - - - - - - - - -*/
getssa:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN SSA

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) & \isblank("NEWUCAT") THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN SSAU
   END
END

RETURN SSA

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getcat: Return the appropriate catalog in */
/* which to catalog a dataset--either the    */
/* mastercat or usercat.                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getcat:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN NEWMCAT

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT
   END
END

RETURN NEWMCAT

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- end low level functions -------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
./ ADD NAME=#COPYDS
/*---------------------------------------------------Rexx--*/
/* ZCLONE  - Build JCL and other elements for cloning a    */
/*           z/OS system.                                  */
/*---------------------------------------------------------*/
/* #COPYDS  - Copy datasets.                               */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2007 John C. Miller                        */
/*---------------------------------------------------------*/
ARG jobnum ipds opds zzprms .
IF \varinit() THEN RETURN 1 /* Read parms, initialize vars. */
call parse_dataset

maxdsns = 99
maxdsnctr = maxdsns + 1

/*=========================================================*/
/* JOB: Copy datasets.                                     */
/*=========================================================*/
dsctr = 0; jobctr = 0

DO ##xxx = 1 TO DS.0
   maxdsnctr = maxdsnctr +1
   IF maxdsnctr > maxdsns THEN DO
      jobctr = jobctr + 1
      zjnum1 = "JOB"jobnum""RIGHT("000"jobctr,2)
      zjnum2 = jobnum""RIGHT("000"jobctr,2)
      call clsout opds
      call setout opds,zjnum1
      maxdsnctr = 0
      Say "Building Job "zjnum2": Copy datasets."
      call jobcard jobnum
      call jcd
      call jcc "Job "zjnum2
      call jcd
      call jcc "COPY - Copy the datasets in the @DATASETS member."
      call jcd
      call jcc mydate()" "comment
   END
   IF DS.##xxx.verb /= "DATASET" | DS.##xxx.option /= "COPY" THEN,
   ITERATE
   /* DATASET COPY  record.  */
   dsctr = dsctr + 1
   zzdsn = DS.##xxx.DSN
   zzvol = DS.##xxx.VOL
   IF SYMBOL("DS."##xxx".NEWNAME") /= "VAR" THEN zznewname = ""
   ELSE zznewname = DS.##xxx.NEWNAME

   IF DS.##xxx.MODE = "DFDSS"      THEN call copydss
   IF DS.##xxx.MODE = "IEBCOPY"    THEN call copyieb
   IF DS.##xxx.MODE = "IEBGENER"   THEN call copygen
   IF DS.##xxx.MODE = "HFS"        THEN call copyhfs
   IF DS.##xxx.MODE = "RACF"       THEN call copyracf
   IF POS("SMF",DS.##xxx.PARM) > 0 THEN call copynon
END

call jcl "//*"
call clsout opds,'JOB'jobnum
RETURN

/* subr */
copydss:
stepname = "DSSC"RIGHT("00000"dsctr,4)
call jcd
call jcc stepname
call jcc "Copy "zzdsn" with DFDSS."
call jcd
call jcl "//"stepname" EXEC PGM=ADRDSSU"
call jcl "//SYSPRINT  DD SYSOUT=* "
call jcl "//SYSIN     DD * "
call jcl "      COPY DATASET( - "
call jcl "         INCLUDE("zzdsn")) -"
call jcl "         REPLACE    -"
IF attrib('RLSE',zzparms) THEN,  /* If not RLSE, do ALLDATA. */
call jcl "         ALLDATA(*) -"
call jcl "         TOL(ENQF) - "
call jcl "         BYPASSACS(**) -"
call jcl "         NULLSTORCLAS  -"
call jcl "         PROCESS(SYS1)  -"
IF zznewname /= "" THEN zssa = getssa(zznewname)
ELSE                    zssa = getssa(zzdsn)

IF zznewname /= "" THEN zzrnu = zssa""zznewname
ELSE                    zzrnu = zssa""zzdsn

call jcl "         RENAMEU( -"
call jcl "            "zzdsn", -"
call jcl "            "zzrnu" -"
call jcl "                ) -"
IF dstype(zzdsn) = "VSAM" THEN,
call jcl "         RECATALOG("newmcat") -"
call jcl "         OUTDYNAM("zzvol") -"
call jcl "         SHARE"
call jcl "//*"
RETURN

/* subr */
copyieb:
stepname = "IEBC"RIGHT("0000"dsctr,4)
call jcd
call jcc stepname
call jcc "Copy "zzdsn" with IEBCOPY"
call jcd
call jcl "//"stepname" EXEC PGM=IEBCOPY"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSUT1   DD DSN="zzdsn",DISP=SHR,"
call jcl "//         UNIT=SYSALLDA,VOL=SER="
IF zznewname /= "" THEN tgtdsn = zznewname
ELSE tgtdsn = zzdsn
zssa = getssa(tgtdsn) /* Look up appropriate SSA */

call jcl "//SYSUT2   DD DSN="zssa""tgtdsn",DISP=SHR,"
IF attrib('RLSE',zzparms) THEN, /* If RLSE, specify RLSE.     */
call jcl "//         SPACE=(CYL,(1,1,1),RLSE),"
call jcl "//         UNIT=SYSALLDA,VOL=SER="zzvol
call jcl "//SYSIN    DD * "
call jcl "  COPY I=SYSUT1,O=SYSUT2,LIST=NO "
call jcl "//*"
RETURN

/* subr */
copygen:
stepname = "GENR"RIGHT("0000"dsctr,4)
call jcd
call jcc stepname
call jcc "Copy "zzdsn" with IEBGENER"
call jcd
call jcl "//"stepname" EXEC PGM=IEBGENER"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSUT1   DD DSN="zzdsn",DISP=SHR,"
call jcl "//         UNIT=SYSALLDA,VOL=SER="
IF zznewname /= "" THEN tgtdsn = zznewname
ELSE tgtdsn = zzdsn
zssa = getssa(tgtdsn) /* Look up appropriate SSA */
call jcl "//SYSUT2   DD DSN="zssa""tgtdsn",DISP=SHR,"
IF attrib('RLSE',zzparms) THEN, /* If RLSE, specify RLSE.     */
call jcl "//         SPACE=(CYL,(1,1,1),RLSE),"
call jcl "//         UNIT=SYSALLDA,VOL=SER="zzvol
call jcl "//SYSIN    DD DUMMY"
call jcl "//*"
RETURN

/* subr */
copynon:
stepname = "NOOP"RIGHT("0000"dsctr,4)
IF zznewname /= "" THEN tgtdsn = zznewname
ELSE tgtdsn = zzdsn
call jcd
call jcc stepname
call jcc "None: "tgtdsn" will not be copied."
call jcc "This dataset was specified as No-Copy (Allocate only.)"
call jcd
call jcl "//"stepname" EXEC PGM=IEFBR14"
call jcl "//*"
RETURN

/* subr */
copyhfs:
stepname = "HFSD"RIGHT("00000"dsctr,4)
call jcd
call jcc stepname
call jcc "Copy "zzdsn" HFS with DFDSS DUMP and RESTORE."
IF zznewname /= "" THEN,
call jcc "Target dsn is "zznewname"."
call jcd
call jcl "//"stepname" EXEC PGM=ADRDSSU"
call jcl "//SYSPRINT  DD SYSOUT=* "
call jcl "//TAPE      DD DISP=(,PASS),DSN=&&TAPE,UNIT=SYSALLDA,"
call jcl "//          VOL=SER="workvol",SPACE=(CYL,(350,200),RLSE)"
call jcl "//SYSIN     DD * "
call jcl "  DUMP    DATASET(  -"
call jcl "          INCLUDE("zzdsn")) -"
call jcl "          TOL(ENQF) -"
call jcl "          OUTDD(TAPE)"
call jcl "//*"
stepnam2 = "HFSR"RIGHT("00000"dsctr,4)
call jcl "//"stepnam2" EXEC PGM=ADRDSSU,COND=(4,LT,"stepname")"
call jcl "//SYSPRINT  DD SYSOUT=* "
call jcl "//TAPE      DD DISP=(OLD,DELETE),DSN=&&TAPE"
call jcl "//SYSIN     DD * "
call jcl "  RESTORE DATASET( -"
call jcl "          INCLUDE(**)) -"
call jcl "          RECATALOG("newmcat") -"
call jcl "          BYPASSACS(**) -"
call jcl "          NULLSTORCLAS -"
IF zznewname /= "" THEN zssa = getssa(zznewname)
ELSE                    zssa = getssa(zzdsn)

IF zznewname /= "" THEN zzrnu = zzdsn","zssa""zznewname
ELSE                    zzrnu = zzdsn","zssa""zzdsn
call jcl "          RENAMEU("zzrnu") -"
call jcl "          OUTDYNAM("zzvol") -"
call jcl "          REPLACE TOL(ENQF) INDD(TAPE) "
call jcl "//*"
RETURN

/* subr */
copyracf:
stepname = "RACF"RIGHT("00000"dsctr,4)
IF isblank("DS."##xxx".SPACE") THEN zzspa = ""
ELSE zzspa = ",SPACE=("DS.##xxx.SPACE")"
call jcd
call jcc stepname
call jcc "Copy "zzdsn" with IRRUT400"
call jcd
call jcl "//RFCOPY   EXEC PGM=IRRUT400,PARM='LOCKINPUT,FREESPACE(20)'"
call jcl "//SYSPRINT DD SYSOUT=*"
IF zznewname /= "" THEN tgtdsn = zznewname
ELSE                   tgtdsn = zzdsn
zssa = getssa(tgtdsn) /* Look up appropriate SSA */
call jcl "//INDD1    DD DSN="zzdsn",DISP=OLD"
call jcl "//OUTDD1   DD DSN="zssa""tgtdsn",DISP=(,KEEP),"
call jcl "//         UNIT=SYSALLDA,VOL=SER="zzvol","
call jcl "//         DCB=("zzdsn")"zzspa
call jcl "//UNLOCK   EXEC PGM=IRRUT400,PARM='UNLOCKINPUT'"
call jcl "//SYSPRINT DD SYSOUT=*"
call jcl "//INDD1    DD DSN="zzdsn",DISP=OLD"

RETURN

/* subr */
alter_rename:
ARG ##old,##new

call jcd
call jcl "//ALTER    EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD    SYSOUT=*"
call jcl "//SYSIN    DD    *"
call jcl "  ALTER "##old" -"
call jcl "        NEWNAME("##new") -"
call jcl "        CATALOG("newmcat")"
call jcl "//*"

RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions - v3.8 ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
IF isblank('@DATASET') THEN zzdsmem = '@DATASET'
ELSE zzdsmem = @DATASET
call setinp ipds,zzdsmem,'D.'
DO ###xx = 1 TO D.0
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN zcontin = 1
   ELSE zcontin = 0
   zrest = STRIP(zrest,"T")
   zrest = STRIP(zrest,"T","-")
   zrest = STRIP(zrest,"T","+")
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */
/*---------------------------------------------------------*/
dsdefined:
ARG #x##dsn2
DO #x#x2 = 1 TO DS.0
   IF DS.#x#x2.verb /= "DATASET" THEN ITERATE
   IF SYMBOL("DS."#x#x2".NEWNAME") = "VAR" THEN,
      #x##dsn = DS.#x#x2.NEWNAME
   ELSE #x##dsn = DS.#x#x2.DSN
   IF #x##dsn2 = #x##dsn THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.  The list  */
/* returned is a space delimited list of dsn+volume pairs, */
/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */
/* The parse_dataset routine must have already be run for  */
/* this routine to work.                                   */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ###xx = 1 TO DS.0
   IF DS.###xx.verb /= "DATASET" THEN ITERATE
   IF attrib(##prm,DS.###xx.PARM) THEN DO
      IF SYMBOL("DS."###xx".NEWNAME") = "VAR" THEN,
      ###dslst = ###dslst" "DS.###xx.NEWNAME DS.###xx.VOL
      ELSE,
      ###dslst = ###dslst" "DS.###xx.DSN DS.###xx.VOL
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* dstype - Return dataset type.                           */
/*---------------------------------------------------------*/
dstype:
ARG ##ds
##x = OUTTRAP('##y.',25)
"LISTD '"##ds"'"
##rc = rc
##x = OUTTRAP('OFF')
IF ##rc > 0 THEN RETURN "ERROR"
ELSE RETURN WORD(##y.3,WORDS(##y.3))

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),ZCLONE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
IF \setinp(ipds,zzprms,'PARMS.') THEN DO
   SAY "Error: Unable to allocate parms member:"ipds"("zzprms")."
   RETURN 0
END
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/* ' .     /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
/* IF r = "" THEN ITERATE */
   r = varsub(r)
   INTERPRET q '= "'r'"'
END
RETURN 1

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem, ##mode
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
IF ##mode = "" THEN ##mode = "SHR"
"ALLOC FI(output) DA('"##ds"("##mem")') "##mode
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
IF SYSDSN("'"##ds2"("##mem2")'") /= "OK" THEN RETURN 0
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(opds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(opds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str ##str2 '.' .
RETURN ##str2

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*---------------------------------------------------------*/
/* nonblank - Determine if a variable is blank or undef.   */
/*---------------------------------------------------------*/
isblank:
PARSE ARG #prm
IF VALUE(#prm) = "" THEN RETURN 1
IF SYMBOL(#prm) = = "LIT" THEN RETURN 1
RETURN 0

/*-------------------------------------------*/
/* Variable substitution.  Return a string   */
/* with all variables interpolated.  Vars    */
/* either be vars coded in the rexx exec     */
/* itself, or parms coded in the @PARMS file.*/
/*-------------------------------------------*/
varsub:
PARSE ARG ####str
####i = POS("&",####str)
DO WHILE ####i > 0
   ####str0 = SUBSTR(####str,1,####i-1)
   ####str2 = SUBSTR(####str,####i)
   ####str2 = TRANSLATE(####str2,"               "," &./()*&%$#@:<>")
   ####str2 = WORD(####str2,1)
   ####l = LENGTH(####str2)+1
   ####str3 = SUBSTR(####str,####i+####l)
   IF ####str2 = ZCLONE THEN ####str2 = ipds
   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)
   ####str = ####str0""####str2""####str3
   ####i = POS("&",####str)
END
RETURN ####str

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Add a text line to a queue.  (actually a  */
/* stem variable.)  This allows us to manage */
/* the output from various processes and     */
/* give the user a more orderly output.      */
/* The "queue" names must be numbers, due to */
/* the vagaries of the rexx interpreter.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* To store a line in queue #1:              */
/*   call qu 1,'Hello World!!'               */
/* To print all lines from queue #1:         */
/*   DO x = 1 TO q.1.0                       */
/*      SAY q.1.x                            */
/*   END                                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qu:
PARSE ARG #q,#data
#ctr = VALUE(q.#q.0)
IF DATATYPE(#ctr) /= 'NUM' THEN DO
   q.#q.0 = 0
   #ctr = 0
END
#ctr=#ctr+1; q.#q.0=#ctr
q.#q.#ctr = #data
return
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Print out all lines of a queue.           */
/* #q   = Queue number to print (1..n)       */
/* #box = 1 -> print line within box chars.  */
/* #box = 0 -> print line w/no box chars.    */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qup:
PARSE ARG #q,#box
IF #box /= 1 THEN #box = 0
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN
DO ##x = 1 TO q.#q.0
   IF #box THEN say box(q.#q.##x)
   ELSE            say q.#q.##x
END
RETURN

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Queue has lines: 0|1                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/
quhaslines:
PARSE ARG #q
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0
ELSE RETURN 1

/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Get volume for a given dataset.           */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getvol:
PARSE ARG ####d
DO ####x=1 TO DS.0
   IF \isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME
   ELSE                               ####d2 = DS.####x.DSN
   IF ####d = ####d2 THEN RETURN DS.####x.VOL
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* InsertIntoMember:  Insert some text into  */
/* a member, but only if a search string is  */
/* found/not found.  If ##negative is set to */
/* 1, then only insert if the search string  */
/* is not found.  Otherwise, only insert the */
/* string if the search string IS found.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
insertIntoMember:
PARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative

IF setinp(##ds, ##mem) THEN DO
   ##foun=0
   DO ##xx = 1 TO INPUT.0
      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1
   END
   IF ##negative  = 1 &  ##foun THEN RETURN 0
   IF ##negative /= 1 & \##foun THEN RETURN 0
   call clsinp ##ds, ##mem
   call setout ##ods, ##omem
   DO ##xx = 1 TO INPUT.0
      call jcl INPUT.##xx
   END
END
ELSE DO
   call setout ##ods, ##omem
END
call jcl ##txt
call clsout ##ds, ##mem
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* hasParms - True if any of the coded parms */
/* are present for a dataset.                */
/*- - - - - - - - - - - - - - - - - - - - - -*/
hasParms:
PARSE ARG ##prms, ##dsprms
##dsprms = TRANSLATE(##dsprms,' ',',')
DO ####hp = 1 TO WORDS(##prms)
   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* vsam_part:  Return name of DATA or INDEX  */
/* component of a VSAM file.                 */
/*- - - - - - - - - - - - - - - - - - - - - -*/
vsam_part:
ARG ##part,##ds
##x = OUTTRAP('##y.',25)
"LISTC ENT('"ds"')"
##rc = rc
##x = OUTTRAP('OFF')
DO ##x = 1 TO ##y.0
   say ##y.##x
   PARSE VAR ##y.##x (##part) "------- " zzdsn .
   IF zzdsn /= "" THEN RETURN zzdsn
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* volsym:  If USESYM=YES in @PARMS, then    */
/* substitute "&SYSRn" for the volser passed.*/
/* Otherwise, just spit back the volser.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
volsym:
PARSE ARG ##volser
IF isblank("USESYM") THEN RETURN ##volser
IF USESYM /= "YES" & USERSYM /= "1" THEN RETURN ##volser

DO ##zz = 1 TO 99
   IF \isblank("VOLSER"##zz) & \isblank("ADDR"##zz) THEN DO
      ###zvolser = VALUE("VOLSER"##zz)
      IF ##volser = ###zvolser THEN RETURN "&SYSR"##zz
   END
END

RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getssa: Return the appropriate SSA for a  */
/* dataset.  If usercat is defined and an    */
/* alias to the usercat would be applied to  */
/* this dataset, then return the SSAU value. */
/* Else, return the SSA value (for the mcat).*/
/*- - - - - - - - - - - - - - - - - - - - - -*/
getssa:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN SSA

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) & \isblank("NEWUCAT") THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN SSAU
   END
END

RETURN SSA

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getcat: Return the appropriate catalog in */
/* which to catalog a dataset--either the    */
/* mastercat or usercat.                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getcat:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN NEWMCAT

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT
   END
END

RETURN NEWMCAT

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- end low level functions -------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
./ ADD NAME=#COPYMEM
/*---------------------------------------------------Rexx--*/
/* ZCLONE  - Build JCL and other elements for cloning a    */
/*           z/OS system.                                  */
/*---------------------------------------------------------*/
/* #COPYMEM - Copy generated members to their final homes. */
/*---------------------------------------------------------*/
/* V3.0 - 07/15/2007 John C. Miller                        */
/*---------------------------------------------------------*/
ARG jobnum ipds opds zzprms .
IF \varinit() THEN RETURN 1 /* Read parms, initialize vars. */
call parse_dataset

/*=========================================================*/
/* JOB: Copy members from ZCLONE PDS to various places.    */
/*=========================================================*/
Say "Building Job "jobnum": Copy generated members."
call setout opds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "COPYMEM - Copy customized members for various PROCs,   "
call jcc "          PARMLIB members, etc."
call jcd
call jcc mydate()" "comment

/*--------------------------------------------------------------------*/
/* Look for MEMCOPY commands in @DATASET member, and build DD stmts.  */
/* If the first 5 chars are blank, we assume a continuation, and keep */
/* stringing records togther until no more continuation records are   */
/* found.  Then we parse the combined string for all the values.      */
/*--------------------------------------------------------------------*/
indsn="";outdsn="";stepctr=0
DO ##xxx = 1 TO DS.0
   IF DS.##xxx.verb /= "MEMCOPY" THEN ITERATE
   zzindsn  = DS.##xxx.IN
   zzoutdsn = DS.##xxx.OUT
   IF indsn /= zzindsn | outdsn /= zzoutdsn THEN DO
      indsn = zzindsn; outdsn = zzoutdsn
      zzinvol  = getvol(DS.##xxx.IN)
      /* No support for coding the volser on an input dataset. */
      zzinvol  = ""
      zzoutvol = getvol(DS.##xxx.OUT)
      call copystep
   END
   zzmems = DS.##xxx.M
   zzmems = TRANSLATE(zzmems,"   ","(),")
   PARSE VAR zzmems zzmem1 zzmem2
   zzmems = zzmem1","zzmem2
   call jcl "    S M=(("zzmems",R))"
END

call clsout opds,'JOB'jobnum

RETURN

copystep:

   stepctr = stepctr + 1
   zzstp = "COPY"RIGHT("0000"stepctr,3)
   call jcd
   call jcc zzstp
   call jcd
   call jcl "//"zzstp"  EXEC  PGM=IEBCOPY"
   call jcl "//SYSPRINT DD SYSOUT=*"
   IF zzinvol /= "" THEN DO
      call jcl "//IN       DD DISP=SHR,DSN="zzindsn","
      call jcl "//         UNIT="devtype",VOL=SER="zzinvol
   END
   ELSE DO
      call jcl "//IN       DD DISP=SHR,DSN="zzindsn
   END
   IF zzoutvol /= "" THEN DO
      call jcl "//OUT      DD DISP=SHR,DSN="zzoutdsn","
      call jcl "//         UNIT="devtype",VOL=SER="zzoutvol
   END
   ELSE DO
      call jcl "//OUT      DD DISP=SHR,DSN="zzoutdsn
   END
   call jcl "//SYSIN    DD *"
   call jcl "  COPY I=IN,O=OUT"
   RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions - v3.8 ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
IF isblank('@DATASET') THEN zzdsmem = '@DATASET'
ELSE zzdsmem = @DATASET
call setinp ipds,zzdsmem,'D.'
DO ###xx = 1 TO D.0
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN zcontin = 1
   ELSE zcontin = 0
   zrest = STRIP(zrest,"T")
   zrest = STRIP(zrest,"T","-")
   zrest = STRIP(zrest,"T","+")
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */
/*---------------------------------------------------------*/
dsdefined:
ARG #x##dsn2
DO #x#x2 = 1 TO DS.0
   IF DS.#x#x2.verb /= "DATASET" THEN ITERATE
   IF SYMBOL("DS."#x#x2".NEWNAME") = "VAR" THEN,
      #x##dsn = DS.#x#x2.NEWNAME
   ELSE #x##dsn = DS.#x#x2.DSN
   IF #x##dsn2 = #x##dsn THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.  The list  */
/* returned is a space delimited list of dsn+volume pairs, */
/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */
/* The parse_dataset routine must have already be run for  */
/* this routine to work.                                   */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ###xx = 1 TO DS.0
   IF DS.###xx.verb /= "DATASET" THEN ITERATE
   IF attrib(##prm,DS.###xx.PARM) THEN DO
      IF SYMBOL("DS."###xx".NEWNAME") = "VAR" THEN,
      ###dslst = ###dslst" "DS.###xx.NEWNAME DS.###xx.VOL
      ELSE,
      ###dslst = ###dslst" "DS.###xx.DSN DS.###xx.VOL
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* dstype - Return dataset type.                           */
/*---------------------------------------------------------*/
dstype:
ARG ##ds
##x = OUTTRAP('##y.',25)
"LISTD '"##ds"'"
##rc = rc
##x = OUTTRAP('OFF')
IF ##rc > 0 THEN RETURN "ERROR"
ELSE RETURN WORD(##y.3,WORDS(##y.3))

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),ZCLONE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
IF \setinp(ipds,zzprms,'PARMS.') THEN DO
   SAY "Error: Unable to allocate parms member:"ipds"("zzprms")."
   RETURN 0
END
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/* ' .     /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
/* IF r = "" THEN ITERATE */
   r = varsub(r)
   INTERPRET q '= "'r'"'
END
RETURN 1

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem, ##mode
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
IF ##mode = "" THEN ##mode = "SHR"
"ALLOC FI(output) DA('"##ds"("##mem")') "##mode
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
IF SYSDSN("'"##ds2"("##mem2")'") /= "OK" THEN RETURN 0
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(opds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(opds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str ##str2 '.' .
RETURN ##str2

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*---------------------------------------------------------*/
/* nonblank - Determine if a variable is blank or undef.   */
/*---------------------------------------------------------*/
isblank:
PARSE ARG #prm
IF VALUE(#prm) = "" THEN RETURN 1
IF SYMBOL(#prm) = = "LIT" THEN RETURN 1
RETURN 0

/*-------------------------------------------*/
/* Variable substitution.  Return a string   */
/* with all variables interpolated.  Vars    */
/* either be vars coded in the rexx exec     */
/* itself, or parms coded in the @PARMS file.*/
/*-------------------------------------------*/
varsub:
PARSE ARG ####str
####i = POS("&",####str)
DO WHILE ####i > 0
   ####str0 = SUBSTR(####str,1,####i-1)
   ####str2 = SUBSTR(####str,####i)
   ####str2 = TRANSLATE(####str2,"               "," &./()*&%$#@:<>")
   ####str2 = WORD(####str2,1)
   ####l = LENGTH(####str2)+1
   ####str3 = SUBSTR(####str,####i+####l)
   IF ####str2 = ZCLONE THEN ####str2 = ipds
   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)
   ####str = ####str0""####str2""####str3
   ####i = POS("&",####str)
END
RETURN ####str

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Add a text line to a queue.  (actually a  */
/* stem variable.)  This allows us to manage */
/* the output from various processes and     */
/* give the user a more orderly output.      */
/* The "queue" names must be numbers, due to */
/* the vagaries of the rexx interpreter.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* To store a line in queue #1:              */
/*   call qu 1,'Hello World!!'               */
/* To print all lines from queue #1:         */
/*   DO x = 1 TO q.1.0                       */
/*      SAY q.1.x                            */
/*   END                                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qu:
PARSE ARG #q,#data
#ctr = VALUE(q.#q.0)
IF DATATYPE(#ctr) /= 'NUM' THEN DO
   q.#q.0 = 0
   #ctr = 0
END
#ctr=#ctr+1; q.#q.0=#ctr
q.#q.#ctr = #data
return
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Print out all lines of a queue.           */
/* #q   = Queue number to print (1..n)       */
/* #box = 1 -> print line within box chars.  */
/* #box = 0 -> print line w/no box chars.    */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qup:
PARSE ARG #q,#box
IF #box /= 1 THEN #box = 0
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN
DO ##x = 1 TO q.#q.0
   IF #box THEN say box(q.#q.##x)
   ELSE            say q.#q.##x
END
RETURN

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Queue has lines: 0|1                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/
quhaslines:
PARSE ARG #q
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0
ELSE RETURN 1

/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Get volume for a given dataset.           */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getvol:
PARSE ARG ####d
DO ####x=1 TO DS.0
   IF \isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME
   ELSE                               ####d2 = DS.####x.DSN
   IF ####d = ####d2 THEN RETURN DS.####x.VOL
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* InsertIntoMember:  Insert some text into  */
/* a member, but only if a search string is  */
/* found/not found.  If ##negative is set to */
/* 1, then only insert if the search string  */
/* is not found.  Otherwise, only insert the */
/* string if the search string IS found.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
insertIntoMember:
PARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative

IF setinp(##ds, ##mem) THEN DO
   ##foun=0
   DO ##xx = 1 TO INPUT.0
      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1
   END
   IF ##negative  = 1 &  ##foun THEN RETURN 0
   IF ##negative /= 1 & \##foun THEN RETURN 0
   call clsinp ##ds, ##mem
   call setout ##ods, ##omem
   DO ##xx = 1 TO INPUT.0
      call jcl INPUT.##xx
   END
END
ELSE DO
   call setout ##ods, ##omem
END
call jcl ##txt
call clsout ##ds, ##mem
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* hasParms - True if any of the coded parms */
/* are present for a dataset.                */
/*- - - - - - - - - - - - - - - - - - - - - -*/
hasParms:
PARSE ARG ##prms, ##dsprms
##dsprms = TRANSLATE(##dsprms,' ',',')
DO ####hp = 1 TO WORDS(##prms)
   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* vsam_part:  Return name of DATA or INDEX  */
/* component of a VSAM file.                 */
/*- - - - - - - - - - - - - - - - - - - - - -*/
vsam_part:
ARG ##part,##ds
##x = OUTTRAP('##y.',25)
"LISTC ENT('"ds"')"
##rc = rc
##x = OUTTRAP('OFF')
DO ##x = 1 TO ##y.0
   say ##y.##x
   PARSE VAR ##y.##x (##part) "------- " zzdsn .
   IF zzdsn /= "" THEN RETURN zzdsn
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* volsym:  If USESYM=YES in @PARMS, then    */
/* substitute "&SYSRn" for the volser passed.*/
/* Otherwise, just spit back the volser.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
volsym:
PARSE ARG ##volser
IF isblank("USESYM") THEN RETURN ##volser
IF USESYM /= "YES" & USERSYM /= "1" THEN RETURN ##volser

DO ##zz = 1 TO 99
   IF \isblank("VOLSER"##zz) & \isblank("ADDR"##zz) THEN DO
      ###zvolser = VALUE("VOLSER"##zz)
      IF ##volser = ###zvolser THEN RETURN "&SYSR"##zz
   END
END

RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getssa: Return the appropriate SSA for a  */
/* dataset.  If usercat is defined and an    */
/* alias to the usercat would be applied to  */
/* this dataset, then return the SSAU value. */
/* Else, return the SSA value (for the mcat).*/
/*- - - - - - - - - - - - - - - - - - - - - -*/
getssa:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN SSA

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) & \isblank("NEWUCAT") THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN SSAU
   END
END

RETURN SSA

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getcat: Return the appropriate catalog in */
/* which to catalog a dataset--either the    */
/* mastercat or usercat.                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getcat:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN NEWMCAT

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT
   END
END

RETURN NEWMCAT

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- end low level functions -------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
./ ADD NAME=#DEFCAT
/*---------------------------------------------------Rexx--*/
/* ZCLONE  - Build JCL and other elements for cloning a    */
/*           z/OS system.                                  */
/*---------------------------------------------------------*/
/* #DEFMCAT - Define master catalog.                       */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
ARG jobnum ipds opds zzprms .
IF \varinit() THEN RETURN 1 /* Read parms, initialize vars. */
call parse_dataset

/*=========================================================*/
/* JOB: Define master catalog.                             */
/*=========================================================*/
IF \isblank('NEWMCAT') | \isblank('NEWUCAT') THEN DO
   Say "Building Job "jobnum": Define master catalog."
   call setout opds,'JOB'jobnum
   call jobcard jobnum
   call jcd
   call jcc "Job "jobnum
   call jcd
   call jcc "DEFMCAT - Define catalogs and aliases."
   call jcd
   call jcc mydate()" "comment
   call jcl "//DEFCAT   EXEC PGM=IDCAMS"
   call jcl "//SYSPRINT DD SYSOUT=* "
   call jcl "//SYSIN    DD * "
END

/*---------------------------------------------------------*/
/* Mastercat.                                              */
/*---------------------------------------------------------*/
IF \isblank('NEWMCAT') THEN DO
   call jcl " "
   call jcl "      DEFINE USERCATALOG     ( -"
   call jcl "         NAME("newmcat") -"
   call jcl "         CYL(5 2) - "
   call jcl "         VOL("newmcatvol") -"
   call jcl "         BUFFERSPACE(8192) -"
   call jcl "         BUFND(10) -"
   call jcl "         BUFNI(10) -"
   call jcl "         ICFCATALOG -"
   call jcl "         STRNO(9) ) -"
   call jcl "         CATALOG("oldmcat")"
   call jcl " "
   IF \isblank("SSA") THEN DO
      zzssa = STRIP(ssa,"B",".")   /* Get rid of trailing "." */
      call jcl "      IF MAXCC = 0 THEN DO "
      call jcl "         DELETE "zzssa" ALIAS"
      call jcl "         SET MAXCC=0"
      call jcl " "
      call jcl "         DEFINE ALIAS(NAME("zzssa") -"
      call jcl "         RELATE("newmcat")) -"
      call jcl "         CATALOG("oldmcat")"
      call jcl "      END"
      call jcl " "
   END
END

/*---------------------------------------------------------*/
/* Usercat.                                                */
/*---------------------------------------------------------*/
IF \isblank('NEWMCAT') & \isblank('NEWMCAT') THEN DO
   call jcl " "
   call jcl "      IF MAXCC = 0 THEN DO "
   call jcl "         DEFINE USERCATALOG     ( -"
   call jcl "            NAME("newucat") -"
   call jcl "            CYL(5 2) - "
   call jcl "            VOL("newucatvol") -"
   call jcl "            BUFFERSPACE(8192) -"
   call jcl "            BUFND(10) -"
   call jcl "            BUFNI(10) -"
   call jcl "            ICFCATALOG -"
   call jcl "            STRNO(9) ) -"
   call jcl "            CATALOG("oldmcat")"
   call jcl "      END"
   call jcl "      IF MAXCC = 0 THEN DO "
   call jcl "         IMPORT OBJECTS -"
   call jcl "            (("newucat " -"
   call jcl "            VOLUME("newucatvol") -"
   call jcl "            DEVICETYPE("devtype"))) -"
   call jcl "            CONNECT CATALOG("newmcat")"
   call jcl "      END"
   call jcl " "
   IF \isblank("SSAU") THEN DO
      zzssau = STRIP(ssau,"B",".")   /* Get rid of trailing "." */
      call jcl "      IF MAXCC = 0 THEN DO "
      call jcl "         DELETE "zzssau" ALIAS"
      call jcl "         SET MAXCC=0"
      call jcl " "
      call jcl "         DEFINE ALIAS(NAME("zzssau") -"
      call jcl "         RELATE("newucat")) -"
      call jcl "         CATALOG("oldmcat")"
      call jcl "      END"
      call jcl " "
   END
END

/*---------------------------------------------------------*/
/* Usercat aliases (if specified in @PARMS)                */
/*---------------------------------------------------------*/
IF \isblank("UCATALIAS1") & \isblank("NEWUCAT") THEN DO
   call jcl "      IF MAXCC = 0 THEN DO "
END
DO zz = 1 TO 99
   IF \isblank("UCATALIAS"zz) & \isblank("NEWUCAT") THEN DO
      zalias = VALUE("UCATALIAS"zz);
      call jcl "         DEFINE ALIAS(NAME("zalias") -"
      call jcl "         RELATE("newucat")) -"
      call jcl "         CATALOG("newmcat")"
      call jcl " "
   END
END
IF \isblank("UCATALIAS1") THEN DO
   call jcl "      END"
END

call clsout opds,'JOB'jobnum

RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions - v3.8 ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
IF isblank('@DATASET') THEN zzdsmem = '@DATASET'
ELSE zzdsmem = @DATASET
call setinp ipds,zzdsmem,'D.'
DO ###xx = 1 TO D.0
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN zcontin = 1
   ELSE zcontin = 0
   zrest = STRIP(zrest,"T")
   zrest = STRIP(zrest,"T","-")
   zrest = STRIP(zrest,"T","+")
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */
/*---------------------------------------------------------*/
dsdefined:
ARG #x##dsn2
DO #x#x2 = 1 TO DS.0
   IF DS.#x#x2.verb /= "DATASET" THEN ITERATE
   IF SYMBOL("DS."#x#x2".NEWNAME") = "VAR" THEN,
      #x##dsn = DS.#x#x2.NEWNAME
   ELSE #x##dsn = DS.#x#x2.DSN
   IF #x##dsn2 = #x##dsn THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.  The list  */
/* returned is a space delimited list of dsn+volume pairs, */
/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */
/* The parse_dataset routine must have already be run for  */
/* this routine to work.                                   */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ###xx = 1 TO DS.0
   IF DS.###xx.verb /= "DATASET" THEN ITERATE
   IF attrib(##prm,DS.###xx.PARM) THEN DO
      IF SYMBOL("DS."###xx".NEWNAME") = "VAR" THEN,
      ###dslst = ###dslst" "DS.###xx.NEWNAME DS.###xx.VOL
      ELSE,
      ###dslst = ###dslst" "DS.###xx.DSN DS.###xx.VOL
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* dstype - Return dataset type.                           */
/*---------------------------------------------------------*/
dstype:
ARG ##ds
##x = OUTTRAP('##y.',25)
"LISTD '"##ds"'"
##rc = rc
##x = OUTTRAP('OFF')
IF ##rc > 0 THEN RETURN "ERROR"
ELSE RETURN WORD(##y.3,WORDS(##y.3))

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),ZCLONE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
IF \setinp(ipds,zzprms,'PARMS.') THEN DO
   SAY "Error: Unable to allocate parms member:"ipds"("zzprms")."
   RETURN 0
END
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/* ' .     /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
/* IF r = "" THEN ITERATE */
   r = varsub(r)
   INTERPRET q '= "'r'"'
END
RETURN 1

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem, ##mode
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
IF ##mode = "" THEN ##mode = "SHR"
"ALLOC FI(output) DA('"##ds"("##mem")') "##mode
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
IF SYSDSN("'"##ds2"("##mem2")'") /= "OK" THEN RETURN 0
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(opds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(opds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str ##str2 '.' .
RETURN ##str2

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*---------------------------------------------------------*/
/* nonblank - Determine if a variable is blank or undef.   */
/*---------------------------------------------------------*/
isblank:
PARSE ARG #prm
IF VALUE(#prm) = "" THEN RETURN 1
IF SYMBOL(#prm) = = "LIT" THEN RETURN 1
RETURN 0

/*-------------------------------------------*/
/* Variable substitution.  Return a string   */
/* with all variables interpolated.  Vars    */
/* either be vars coded in the rexx exec     */
/* itself, or parms coded in the @PARMS file.*/
/*-------------------------------------------*/
varsub:
PARSE ARG ####str
####i = POS("&",####str)
DO WHILE ####i > 0
   ####str0 = SUBSTR(####str,1,####i-1)
   ####str2 = SUBSTR(####str,####i)
   ####str2 = TRANSLATE(####str2,"               "," &./()*&%$#@:<>")
   ####str2 = WORD(####str2,1)
   ####l = LENGTH(####str2)+1
   ####str3 = SUBSTR(####str,####i+####l)
   IF ####str2 = ZCLONE THEN ####str2 = ipds
   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)
   ####str = ####str0""####str2""####str3
   ####i = POS("&",####str)
END
RETURN ####str

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Add a text line to a queue.  (actually a  */
/* stem variable.)  This allows us to manage */
/* the output from various processes and     */
/* give the user a more orderly output.      */
/* The "queue" names must be numbers, due to */
/* the vagaries of the rexx interpreter.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* To store a line in queue #1:              */
/*   call qu 1,'Hello World!!'               */
/* To print all lines from queue #1:         */
/*   DO x = 1 TO q.1.0                       */
/*      SAY q.1.x                            */
/*   END                                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qu:
PARSE ARG #q,#data
#ctr = VALUE(q.#q.0)
IF DATATYPE(#ctr) /= 'NUM' THEN DO
   q.#q.0 = 0
   #ctr = 0
END
#ctr=#ctr+1; q.#q.0=#ctr
q.#q.#ctr = #data
return
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Print out all lines of a queue.           */
/* #q   = Queue number to print (1..n)       */
/* #box = 1 -> print line within box chars.  */
/* #box = 0 -> print line w/no box chars.    */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qup:
PARSE ARG #q,#box
IF #box /= 1 THEN #box = 0
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN
DO ##x = 1 TO q.#q.0
   IF #box THEN say box(q.#q.##x)
   ELSE            say q.#q.##x
END
RETURN

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Queue has lines: 0|1                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/
quhaslines:
PARSE ARG #q
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0
ELSE RETURN 1

/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Get volume for a given dataset.           */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getvol:
PARSE ARG ####d
DO ####x=1 TO DS.0
   IF \isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME
   ELSE                               ####d2 = DS.####x.DSN
   IF ####d = ####d2 THEN RETURN DS.####x.VOL
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* InsertIntoMember:  Insert some text into  */
/* a member, but only if a search string is  */
/* found/not found.  If ##negative is set to */
/* 1, then only insert if the search string  */
/* is not found.  Otherwise, only insert the */
/* string if the search string IS found.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
insertIntoMember:
PARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative

IF setinp(##ds, ##mem) THEN DO
   ##foun=0
   DO ##xx = 1 TO INPUT.0
      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1
   END
   IF ##negative  = 1 &  ##foun THEN RETURN 0
   IF ##negative /= 1 & \##foun THEN RETURN 0
   call clsinp ##ds, ##mem
   call setout ##ods, ##omem
   DO ##xx = 1 TO INPUT.0
      call jcl INPUT.##xx
   END
END
ELSE DO
   call setout ##ods, ##omem
END
call jcl ##txt
call clsout ##ds, ##mem
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* hasParms - True if any of the coded parms */
/* are present for a dataset.                */
/*- - - - - - - - - - - - - - - - - - - - - -*/
hasParms:
PARSE ARG ##prms, ##dsprms
##dsprms = TRANSLATE(##dsprms,' ',',')
DO ####hp = 1 TO WORDS(##prms)
   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* vsam_part:  Return name of DATA or INDEX  */
/* component of a VSAM file.                 */
/*- - - - - - - - - - - - - - - - - - - - - -*/
vsam_part:
ARG ##part,##ds
##x = OUTTRAP('##y.',25)
"LISTC ENT('"ds"')"
##rc = rc
##x = OUTTRAP('OFF')
DO ##x = 1 TO ##y.0
   say ##y.##x
   PARSE VAR ##y.##x (##part) "------- " zzdsn .
   IF zzdsn /= "" THEN RETURN zzdsn
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* volsym:  If USESYM=YES in @PARMS, then    */
/* substitute "&SYSRn" for the volser passed.*/
/* Otherwise, just spit back the volser.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
volsym:
PARSE ARG ##volser
IF isblank("USESYM") THEN RETURN ##volser
IF USESYM /= "YES" & USERSYM /= "1" THEN RETURN ##volser

DO ##zz = 1 TO 99
   IF \isblank("VOLSER"##zz) & \isblank("ADDR"##zz) THEN DO
      ###zvolser = VALUE("VOLSER"##zz)
      IF ##volser = ###zvolser THEN RETURN "&SYSR"##zz
   END
END

RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getssa: Return the appropriate SSA for a  */
/* dataset.  If usercat is defined and an    */
/* alias to the usercat would be applied to  */
/* this dataset, then return the SSAU value. */
/* Else, return the SSA value (for the mcat).*/
/*- - - - - - - - - - - - - - - - - - - - - -*/
getssa:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN SSA

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) & \isblank("NEWUCAT") THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN SSAU
   END
END

RETURN SSA

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getcat: Return the appropriate catalog in */
/* which to catalog a dataset--either the    */
/* mastercat or usercat.                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getcat:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN NEWMCAT

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT
   END
END

RETURN NEWMCAT

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- end low level functions -------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
./ ADD NAME=#DEFNVSM
/*---------------------------------------------------Rexx--*/
/* ZCLONE  - Build JCL and other elements for cloning a    */
/*           z/OS system.                                  */
/*---------------------------------------------------Rexx--*/
/* #DEFNVSM - Define non-VSAM catalog entries              */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
ARG jobnum ipds opds zzprms .
IF \varinit() THEN RETURN 1 /* Read parms, initialize vars. */
call parse_dataset

zuse_syms = \isblank("USESYM") & USESYM = "YES"

/*=========================================================*/
/* JOB: Define NONVSAM catalog entries.                    */
/*=========================================================*/
Say "Building Job "jobnum": Define NONVSAM catalog entries."
call setout opds,'JOB'jobnum

call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "NONVSAM - Define non-VSAM catalog entries for all NONVSAM   "
call jcc "          datasets, including those copied by DFDSS."
call jcc mydate()" "comment
call jcd
call jcl "//DEFNVSAM EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN    DD * "
call jcl " LISTCAT ENT("strip(ssa,"B",".")") ALIAS"
call jcl " IF LASTCC = 0 THEN DO"

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Define catlg entries for NONVSAM.         */
/*- - - - - - - - - - - - - - - - - - - - - -*/
DO ##xxx = 1 TO DS.0
   IF DS.##xxx.verb /= "DATASET" THEN ITERATE
   IF dstype(DS.##XXX.DSN) = "VSAM" THEN ITERATE
   zzEXCEPTIONS = "SMF STGINDEX PGPLPA PGCOMMON PGLOCAL XCF WLM LOGR "
   zbEXC = hasParms(zzEXCEPTIONS,DS.##xxx.PARM)
   IF zbEXC THEN ITERATE
   IF SYMBOL("DS."##xxx".NEWNAME")="VAR" THEN zzdsn = DS.##xxx.NEWNAME
   ELSE zzdsn = DS.##xxx.DSN
trace off
   zzcat = getcat(zzdsn)
   zzvol = DS.##xxx.VOL
   zssa = getssa(zzdsn) /* Look up appropriate SSA */
   call jcl "    DEFINE NONVSAM ( -"
   call jcl "       NAME("zssa""zzdsn") -"
   call jcl "       DEVT("devtype") VOL("zzvol")) CATALOG("zzcat")"
   call jcl " "
   IF zuse_syms THEN DO
      call jcl "    ALTER "zssa""zzdsn" -"
      call jcl "       NEWNAME("zzdsn") -"
      call jcl "       CATALOG("zzcat")"
      call jcl " "
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
      /* If PARM(NOSYM) coded for this DS, don't recatlg with       */
      /* symbolid volser.                                           */
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
      IF \hasParms("NOSYM",DS.##xxx.PARM) THEN DO
         call jcl "    DELETE "zzdsn" NOSCRATCH -"
         call jcl "       CATALOG("zzcat")"
         call jcl " "
         call jcl "    DEFINE NONVSAM ( -"
         call jcl "       NAME("zzdsn") -"
         zzvl2 = volsym(zzvol)
         call jcl "       DEVT(0000) VOL("zzvl2")) CATALOG("zzcat")"
         call jcl " "
      END
   END
trace off
END
call jcl " END"
call jcl "//*"
call clsout opds,'JOB'jobnum
RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions - v3.8 ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
IF isblank('@DATASET') THEN zzdsmem = '@DATASET'
ELSE zzdsmem = @DATASET
call setinp ipds,zzdsmem,'D.'
DO ###xx = 1 TO D.0
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN zcontin = 1
   ELSE zcontin = 0
   zrest = STRIP(zrest,"T")
   zrest = STRIP(zrest,"T","-")
   zrest = STRIP(zrest,"T","+")
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */
/*---------------------------------------------------------*/
dsdefined:
ARG #x##dsn2
DO #x#x2 = 1 TO DS.0
   IF DS.#x#x2.verb /= "DATASET" THEN ITERATE
   IF SYMBOL("DS."#x#x2".NEWNAME") = "VAR" THEN,
      #x##dsn = DS.#x#x2.NEWNAME
   ELSE #x##dsn = DS.#x#x2.DSN
   IF #x##dsn2 = #x##dsn THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.  The list  */
/* returned is a space delimited list of dsn+volume pairs, */
/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */
/* The parse_dataset routine must have already be run for  */
/* this routine to work.                                   */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ###xx = 1 TO DS.0
   IF DS.###xx.verb /= "DATASET" THEN ITERATE
   IF attrib(##prm,DS.###xx.PARM) THEN DO
      IF SYMBOL("DS."###xx".NEWNAME") = "VAR" THEN,
      ###dslst = ###dslst" "DS.###xx.NEWNAME DS.###xx.VOL
      ELSE,
      ###dslst = ###dslst" "DS.###xx.DSN DS.###xx.VOL
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* dstype - Return dataset type.                           */
/*---------------------------------------------------------*/
dstype:
ARG ##ds
##x = OUTTRAP('##y.',25)
"LISTD '"##ds"'"
##rc = rc
##x = OUTTRAP('OFF')
IF ##rc > 0 THEN RETURN "ERROR"
ELSE RETURN WORD(##y.3,WORDS(##y.3))

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),ZCLONE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
IF \setinp(ipds,zzprms,'PARMS.') THEN DO
   SAY "Error: Unable to allocate parms member:"ipds"("zzprms")."
   RETURN 0
END
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/* ' .     /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
/* IF r = "" THEN ITERATE */
   r = varsub(r)
   INTERPRET q '= "'r'"'
END
RETURN 1

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem, ##mode
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
IF ##mode = "" THEN ##mode = "SHR"
"ALLOC FI(output) DA('"##ds"("##mem")') "##mode
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
IF SYSDSN("'"##ds2"("##mem2")'") /= "OK" THEN RETURN 0
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(opds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(opds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str ##str2 '.' .
RETURN ##str2

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*---------------------------------------------------------*/
/* nonblank - Determine if a variable is blank or undef.   */
/*---------------------------------------------------------*/
isblank:
PARSE ARG #prm
IF VALUE(#prm) = "" THEN RETURN 1
IF SYMBOL(#prm) = = "LIT" THEN RETURN 1
RETURN 0

/*-------------------------------------------*/
/* Variable substitution.  Return a string   */
/* with all variables interpolated.  Vars    */
/* either be vars coded in the rexx exec     */
/* itself, or parms coded in the @PARMS file.*/
/*-------------------------------------------*/
varsub:
PARSE ARG ####str
####i = POS("&",####str)
DO WHILE ####i > 0
   ####str0 = SUBSTR(####str,1,####i-1)
   ####str2 = SUBSTR(####str,####i)
   ####str2 = TRANSLATE(####str2,"               "," &./()*&%$#@:<>")
   ####str2 = WORD(####str2,1)
   ####l = LENGTH(####str2)+1
   ####str3 = SUBSTR(####str,####i+####l)
   IF ####str2 = ZCLONE THEN ####str2 = ipds
   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)
   ####str = ####str0""####str2""####str3
   ####i = POS("&",####str)
END
RETURN ####str

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Add a text line to a queue.  (actually a  */
/* stem variable.)  This allows us to manage */
/* the output from various processes and     */
/* give the user a more orderly output.      */
/* The "queue" names must be numbers, due to */
/* the vagaries of the rexx interpreter.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* To store a line in queue #1:              */
/*   call qu 1,'Hello World!!'               */
/* To print all lines from queue #1:         */
/*   DO x = 1 TO q.1.0                       */
/*      SAY q.1.x                            */
/*   END                                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qu:
PARSE ARG #q,#data
#ctr = VALUE(q.#q.0)
IF DATATYPE(#ctr) /= 'NUM' THEN DO
   q.#q.0 = 0
   #ctr = 0
END
#ctr=#ctr+1; q.#q.0=#ctr
q.#q.#ctr = #data
return
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Print out all lines of a queue.           */
/* #q   = Queue number to print (1..n)       */
/* #box = 1 -> print line within box chars.  */
/* #box = 0 -> print line w/no box chars.    */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qup:
PARSE ARG #q,#box
IF #box /= 1 THEN #box = 0
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN
DO ##x = 1 TO q.#q.0
   IF #box THEN say box(q.#q.##x)
   ELSE            say q.#q.##x
END
RETURN

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Queue has lines: 0|1                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/
quhaslines:
PARSE ARG #q
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0
ELSE RETURN 1

/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Get volume for a given dataset.           */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getvol:
PARSE ARG ####d
DO ####x=1 TO DS.0
   IF \isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME
   ELSE                               ####d2 = DS.####x.DSN
   IF ####d = ####d2 THEN RETURN DS.####x.VOL
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* InsertIntoMember:  Insert some text into  */
/* a member, but only if a search string is  */
/* found/not found.  If ##negative is set to */
/* 1, then only insert if the search string  */
/* is not found.  Otherwise, only insert the */
/* string if the search string IS found.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
insertIntoMember:
PARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative

IF setinp(##ds, ##mem) THEN DO
   ##foun=0
   DO ##xx = 1 TO INPUT.0
      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1
   END
   IF ##negative  = 1 &  ##foun THEN RETURN 0
   IF ##negative /= 1 & \##foun THEN RETURN 0
   call clsinp ##ds, ##mem
   call setout ##ods, ##omem
   DO ##xx = 1 TO INPUT.0
      call jcl INPUT.##xx
   END
END
ELSE DO
   call setout ##ods, ##omem
END
call jcl ##txt
call clsout ##ds, ##mem
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* hasParms - True if any of the coded parms */
/* are present for a dataset.                */
/*- - - - - - - - - - - - - - - - - - - - - -*/
hasParms:
PARSE ARG ##prms, ##dsprms
##dsprms = TRANSLATE(##dsprms,' ',',')
DO ####hp = 1 TO WORDS(##prms)
   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* vsam_part:  Return name of DATA or INDEX  */
/* component of a VSAM file.                 */
/*- - - - - - - - - - - - - - - - - - - - - -*/
vsam_part:
ARG ##part,##ds
##x = OUTTRAP('##y.',25)
"LISTC ENT('"ds"')"
##rc = rc
##x = OUTTRAP('OFF')
DO ##x = 1 TO ##y.0
   say ##y.##x
   PARSE VAR ##y.##x (##part) "------- " zzdsn .
   IF zzdsn /= "" THEN RETURN zzdsn
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* volsym:  If USESYM=YES in @PARMS, then    */
/* substitute "&SYSRn" for the volser passed.*/
/* Otherwise, just spit back the volser.     */
/* - - - 07/29/2009 JCM - - - - - - - - - - -*/
/* If "ASTERISKS" is defined in parms for    */
/* this ds, then catalog with "******"       */
/* instead of &SYSR1. "******","ASTER","*"   */
/* are also synonyms.                        */
/*- - - - - - - - - - - - - - - - - - - - - -*/
volsym:
PARSE ARG ##volser
IF isblank("USESYM") THEN RETURN ##volser
IF USESYM /= "YES" & USERSYM /= "1" THEN RETURN ##volser

IF hasParms("ASTERISKS",DS.##xxx.PARM) THEN RETURN "******"
IF hasParms("******",DS.##xxx.PARM) THEN RETURN "******"
IF hasParms("ASTER",DS.##xxx.PARM) THEN RETURN "******"
IF hasParms("*",DS.##xxx.PARM) THEN RETURN "******"

DO ##zz = 1 TO 99
   IF \isblank("VOLSER"##zz) & \isblank("ADDR"##zz) THEN DO
      ###zvolser = VALUE("VOLSER"##zz)
      IF ##volser = ###zvolser THEN RETURN "&SYSR"##zz
   END
END

RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getssa: Return the appropriate SSA for a  */
/* dataset.  If usercat is defined and an    */
/* alias to the usercat would be applied to  */
/* this dataset, then return the SSAU value. */
/* Else, return the SSA value (for the mcat).*/
/*- - - - - - - - - - - - - - - - - - - - - -*/
getssa:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN SSA

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) & \isblank("NEWUCAT") THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN SSAU
   END
END

RETURN SSA

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getcat: Return the appropriate catalog in */
/* which to catalog a dataset--either the    */
/* mastercat or usercat.                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getcat:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN NEWMCAT

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT
   END
END

RETURN NEWMCAT

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- end low level functions -------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
./ ADD NAME=#DEFVSAM
/*---------------------------------------------------Rexx--*/
/* ZCLONE  - Build JCL and other elements for cloning a    */
/*           z/OS system.                                  */
/*---------------------------------------------------Rexx--*/
/* #DEFVSAM - Define VSAM files.                           */
/*---------------------------------------------------------*/
ARG jobnum ipds opds zzprms .
IF \varinit() THEN RETURN 1 /* Read parms, initialize vars. */
call parse_dataset

/*=========================================================*/
/* JOB: Define VSAM files.                                 */
/*=========================================================*/
Say "Building Job "jobnum": Define VSAM files."
call setout opds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "DEFVSAM - Define MANx, PAGE, STGINDEX datasets."
call jcd
call jcc "Define the datasets with the SSA prefix: "ssa", so that the"
call jcc "catalog entries are defined in our new rescue master catalog,"
call jcc newmcat"."
call jcd
call jcc "We check for the SSA being defined before doing any defines."
call jcc "This prevents us from inadvertently storing junk in the "
call jcc "master catalog of the driving system.  "
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//DEFVSAM  EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN    DD * "
call jcl " LISTCAT ALL ENTRY("strip(ssa,"B",".")") ALIAS"
call jcl " IF LASTCC = 0 THEN DO"
call jcl " "
DO ##xxx = 1 TO DS.0
   IF hasParms("STGINDEX",DS.##xxx.PARM) THEN DO
      zzdsn = DS.##xxx.DSN
      zzvol = DS.##xxx.VOL
      zzspa = TRANSLATE(DS.##xxx.SPACE,"   ",",()")
      PARSE VAR zzspa zzunit zzpri .
      call jcl "      DEFINE CLUSTER ( -"
      call jcl "                NAME( "ssa""zzdsn" ) -"
      call jcl "                "zzunit"( "zzpri" ) -"
      call jcl "                VOL("zzvol") -"
      call jcl "                BUFFERSPACE(20480) - "
      call jcl "                KEYS(12 8) - "
      call jcl "                RECORDSIZE(2041,2041) -"
      call jcl "                REUSE ) - "
      call jcl "             DATA ( -"
      call jcl "                NAME( "ssa""zzdsn".DATA ) -"
      call jcl "                CISZ(2048) ) - "
      call jcl "             INDEX ( - "
      call jcl "                NAME( "ssa""zzdsn".INDEX ) -"
      call jcl "                CISZ(1024) )"
      call jcl " "
      call jcl " "
   END
END

/*---------------------------------------------------------*/
/* Create PAGE datasets.                                   */
/*---------------------------------------------------------*/
DO ##xxx = 1 TO DS.0
   IF hasParms("PGPLPA PGCOMMON PGLOCAL",DS.##xxx.PARM) THEN DO
      zzdsn = DS.##xxx.DSN
      zzvol = DS.##xxx.VOL
      zzspa = TRANSLATE(DS.##xxx.SPACE,"   ",",()")
      PARSE VAR zzspa zzunit zzpri .
      call jcl "     DEFINE PAGESPACE ( -"
      call jcl "                NAME( "ssa""zzdsn") -"
      call jcl "                   "zzunit"(" zzpri ") -"
      call jcl "                   VOL("zzvol") -"
      call jcl "                   NOSWAP - "
      call jcl "                   UNIQUE )  "
      call jcl " "
      call jcl " "
   END
END

/*---------------------------------------------------------*/
/* Build defines for each SMF ds as defined in @DATASET,   */
/* i.e. dsns that have the SMF parm coded.                 */
/*---------------------------------------------------------*/
call smflist

DO xx = 1 TO SMF.0
   smfds   = SMF.xx.dsn
   smfvl   = SMF.xx.vol
   smfunit = SMF.xx.unit
   smfpri  = SMF.xx.pri
   smfsec  = SMF.xx.sec
   call jcl "  DEFINE CLUSTER ( - "
   call jcl "             NAME( "ssa""smfds" ) -"
   call jcl "                "smfunit"( "zpri zsec" ) -"
   call jcl "                VOLUME("smfvl") -"
   call jcl "                CISZ(4096) - "
   call jcl "                NONINDEXED - "
   call jcl "                RECORDSIZE(4086 32767) - "
   call jcl "                REUSE   SHR(2 3) - "
   call jcl "                SPANNED  SPEED ) - "
   call jcl "          DATA ( -  "
   call jcl "                  NAME( "ssa""smfds".DATA) ) "
   call jcl " "
END

/* Closing END from highest level IF LASTCC (from alias).  */
call jcl " END "
call jcl "//*"

/*---------------------------------------------------------*/
/* Format SMF datasets.  They still have the SSA on front. */
/*---------------------------------------------------------*/
call jcd
call jcc "FMTSMF   - Format SMF datasets."
call jcc mydate()" "comment
call jcd
call jcl "//FMTSMF EXEC PGM=IFASMFDP"
call jcl "//SYSPRINT DD SYSOUT=*"
DO xx = 1 TO SMF.0
   smfds   = SMF.xx.dsn
   smfds   = ssa""smfds
   smfvl   = SMF.xx.vol
   call jcl "//"substr(llq(smfds),1,8)" DD DSN="smfds",DISP=SHR,"
   call jcl "//         UNIT="devtype",VOL=SER="smfvl
END
call jcl "//SYSIN    DD *"
DO xx = 1 TO SMF.0
   smfds   = SMF.xx.dsn
   call jcl "   INDD("llq(smfds)",OPTIONS(CLEAR))"
END
call jcl "//*"

/*---------------------------------------------------------*/
/* Rename SMF datasets to final name (remove SSA).         */
/*---------------------------------------------------------*/
call jcd
call jcc "RENSMF   - Rename SMF datasets."
call jcc mydate()" "comment
call jcd
call jcl "//RENSMF EXEC PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=*"
call jcl "//SYSIN    DD *"
call jcl " LISTCAT ALL ENTRY("strip(ssa,"B",".")") ALIAS"
call jcl " "
call jcl "//*"
call clsout opds,'JOB'jobnum

RETURN

/*---------------------------------------------------------*/
/* Make a list of SMF datasets, plus the PRI and SEC aloc. */
/*---------------------------------------------------------*/
smflist:
SMF.0 = 0
##x91 = 0
/* Read @dataset member into DSNS. stem variable.           */

DO ##xxx = 1 TO DS.0
   IF POS("SMF",DS.##xxx.PARM) = 0 THEN ITERATE
   ##x91 = ##x91 + 1
   SMF.##x91.dsn = DS.##xxx.DSN
   SMF.##x91.vol = DS.##xxx.VOL
   PARSE VAR DS.##xxx.SPACE zunit "," zspa
   zspa = TRANSLATE(zspa,'   ','(),')
   PARSE VAR zspa zpri zsec
   SMF.##x91.unit = zunit
   SMF.##x91.pri  = zpri
   SMF.##x91.pri  = zsec
END
SMF.0 = ##x91

RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions - v3.8 ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
IF isblank('@DATASET') THEN zzdsmem = '@DATASET'
ELSE zzdsmem = @DATASET
call setinp ipds,zzdsmem,'D.'
DO ###xx = 1 TO D.0
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN zcontin = 1
   ELSE zcontin = 0
   zrest = STRIP(zrest,"T")
   zrest = STRIP(zrest,"T","-")
   zrest = STRIP(zrest,"T","+")
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */
/*---------------------------------------------------------*/
dsdefined:
ARG #x##dsn2
DO #x#x2 = 1 TO DS.0
   IF DS.#x#x2.verb /= "DATASET" THEN ITERATE
   IF SYMBOL("DS."#x#x2".NEWNAME") = "VAR" THEN,
      #x##dsn = DS.#x#x2.NEWNAME
   ELSE #x##dsn = DS.#x#x2.DSN
   IF #x##dsn2 = #x##dsn THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.  The list  */
/* returned is a space delimited list of dsn+volume pairs, */
/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */
/* The parse_dataset routine must have already be run for  */
/* this routine to work.                                   */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ###xx = 1 TO DS.0
   IF DS.###xx.verb /= "DATASET" THEN ITERATE
   IF attrib(##prm,DS.###xx.PARM) THEN DO
      IF SYMBOL("DS."###xx".NEWNAME") = "VAR" THEN,
      ###dslst = ###dslst" "DS.###xx.NEWNAME DS.###xx.VOL
      ELSE,
      ###dslst = ###dslst" "DS.###xx.DSN DS.###xx.VOL
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* dstype - Return dataset type.                           */
/*---------------------------------------------------------*/
dstype:
ARG ##ds
##x = OUTTRAP('##y.',25)
"LISTD '"##ds"'"
##rc = rc
##x = OUTTRAP('OFF')
IF ##rc > 0 THEN RETURN "ERROR"
ELSE RETURN WORD(##y.3,WORDS(##y.3))

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),ZCLONE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
IF \setinp(ipds,zzprms,'PARMS.') THEN DO
   SAY "Error: Unable to allocate parms member:"ipds"("zzprms")."
   RETURN 0
END
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/* ' .     /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
/* IF r = "" THEN ITERATE */
   r = varsub(r)
   INTERPRET q '= "'r'"'
END
RETURN 1

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem, ##mode
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
IF ##mode = "" THEN ##mode = "SHR"
"ALLOC FI(output) DA('"##ds"("##mem")') "##mode
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
IF SYSDSN("'"##ds2"("##mem2")'") /= "OK" THEN RETURN 0
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(opds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(opds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str ##str2 '.' .
RETURN ##str2

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*---------------------------------------------------------*/
/* nonblank - Determine if a variable is blank or undef.   */
/*---------------------------------------------------------*/
isblank:
PARSE ARG #prm
IF VALUE(#prm) = "" THEN RETURN 1
IF SYMBOL(#prm) = = "LIT" THEN RETURN 1
RETURN 0

/*-------------------------------------------*/
/* Variable substitution.  Return a string   */
/* with all variables interpolated.  Vars    */
/* either be vars coded in the rexx exec     */
/* itself, or parms coded in the @PARMS file.*/
/*-------------------------------------------*/
varsub:
PARSE ARG ####str
####i = POS("&",####str)
DO WHILE ####i > 0
   ####str0 = SUBSTR(####str,1,####i-1)
   ####str2 = SUBSTR(####str,####i)
   ####str2 = TRANSLATE(####str2,"               "," &./()*&%$#@:<>")
   ####str2 = WORD(####str2,1)
   ####l = LENGTH(####str2)+1
   ####str3 = SUBSTR(####str,####i+####l)
   IF ####str2 = ZCLONE THEN ####str2 = ipds
   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)
   ####str = ####str0""####str2""####str3
   ####i = POS("&",####str)
END
RETURN ####str

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Add a text line to a queue.  (actually a  */
/* stem variable.)  This allows us to manage */
/* the output from various processes and     */
/* give the user a more orderly output.      */
/* The "queue" names must be numbers, due to */
/* the vagaries of the rexx interpreter.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* To store a line in queue #1:              */
/*   call qu 1,'Hello World!!'               */
/* To print all lines from queue #1:         */
/*   DO x = 1 TO q.1.0                       */
/*      SAY q.1.x                            */
/*   END                                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qu:
PARSE ARG #q,#data
#ctr = VALUE(q.#q.0)
IF DATATYPE(#ctr) /= 'NUM' THEN DO
   q.#q.0 = 0
   #ctr = 0
END
#ctr=#ctr+1; q.#q.0=#ctr
q.#q.#ctr = #data
return
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Print out all lines of a queue.           */
/* #q   = Queue number to print (1..n)       */
/* #box = 1 -> print line within box chars.  */
/* #box = 0 -> print line w/no box chars.    */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qup:
PARSE ARG #q,#box
IF #box /= 1 THEN #box = 0
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN
DO ##x = 1 TO q.#q.0
   IF #box THEN say box(q.#q.##x)
   ELSE            say q.#q.##x
END
RETURN

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Queue has lines: 0|1                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/
quhaslines:
PARSE ARG #q
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0
ELSE RETURN 1

/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Get volume for a given dataset.           */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getvol:
PARSE ARG ####d
DO ####x=1 TO DS.0
   IF \isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME
   ELSE                               ####d2 = DS.####x.DSN
   IF ####d = ####d2 THEN RETURN DS.####x.VOL
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* InsertIntoMember:  Insert some text into  */
/* a member, but only if a search string is  */
/* found/not found.  If ##negative is set to */
/* 1, then only insert if the search string  */
/* is not found.  Otherwise, only insert the */
/* string if the search string IS found.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
insertIntoMember:
PARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative

IF setinp(##ds, ##mem) THEN DO
   ##foun=0
   DO ##xx = 1 TO INPUT.0
      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1
   END
   IF ##negative  = 1 &  ##foun THEN RETURN 0
   IF ##negative /= 1 & \##foun THEN RETURN 0
   call clsinp ##ds, ##mem
   call setout ##ods, ##omem
   DO ##xx = 1 TO INPUT.0
      call jcl INPUT.##xx
   END
END
ELSE DO
   call setout ##ods, ##omem
END
call jcl ##txt
call clsout ##ds, ##mem
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* hasParms - True if any of the coded parms */
/* are present for a dataset.                */
/*- - - - - - - - - - - - - - - - - - - - - -*/
hasParms:
PARSE ARG ##prms, ##dsprms
##dsprms = TRANSLATE(##dsprms,' ',',')
DO ####hp = 1 TO WORDS(##prms)
   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* vsam_part:  Return name of DATA or INDEX  */
/* component of a VSAM file.                 */
/*- - - - - - - - - - - - - - - - - - - - - -*/
vsam_part:
ARG ##part,##ds
##x = OUTTRAP('##y.',25)
"LISTC ENT('"ds"')"
##rc = rc
##x = OUTTRAP('OFF')
DO ##x = 1 TO ##y.0
   say ##y.##x
   PARSE VAR ##y.##x (##part) "------- " zzdsn .
   IF zzdsn /= "" THEN RETURN zzdsn
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* volsym:  If USESYM=YES in @PARMS, then    */
/* substitute "&SYSRn" for the volser passed.*/
/* Otherwise, just spit back the volser.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
volsym:
PARSE ARG ##volser
IF isblank("USESYM") THEN RETURN ##volser
IF USESYM /= "YES" & USERSYM /= "1" THEN RETURN ##volser

DO ##zz = 1 TO 99
   IF \isblank("VOLSER"##zz) & \isblank("ADDR"##zz) THEN DO
      ###zvolser = VALUE("VOLSER"##zz)
      IF ##volser = ###zvolser THEN RETURN "&SYSR"##zz
   END
END

RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getssa: Return the appropriate SSA for a  */
/* dataset.  If usercat is defined and an    */
/* alias to the usercat would be applied to  */
/* this dataset, then return the SSAU value. */
/* Else, return the SSA value (for the mcat).*/
/*- - - - - - - - - - - - - - - - - - - - - -*/
getssa:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN SSA

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) & \isblank("NEWUCAT") THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN SSAU
   END
END

RETURN SSA

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getcat: Return the appropriate catalog in */
/* which to catalog a dataset--either the    */
/* mastercat or usercat.                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getcat:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN NEWMCAT

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT
   END
END

RETURN NEWMCAT

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- end low level functions -------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
./ ADD NAME=#DELSSA
/*---------------------------------------------------Rexx--*/
/* ZCLONE  - Build JCL and other elements for cloning a    */
/*           z/OS system.                                  */
/*---------------------------------------------------------*/
/* #DELSSA  - Delete SSA.                                  */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
ARG jobnum ipds opds zzprms .
IF \varinit() THEN RETURN 1 /* Read parms, initialize vars. */
call parse_dataset

/*=========================================================*/
/* JOB: Delete the SSA (System Specific Alias)             */
/*=========================================================*/
Say "Building Job "jobnum": Delete SSA: "ssa
call setout opds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "DELSSA  - Delete the System Specifc Aliases"
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//DELSSA   EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN    DD * "
call jcl " DELETE "strip(ssa,"B",".")" ALIAS"
call jcl " "
IF \isblank('NEWUCAT') & \isblank('SSAU') THEN,
call jcl " DELETE "strip(ssau,"B",".")" ALIAS"
call jcl " "

call clsout opds,'JOB'jobnum

RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions - v3.8 ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
IF isblank('@DATASET') THEN zzdsmem = '@DATASET'
ELSE zzdsmem = @DATASET
call setinp ipds,zzdsmem,'D.'
DO ###xx = 1 TO D.0
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN zcontin = 1
   ELSE zcontin = 0
   zrest = STRIP(zrest,"T")
   zrest = STRIP(zrest,"T","-")
   zrest = STRIP(zrest,"T","+")
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */
/*---------------------------------------------------------*/
dsdefined:
ARG #x##dsn2
DO #x#x2 = 1 TO DS.0
   IF DS.#x#x2.verb /= "DATASET" THEN ITERATE
   IF SYMBOL("DS."#x#x2".NEWNAME") = "VAR" THEN,
      #x##dsn = DS.#x#x2.NEWNAME
   ELSE #x##dsn = DS.#x#x2.DSN
   IF #x##dsn2 = #x##dsn THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.  The list  */
/* returned is a space delimited list of dsn+volume pairs, */
/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */
/* The parse_dataset routine must have already be run for  */
/* this routine to work.                                   */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ###xx = 1 TO DS.0
   IF DS.###xx.verb /= "DATASET" THEN ITERATE
   IF attrib(##prm,DS.###xx.PARM) THEN DO
      IF SYMBOL("DS."###xx".NEWNAME") = "VAR" THEN,
      ###dslst = ###dslst" "DS.###xx.NEWNAME DS.###xx.VOL
      ELSE,
      ###dslst = ###dslst" "DS.###xx.DSN DS.###xx.VOL
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* dstype - Return dataset type.                           */
/*---------------------------------------------------------*/
dstype:
ARG ##ds
##x = OUTTRAP('##y.',25)
"LISTD '"##ds"'"
##rc = rc
##x = OUTTRAP('OFF')
IF ##rc > 0 THEN RETURN "ERROR"
ELSE RETURN WORD(##y.3,WORDS(##y.3))

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),ZCLONE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
IF \setinp(ipds,zzprms,'PARMS.') THEN DO
   SAY "Error: Unable to allocate parms member:"ipds"("zzprms")."
   RETURN 0
END
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/* ' .     /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
/* IF r = "" THEN ITERATE */
   r = varsub(r)
   INTERPRET q '= "'r'"'
END
RETURN 1

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem, ##mode
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
IF ##mode = "" THEN ##mode = "SHR"
"ALLOC FI(output) DA('"##ds"("##mem")') "##mode
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
IF SYSDSN("'"##ds2"("##mem2")'") /= "OK" THEN RETURN 0
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(opds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(opds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str ##str2 '.' .
RETURN ##str2

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*---------------------------------------------------------*/
/* nonblank - Determine if a variable is blank or undef.   */
/*---------------------------------------------------------*/
isblank:
PARSE ARG #prm
IF VALUE(#prm) = "" THEN RETURN 1
IF SYMBOL(#prm) = = "LIT" THEN RETURN 1
RETURN 0

/*-------------------------------------------*/
/* Variable substitution.  Return a string   */
/* with all variables interpolated.  Vars    */
/* either be vars coded in the rexx exec     */
/* itself, or parms coded in the @PARMS file.*/
/*-------------------------------------------*/
varsub:
PARSE ARG ####str
####i = POS("&",####str)
DO WHILE ####i > 0
   ####str0 = SUBSTR(####str,1,####i-1)
   ####str2 = SUBSTR(####str,####i)
   ####str2 = TRANSLATE(####str2,"               "," &./()*&%$#@:<>")
   ####str2 = WORD(####str2,1)
   ####l = LENGTH(####str2)+1
   ####str3 = SUBSTR(####str,####i+####l)
   IF ####str2 = ZCLONE THEN ####str2 = ipds
   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)
   ####str = ####str0""####str2""####str3
   ####i = POS("&",####str)
END
RETURN ####str

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Add a text line to a queue.  (actually a  */
/* stem variable.)  This allows us to manage */
/* the output from various processes and     */
/* give the user a more orderly output.      */
/* The "queue" names must be numbers, due to */
/* the vagaries of the rexx interpreter.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* To store a line in queue #1:              */
/*   call qu 1,'Hello World!!'               */
/* To print all lines from queue #1:         */
/*   DO x = 1 TO q.1.0                       */
/*      SAY q.1.x                            */
/*   END                                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qu:
PARSE ARG #q,#data
#ctr = VALUE(q.#q.0)
IF DATATYPE(#ctr) /= 'NUM' THEN DO
   q.#q.0 = 0
   #ctr = 0
END
#ctr=#ctr+1; q.#q.0=#ctr
q.#q.#ctr = #data
return
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Print out all lines of a queue.           */
/* #q   = Queue number to print (1..n)       */
/* #box = 1 -> print line within box chars.  */
/* #box = 0 -> print line w/no box chars.    */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qup:
PARSE ARG #q,#box
IF #box /= 1 THEN #box = 0
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN
DO ##x = 1 TO q.#q.0
   IF #box THEN say box(q.#q.##x)
   ELSE            say q.#q.##x
END
RETURN

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Queue has lines: 0|1                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/
quhaslines:
PARSE ARG #q
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0
ELSE RETURN 1

/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Get volume for a given dataset.           */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getvol:
PARSE ARG ####d
DO ####x=1 TO DS.0
   IF \isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME
   ELSE                               ####d2 = DS.####x.DSN
   IF ####d = ####d2 THEN RETURN DS.####x.VOL
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* InsertIntoMember:  Insert some text into  */
/* a member, but only if a search string is  */
/* found/not found.  If ##negative is set to */
/* 1, then only insert if the search string  */
/* is not found.  Otherwise, only insert the */
/* string if the search string IS found.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
insertIntoMember:
PARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative

IF setinp(##ds, ##mem) THEN DO
   ##foun=0
   DO ##xx = 1 TO INPUT.0
      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1
   END
   IF ##negative  = 1 &  ##foun THEN RETURN 0
   IF ##negative /= 1 & \##foun THEN RETURN 0
   call clsinp ##ds, ##mem
   call setout ##ods, ##omem
   DO ##xx = 1 TO INPUT.0
      call jcl INPUT.##xx
   END
END
ELSE DO
   call setout ##ods, ##omem
END
call jcl ##txt
call clsout ##ds, ##mem
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* hasParms - True if any of the coded parms */
/* are present for a dataset.                */
/*- - - - - - - - - - - - - - - - - - - - - -*/
hasParms:
PARSE ARG ##prms, ##dsprms
##dsprms = TRANSLATE(##dsprms,' ',',')
DO ####hp = 1 TO WORDS(##prms)
   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* vsam_part:  Return name of DATA or INDEX  */
/* component of a VSAM file.                 */
/*- - - - - - - - - - - - - - - - - - - - - -*/
vsam_part:
ARG ##part,##ds
##x = OUTTRAP('##y.',25)
"LISTC ENT('"ds"')"
##rc = rc
##x = OUTTRAP('OFF')
DO ##x = 1 TO ##y.0
   say ##y.##x
   PARSE VAR ##y.##x (##part) "------- " zzdsn .
   IF zzdsn /= "" THEN RETURN zzdsn
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* volsym:  If USESYM=YES in @PARMS, then    */
/* substitute "&SYSRn" for the volser passed.*/
/* Otherwise, just spit back the volser.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
volsym:
PARSE ARG ##volser
IF isblank("USESYM") THEN RETURN ##volser
IF USESYM /= "YES" & USERSYM /= "1" THEN RETURN ##volser

DO ##zz = 1 TO 99
   IF \isblank("VOLSER"##zz) & \isblank("ADDR"##zz) THEN DO
      ###zvolser = VALUE("VOLSER"##zz)
      IF ##volser = ###zvolser THEN RETURN "&SYSR"##zz
   END
END

RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getssa: Return the appropriate SSA for a  */
/* dataset.  If usercat is defined and an    */
/* alias to the usercat would be applied to  */
/* this dataset, then return the SSAU value. */
/* Else, return the SSA value (for the mcat).*/
/*- - - - - - - - - - - - - - - - - - - - - -*/
getssa:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN SSA

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) & \isblank("NEWUCAT") THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN SSAU
   END
END

RETURN SSA

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getcat: Return the appropriate catalog in */
/* which to catalog a dataset--either the    */
/* mastercat or usercat.                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getcat:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN NEWMCAT

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT
   END
END

RETURN NEWMCAT

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- end low level functions -------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
./ ADD NAME=#INITVOL
/*---------------------------------------------------Rexx--*/
/* ZCLONE  - Build JCL and other elements for cloning a    */
/*           z/OS system.                                  */
/*---------------------------------------------------------*/
/* #INITVOL - Initialize RESCUE volume.                    */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
ARG jobnum ipds opds zzprms .
IF \varinit() THEN RETURN 1 /* Read parms, initialize vars. */
call parse_dataset

/*---------------------------------------------------------*/
/* See if COMMANDPGM and WAITPGM are coded in parms.  If   */
/* not, then don't code the ONLINE and OFFLINE steps.      */
/*---------------------------------------------------------*/
cmdpgm  = \isblank("COMMANDPGM")
waitpg  = \isblank("WAITPGM")

Say "Building Job "jobnum": Init disk pack."
call setout opds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "EXPORTD - Export the new mcat to clean up from previous runs."
IF cmdpgm THEN,
call jcc "OFFLINE - Vary the target VOLSER offline."
call jcc "DSFINIT - Initialize volumes with ICKDSF."
IF cmdpgm THEN,
call jcc "ONLINE  - Vary the target VOLSERS online."
call jcc "DEFVVDS - Define VVDSs on volumes."
call jcd
call jcc "NOTE: You will need to reply to the ICKDSF message ICK003D"
call jcc "on the MVS console after submitting this job.BE SURE that"
call jcc "the address specified in this message is the correct disk"
call jcc "unit.  If the wrong address is specified, and this wrong"
call jcc "address is an offline disk unit, it will be completely wiped"
call jcc "out, and will have to be recovered from a backup."

/*---------------------------------------------------------*/
/* Can't automatically do V ONLINE etc., so place notes    */
/* in JCL to that effect.                                  */
/*---------------------------------------------------------*/
IF \cmdpgm THEN DO
   call jcd
   call jcc "NOTE: The 'COMMAND' and/or 'WAIT' programs were not coded "
   call jcc "in the @PARMS member.  You will need to manually vary the "
   call jcc "disk units for the cloned system offline, and online.     "
   call jcc " "
   call jcc "Before running this job, vary the disk unit offline from  "
   call jcc "the MVS console using the command: "
   call jcc "   V "addr",OFFLINE"
   call jcc "After replying to the the ICKDSF message to confirm the"
   call jcc "initialization of the disk pack, you will need to reply"
   call jcc "to the MVS allocation message with the address of the  "
   call jcc "new rescue volume, "addr"."
END
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//EXPORTD    EXEC  PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN      DD * "
call jcl "     EXPORT "newmcat "-"
call jcl "            DISCONNECT    "
IF \isblank('NEWUCAT') THEN DO
   call jcl "     EXPORT "newucat "-"
   call jcl "            DISCONNECT    "
END
call jcl "     SET MAXCC=0  "
/*---------------------------------------------------------*/
/* If COMMAND cmd is available, us it to do the VARY.      */
/*---------------------------------------------------------*/
IF cmdpgm THEN DO
   zpg1=COMMANDPGM
   call jcd
   call jcc   " OFFLINE"
   call jcd
   DO zz = 1 TO 99
      IF \isblank("VOLSER"zz) & \isblank("ADDR"zz) THEN DO
         zaddr = VALUE("ADDR"zz); zvolser = VALUE("VOLSER"zz)
         j =  "//OFFLINE    EXEC PGM="zpg1",PARM='V "zaddr",OFFLINE'"
         call jcl j
         IF waitpg THEN DO
            zpg2=WAITPGM
            call jcl "//WAIT       EXEC PGM="zpg2",PARM=2"
         END
      END
   END
END
/*---------------------------------------------------------*/
/* Write the JCL to initialize the volumes.  Include ipl   */
/* text and bootstrap records for the ADDR1/VOLSER1.       */
/*---------------------------------------------------------*/
DO zz = 1 TO 99
   IF \isblank("VOLSER"zz) & \isblank("ADDR"zz) THEN DO
      zaddr = VALUE("ADDR"zz); zvolser = VALUE("VOLSER"zz)
      call volinit "VOLSER"zz, "ADDR"zz
   END
END
/*---------------------------------------------------------*/
/* If COMMAND cmd is available, us it to do the VARY.      */
/*---------------------------------------------------------*/
IF cmdpgm THEN DO
   zpgm=COMMANDPGM
   call jcd
   call jcc   " ONLINE"
   call jcd
   DO zz = 1 TO 99
      IF \isblank("VOLSER"zz) & \isblank("ADDR"zz) THEN DO
         zaddr = VALUE("ADDR"zz); zvolser = VALUE("VOLSER"zz)
         j =  "//ONLINE     EXEC PGM="zpgm",PARM='V "zaddr",ONLINE'"
         call jcl j
         IF waitpg THEN DO
            zpg2=WAITPGM
            call jcl "//WAIT       EXEC PGM="zpg2",PARM=2"
         END
      END
   END
END

/*---------------------------------------------------------*/
/* Define VVDS on each volume.                             */
/*---------------------------------------------------------*/
call jcd
call jcc   "DEFVVDS - Define VVDS."
call jcd
call jcl "//DEFVVDS  EXEC PGM=IDCAMS"
call jcl "//SYSPRINT DD SYSOUT=*"
DO zz = 1 TO 99
   filenm = "TRGT"RIGHT("00"zz,3)
   volser = VALUE("VOLSER"zz)
   IF \isblank("VOLSER"zz) & \isblank("ADDR"zz) THEN DO
      call jcl "//"filenm"  DD DISP=SHR,UNIT=SYSALLDA,VOL=SER="volser
   END
END
call jcl "//SYSIN    DD *"
DO zz = 1 TO 99
   filenm = "TRGT"RIGHT("00"zz,3)
   volser = VALUE("VOLSER"zz)
   IF \isblank("VOLSER"zz) & \isblank("ADDR"zz) THEN DO
      call jcl " DELETE    SYS1.VVDS.V"volser" -"
      call jcl "           FILE("filenm") CLUSTER PURGE -"
      call jcl "           CATALOG("oldmcat") "
      call jcl " SET MAXCC=0"
      call jcl " "
      call jcl " DEFINE CLUSTER ( -"
      call jcl "           NAME(SYS1.VVDS.V"volser") -"
      call jcl "           CYL(1,1) -"
      call jcl "           VOL("volser") -"
      call jcl "           FILE("filenm") - "
      call jcl "           NONINDEXED - "
      call jcl "           OWNER(RESCUE) ) -"
      call jcl "           CATALOG("oldmcat")"
      call jcl "                            "
   END
END
call clsout opds,'JOB'jobnum

RETURN

/*---------------------------------------------------------*/
/* volinit - Subroutine to initialize a volume.            */
/*---------------------------------------------------------*/
volinit:
ARG ##volser, ##addr
IF \isblank(##volser) & \isblank(##addr) THEN DO
   zvolser = VALUE(##volser); zaddr = VALUE(##addr)
   call jcd
   call jcc   "DSFINIT - DSF Initialize"
   call jcd
   call jcl "//DSFINIT  EXEC PGM=ICKDSF"
   IF ##volser = 'VOLSER1' THEN DO
      call jcl "//IPLTEXT  DD DISP=SHR,VOL=SER="sysres",UNIT=SYSALLDA,"
      call jcl "//         DSN=SYS1.SAMPLIB(IPLRECS)"
      call jcl "//         DD DISP=SHR,VOL=SER="sysres",UNIT=SYSALLDA,"
      call jcl "//         DSN=SYS1.SAMPLIB(IEAIPL00)"
   END
   call jcl "//SYSPRINT DD     SYSOUT=* "
   call jcl "//SYSIN      DD   *        "
   call jcl " INIT     UNIT("zaddr") -   "
   call jcl "          VOLID("zvolser") -"
   call jcl "          VTOC(0,1,14) -  "
   call jcl "          PURGE -  "
   call jcl "          MAP -  "
   IF ##volser = 'VOLSER1' THEN DO
      call jcl "          IPLDD(IPLTEXT) - "
      call jcl "          NOBOOTSTRAP -"
   END
   call jcl "          NOVERIFY -  "
   call jcl "          NOVALIDATE -  "
   call jcl "          NOCHECK    "
   call jcl "//*"
END
RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions - v3.8 ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
IF isblank('@DATASET') THEN zzdsmem = '@DATASET'
ELSE zzdsmem = @DATASET
call setinp ipds,zzdsmem,'D.'
DO ###xx = 1 TO D.0
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN zcontin = 1
   ELSE zcontin = 0
   zrest = STRIP(zrest,"T")
   zrest = STRIP(zrest,"T","-")
   zrest = STRIP(zrest,"T","+")
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */
/*---------------------------------------------------------*/
dsdefined:
ARG #x##dsn2
DO #x#x2 = 1 TO DS.0
   IF DS.#x#x2.verb /= "DATASET" THEN ITERATE
   IF SYMBOL("DS."#x#x2".NEWNAME") = "VAR" THEN,
      #x##dsn = DS.#x#x2.NEWNAME
   ELSE #x##dsn = DS.#x#x2.DSN
   IF #x##dsn2 = #x##dsn THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.  The list  */
/* returned is a space delimited list of dsn+volume pairs, */
/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */
/* The parse_dataset routine must have already be run for  */
/* this routine to work.                                   */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ###xx = 1 TO DS.0
   IF DS.###xx.verb /= "DATASET" THEN ITERATE
   IF attrib(##prm,DS.###xx.PARM) THEN DO
      IF SYMBOL("DS."###xx".NEWNAME") = "VAR" THEN,
      ###dslst = ###dslst" "DS.###xx.NEWNAME DS.###xx.VOL
      ELSE,
      ###dslst = ###dslst" "DS.###xx.DSN DS.###xx.VOL
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* dstype - Return dataset type.                           */
/*---------------------------------------------------------*/
dstype:
ARG ##ds
##x = OUTTRAP('##y.',25)
"LISTD '"##ds"'"
##rc = rc
##x = OUTTRAP('OFF')
IF ##rc > 0 THEN RETURN "ERROR"
ELSE RETURN WORD(##y.3,WORDS(##y.3))

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),ZCLONE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
IF \setinp(ipds,zzprms,'PARMS.') THEN DO
   SAY "Error: Unable to allocate parms member:"ipds"("zzprms")."
   RETURN 0
END
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/* ' .     /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
/* IF r = "" THEN ITERATE */
   r = varsub(r)
   INTERPRET q '= "'r'"'
END
RETURN 1

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem, ##mode
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
IF ##mode = "" THEN ##mode = "SHR"
"ALLOC FI(output) DA('"##ds"("##mem")') "##mode
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
IF SYSDSN("'"##ds2"("##mem2")'") /= "OK" THEN RETURN 0
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(opds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(opds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str ##str2 '.' .
RETURN ##str2

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*---------------------------------------------------------*/
/* nonblank - Determine if a variable is blank or undef.   */
/*---------------------------------------------------------*/
isblank:
PARSE ARG #prm
IF VALUE(#prm) = "" THEN RETURN 1
IF SYMBOL(#prm) = = "LIT" THEN RETURN 1
RETURN 0

/*-------------------------------------------*/
/* Variable substitution.  Return a string   */
/* with all variables interpolated.  Vars    */
/* either be vars coded in the rexx exec     */
/* itself, or parms coded in the @PARMS file.*/
/*-------------------------------------------*/
varsub:
PARSE ARG ####str
####i = POS("&",####str)
DO WHILE ####i > 0
   ####str0 = SUBSTR(####str,1,####i-1)
   ####str2 = SUBSTR(####str,####i)
   ####str2 = TRANSLATE(####str2,"               "," &./()*&%$#@:<>")
   ####str2 = WORD(####str2,1)
   ####l = LENGTH(####str2)+1
   ####str3 = SUBSTR(####str,####i+####l)
   IF ####str2 = ZCLONE THEN ####str2 = ipds
   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)
   ####str = ####str0""####str2""####str3
   ####i = POS("&",####str)
END
RETURN ####str

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Add a text line to a queue.  (actually a  */
/* stem variable.)  This allows us to manage */
/* the output from various processes and     */
/* give the user a more orderly output.      */
/* The "queue" names must be numbers, due to */
/* the vagaries of the rexx interpreter.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* To store a line in queue #1:              */
/*   call qu 1,'Hello World!!'               */
/* To print all lines from queue #1:         */
/*   DO x = 1 TO q.1.0                       */
/*      SAY q.1.x                            */
/*   END                                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qu:
PARSE ARG #q,#data
#ctr = VALUE(q.#q.0)
IF DATATYPE(#ctr) /= 'NUM' THEN DO
   q.#q.0 = 0
   #ctr = 0
END
#ctr=#ctr+1; q.#q.0=#ctr
q.#q.#ctr = #data
return
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Print out all lines of a queue.           */
/* #q   = Queue number to print (1..n)       */
/* #box = 1 -> print line within box chars.  */
/* #box = 0 -> print line w/no box chars.    */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qup:
PARSE ARG #q,#box
IF #box /= 1 THEN #box = 0
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN
DO ##x = 1 TO q.#q.0
   IF #box THEN say box(q.#q.##x)
   ELSE            say q.#q.##x
END
RETURN

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Queue has lines: 0|1                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/
quhaslines:
PARSE ARG #q
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0
ELSE RETURN 1

/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Get volume for a given dataset.           */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getvol:
PARSE ARG ####d
DO ####x=1 TO DS.0
   IF \isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME
   ELSE                               ####d2 = DS.####x.DSN
   IF ####d = ####d2 THEN RETURN DS.####x.VOL
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* InsertIntoMember:  Insert some text into  */
/* a member, but only if a search string is  */
/* found/not found.  If ##negative is set to */
/* 1, then only insert if the search string  */
/* is not found.  Otherwise, only insert the */
/* string if the search string IS found.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
insertIntoMember:
PARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative

IF setinp(##ds, ##mem) THEN DO
   ##foun=0
   DO ##xx = 1 TO INPUT.0
      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1
   END
   IF ##negative  = 1 &  ##foun THEN RETURN 0
   IF ##negative /= 1 & \##foun THEN RETURN 0
   call clsinp ##ds, ##mem
   call setout ##ods, ##omem
   DO ##xx = 1 TO INPUT.0
      call jcl INPUT.##xx
   END
END
ELSE DO
   call setout ##ods, ##omem
END
call jcl ##txt
call clsout ##ds, ##mem
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* hasParms - True if any of the coded parms */
/* are present for a dataset.                */
/*- - - - - - - - - - - - - - - - - - - - - -*/
hasParms:
PARSE ARG ##prms, ##dsprms
##dsprms = TRANSLATE(##dsprms,' ',',')
DO ####hp = 1 TO WORDS(##prms)
   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* vsam_part:  Return name of DATA or INDEX  */
/* component of a VSAM file.                 */
/*- - - - - - - - - - - - - - - - - - - - - -*/
vsam_part:
ARG ##part,##ds
##x = OUTTRAP('##y.',25)
"LISTC ENT('"ds"')"
##rc = rc
##x = OUTTRAP('OFF')
DO ##x = 1 TO ##y.0
   say ##y.##x
   PARSE VAR ##y.##x (##part) "------- " zzdsn .
   IF zzdsn /= "" THEN RETURN zzdsn
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* volsym:  If USESYM=YES in @PARMS, then    */
/* substitute "&SYSRn" for the volser passed.*/
/* Otherwise, just spit back the volser.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
volsym:
PARSE ARG ##volser
IF isblank("USESYM") THEN RETURN ##volser
IF USESYM /= "YES" & USERSYM /= "1" THEN RETURN ##volser

DO ##zz = 1 TO 99
   IF \isblank("VOLSER"##zz) & \isblank("ADDR"##zz) THEN DO
      ###zvolser = VALUE("VOLSER"##zz)
      IF ##volser = ###zvolser THEN RETURN "&SYSR"##zz
   END
END

RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getssa: Return the appropriate SSA for a  */
/* dataset.  If usercat is defined and an    */
/* alias to the usercat would be applied to  */
/* this dataset, then return the SSAU value. */
/* Else, return the SSA value (for the mcat).*/
/*- - - - - - - - - - - - - - - - - - - - - -*/
getssa:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN SSA

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) & \isblank("NEWUCAT") THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN SSAU
   END
END

RETURN SSA

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getcat: Return the appropriate catalog in */
/* which to catalog a dataset--either the    */
/* mastercat or usercat.                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getcat:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN NEWMCAT

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT
   END
END

RETURN NEWMCAT

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- end low level functions -------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
./ ADD NAME=#MEMBERS
/*---------------------------------------------------Rexx--*/
/* MEMBERS - Build various RESCUE system members.          */
/*---------------------------------------------------------*/
/* No jobs are generated by this member.                   */
/*---------------------------------------------------------*/
/* 03/08/2007 John C. Miller                               */
/*---------------------------------------------------------*/
ARG ipds opds zzprms .
IF \varinit() THEN RETURN 1 /* Read parms, initialize vars. */
call parse_dataset

/*---------------------------------------------------------*/
/* Call routines to build various members.                 */
/*---------------------------------------------------------*/
call iodf              /* LOAD00 for IODF.                 */
call ieasym            /* IEASYM00 system symbols.         */
call apf               /* PROGA0 for APF.                  */
call lnklst            /* PROGL0 for LNKLST.               */
call lpa               /* LPALST00.                        */
call jes2              /* PROC for JES2.                   */
call jes2parm          /* Create JES2PARM.                 */
call tsoproc           /* TSO LOGON PROC.                  */
call tso               /* TSO STARTED PROC.                */
call vtamproc          /* VTAM startup proc.               */
call mstrjcl           /* MSTRJCL00.                       */
call bpxprm            /* BPXPRM00 OMVS parms.             */
call igdsms            /* IGDSMS00 member.                 */
call couple            /* COUPLE00 member.                 */
call vatlst            /* VATLST00 member.                 */
call ieasys            /* IEASYS00 member.                 */

exit

/*---------------------------------------------------------*/
/* COUPLEnn member:  For now, we only support operation    */
/* in sysplex-local mode using   COUPLE SYSPLEX(LOCAL)     */
/*---------------------------------------------------------*/
/* @PARM statements used to create COUPLE00 member.        */
/* Not currently used.                                     */
/*---------------------------------------------------------*/
/* Couple datasets.                                        */
/*            DSN               Volume # to put ds on.     */
/*---------------------------------------------------------*/
/*  XCF1        = SYS1.XCF.CDS01    1                      */
/*  XCF2        = SYS1.XCF.CDS02    2                      */
/*  WLM1        = SYS1.WLM.CDS01    1                      */
/*  WLM2        = SYS1.WLM.CDS02    2                      */
/*  LOGR1       = SYS1.LOGR.CDS01   1                      */
/*  LOGR2       = SYS1.LOGR.CDS02   2                      */
/*                                                         */
/*  SYSPLEX     = LOCAL                                    */
/*---------------------------------------------------------*/
RETURN                                                     */

/*---------------------------------------------------------*/
/* LOAD00 member: SYS1.IPLPARM                             */
/*---------------------------------------------------------*/
iodf:
SAY "Building LOAD00 IPLPARM member."
##iodf = "00"
##iodfsys = "SYS1"
/* See if nonstandard SYSx prefix. */
IF substr(iodf,1,3) = 'SYS' THEN DO
   PARSE VAR iodf ##iodfsys "." .
END

/* See if nonstandard IODFxx prefix. */
##y9 = POS('.IODF',iodf)
IF ##y9 > 0 THEN ##iodf = substr(iodf,##y9+5,2)
call setout opds,'LOAD00' /* Set output member name.  */
call jcl "IODF     "##iodf" "substr(##iodfsys,1,8)"",
         substr(ioconfigid,1,9)"00"
call jcl "NUCLEUS  1"
call jcl "SYSCAT   "substr(newmcatvol,1,6)"113C"newmcat
call jcl "IEASYM   00"

/* Add PARMLIBs */
libs = xdslist('PARMLIB')
DO x = 1 TO WORDS(libs) BY 2
   volser = WORD(libs,x+1)
   call jcl "PARMLIB  "substr(WORD(libs,x),1,45)volser
END

call clsout opds,'LOAD00'
RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of LOAD00 Member.                                   */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* IEASYM member: SYS1.PARMLIB                             */
/*---------------------------------------------------------*/
ieasym:
SAY "Building IEASYM PARMLIB member."
call setout opds,'IEASYM00' /* Set output member name.  */

/*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */
/* Create a SYSDEF and a throwaway SYMDEF entry.        */
/*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */
call jcl "SYSDEF"
call jcl "   SYMDEF(&SSALIAS='"SSA"')"
/*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */
/* Iterate through VOLSER2-VOLSERn and create a SYSRn   */
/* system variable in IEASYM00                          */
/*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */
DO zz = 2 TO 99
   IF \isblank("VOLSER"zz) & \isblank("ADDR"zz) THEN DO
      zvolser = VALUE("VOLSER"zz)
      call jcl "   SYMDEF(&SYSR"zz"='"zvolser"')"
   END
END

call clsout opds,'IEASYM00'
RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of IEASYM Member.                                   */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* PROGA0 Parmlib member: APF entries.                     */
/*---------------------------------------------------------*/
/* Creates entries for all datasets in @DATASET that have  */
/* PARM(APF)                                               */
/*---------------------------------------------------------*/
apf:
SAY "Building PROGA0 PARMLIB member."
call setout opds,'PROGA0' /* Set output member name.  */

call jcl "/*--------------------------------------------------*/"
call jcl "/* APF entries dynamically built by RESCUE exec.    */"
call jcl "/*--------------------------------------------------*/"
call jcl "APF FORMAT(DYNAMIC)"

/* Add APF LIBs */
libs = xdslist('APF')
DO x = 1 TO WORDS(libs) BY 2
   ##z10 = "APF ADD "substr("DSNAME("WORD(libs,x)")",1,46)
   ##z10 = ##z10"VOLUME("WORD(libs,x+1)")"
   call jcl ##z10
END

call clsout opds,'PROGA0'
RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of PROGA0 Member.                                   */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* PROGL0 Parmlib member: LNKLST entries                   */
/*---------------------------------------------------------*/
/* Creates entries for all datasets in @DATASET that have  */
/* PARM(LNKLST)                                            */
/*---------------------------------------------------------*/
lnklst:
SAY "Building PROGL0 PARMLIB member."
call setout opds,'PROGL0' /* Set output member name.  */

call jcl "/*--------------------------------------------------*/"
call jcl "/* LNKLST entries dynamically built by RESCUE exec. */"
call jcl "/*--------------------------------------------------*/"
call jcl "LNKLST DEFINE NAME(LNKLST00)"

/* Add LNKLST LIBs */
libs = xdslist('LNK')
DO x = 1 TO WORDS(libs) BY 2
   ds = WORD(libs,x); volser = WORD(libs,x+1)
   ##z10 = "LNKLST ADD NAME(LNKLST00)"
   call jcl ##z10
   ##z10 = "     "substr("DSNAME("ds")",1,40)"VOLUME("volser")"
   call jcl ##z10
END

call jcl "LNKLST ACTIVATE NAME(LNKLST00)"
call clsout opds,'PROGL0'

RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of PROGL0 Member.                                   */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* LPALST00 Parmlib member - LPA libraries.                */
/*---------------------------------------------------------*/
/* Creates entries for all datasets in @DATASET that have  */
/* PARM(LPA)                                               */
/*---------------------------------------------------------*/
lpa:
SAY "Building LPALST00 PARMLIB member."
call setout opds,'LPALST00' /* Set output member name.  */

/* Add LPALST LIBs */
libs = xdslist('LPA')
DO x = 1 TO WORDS(libs) BY 2
   IF x < WORDS(libs)-1 THEN,
   call jcl WORD(libs,x)","
   ELSE,
   call jcl WORD(libs,x)
END

call clsout opds
RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of LPALST00 Member.                                 */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


/*---------------------------------------------------------*/
/* JES2 - Startup PROC.                                    */
/*---------------------------------------------------------*/
/* Adds a DD statement under the //PROC00 DDNAME for all   */
/* datasets in @DATASET that have PARM(PROCLIB)            */
/*---------------------------------------------------------*/
jes2:
SAY "Building JES2 PROC."
call setout opds,'JES2' /* Set output member name.  */
libs = xdslist('ZPARMLIB')
zzparmlib = WORD(libs,1)

call jcd
call jcc "JES2 Startup PROC."
call jcc "Built dynamically by ZCLONE exec, "mydate()
call jcd
call jcl "//JES2     PROC JESPARM=JES2PARM"
call jcl "//IEFPROC  EXEC PGM=HASJES20,"
call jcl "//            DPRTY=(15,15),TIME=1440,PERFORM=9"
call jcl "//HASPPARM DD DISP=SHR,DSN="zzparmlib"(&JESPARM)"

/* Add PROCLIBs */
libs = xdslist('PROCLIB')
DO x = 1 TO WORDS(libs) BY 2
   IF x = 1 THEN,
   call jcl "//PROC00   DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

call jcl "//*"
call jcl "//IEFRDER  DD SYSOUT=*"
call jcl "//*"
call jcl "//HASPLIST DD DDNAME=IEFRDER"
call jcl "//*"
call clsout opds,'JES2'

RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of JES2 PROC Member.                                */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* JES2PARM - JES2 parameter member.                       */
/*---------------------------------------------------------*/
/* Uses the ZJES2PRM member as a model, and adds SPOOLDEF  */
/* and CKPTDEF statements.  The checkpoint datasets coded  */
/* are the first one or two datasets that have             */
/* PARM(HASPCKPT) coded.  The VOLUME= parm of the SPOOLDEF */
/* statement is derived as follows:  1) Find the first ds  */
/* in @DATASET that has PARM(HASPACE).  2) The volume that */
/* this dataset resides on is used as the base for the     */
/* VOLUME= parm.  The SPOOLPRF parameter coded in @PARMS   */
/* determines the length of the VOLUEM= parm.  E.g., if    */
/* SYS1.HASPACE PARM(HASPACE) VOLUME(RESC1A) is coded in   */
/* @DATASET, AND SPOOLPRF=5 IN @PARMS, THEN VOLUME=RESC1   */
/* will be the result.                                     */
/*---------------------------------------------------------*/
jes2parm:
SAY "Building JES2 PARMS."
call setout opds,'JES2PARM'   /* Set output member name.  */
call setinp ipds,'ZJES2PRM','JES2PRM.' /* Input member name. */

call jcl "/*-------------------------------------------------------*/"
call jcl "/* JES2 Parameter deck.                                  */"
call jcl "/* Built dynamically by RESCUE exec, "mydate()"          */"
call jcl "/*-------------------------------------------------------*/"
ckpts = xdslist('HASPCKPT')
IF WORDS(ckpts)>2 THEN ckptcomma = ","
ELSE ckptcomma = ""
ckptds = WORD(ckpts,1); ckptvol = WORD(ckpts,2)
call jcl "CKPTDEF  CKPT1=(DSNAME="ckptds","
call jcl "         INUSE=YES,VOL="ckptvol")"ckptcomma
IF WORDS(ckpts)>2 THEN DO
   ckptds = WORD(ckpts,3); ckptvol = WORD(ckpts,4)
   call jcl "         CKPT2=(DSNAME="ckptds","
   call jcl "         INUSE=YES,VOL="ckptvol")"
END
/*-------------------------------------*/
/* Build SPOOLDEF statement.           */
/* spoolprf is from @PARMS and is the  */
/* length of the VOLUME= parm.         */
/*-------------------------------------*/
spool = xdslist('HASPACE')
spoolds = WORD(spool,1); spoolvol = WORD(spool,2)
IF SYMBOL("spoolprf") /= "VAR" THEN spoolprf = 4
IF DATATYPE(spoolprf) /= "N"   THEN spoolprf = 4
IF spoolprf < 4                THEN spoolprf = 4
IF spoolprf > 6                THEN spoolprf = 4
spoolvol = substr(spoolvol,1,spoolprf)
call jcl "SPOOLDEF BUFSIZE=3856,"
call jcl "         DSNAME="spoolds","
call jcl "         FENCE=NO,"
call jcl "         SPOOLNUM=32,"
call jcl "         TGBPERVL=5,"
call jcl "         TGSPACE=(MAX=16288,WARN=80),"
call jcl "         TGSIZE=33,"
call jcl "         TRKCELL=5,"
call jcl "         VOLUME="spoolvol
/*-------------------------------------*/
/*  Copy rest of parms from JES2PRM.   */
/*-------------------------------------*/
DO x = 1 TO JES2PRM.0
   call jcl JES2PRM.x
END

call clsout opds,'JES2PARM'
DROP JES2PRM.

RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of JES2PARM Member.                                 */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* BPXPRM00 - OMVS Parmlib member.                         */
/*---------------------------------------------------------*/
/* Copy model member ZBPXPRM to output member BPXPRM00.    */
/* Also add to BPXPRM00 mount statements for any OMVS      */
/* files.                                                  */
/*---------------------------------------------------------*/

/*=====================================*/
/*  Build the BPXPRM00 member.         */
/*=====================================*/
bpxprm:
SAY "Building OMVS PARMLIB member BPXPRM00."
call setout opds,'BPXPRM00'    /* Set output member name.  */
call setinp ipds,'ZBPXPRM','BPXPRM.' /* Input member name. */

/*----------------------------------------*/
/* Create header and copy model BPXPRM.   */
/*----------------------------------------*/
call jcl "/*-------------------------------------------------------*/"
call jcl "/* OMVS parameters.                                      */"
call jcl "/* Built dynamically by RESCUE exec, "mydate()"          */"
call jcl "/*-------------------------------------------------------*/"
DO x = 1 TO BPXPRM.0
   call jcl BPXPRM.x
END
call jcl " "

/*----------------------------------------*/
/*  Build MOUNT statments for OMVS libs.  */
/*----------------------------------------*/
DO y = 1 TO DS.0
   /*--------------------------------------------------------*/
   /* Loop through the DS. stem var for any dataset with     */
   /* a MOUNT() parameter, and create a mount statement.     */
   /*--------------------------------------------------------*/
   IF SYMBOL("DS."y".MOUNT") /= "VAR" THEN ITERATE
   IF SYMBOL("DS."y".TYPE")  /= "VAR" THEN DS.x.TYPE="HFS"
   IF SYMBOL("DS."y".MODE")  /= "VAR" THEN DS.x.MODE="RDWR"
   call omvsmnt DS.y.MOUNT,DS.y.DSN
END

call clsout opds,'BPXPRM00'
DROP BPXPRM.
RETURN

/* subr. */
omvsmnt:
PARSE ARG ##mountpt, ##omvsds
##mountpt = STRIP(##mountpt,"B","'")
IF ##mountpt = '/'    THEN DO
   call jcl "ROOT     FILESYSTEM('"##omvsds"')"
   call jcl "         TYPE(HFS)"
   call jcl "         MODE(RDWR)"
   call jcl " "
END
ELSE DO
   call jcl "MOUNT    FILESYSTEM('"##omvsds"')"
   call jcl "         MOUNTPOINT('"##mountpt"')"
   call jcl "         TYPE(HFS)"
   call jcl "         MODE(RDWR)"
   call jcl " "
END
RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of BPXPRM00 Parmlib member.                         */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*=====================================*/
/*  Build the TSO STARTUP PROC.        */
/*=====================================*/
tso:

SAY "Building TSO STARTUP PROC" tsoproc"."
call setout opds,'TSO'      /* Set output member name.  */
libs = xdslist('ZPARMLIB')  /* Get name of our parmlib. */
zzparmlib = WORD(libs,1)

call jcd
call jcc "TSO STARTUP PROC"
call jcc "Built dynamically by ZCLONE exec, "mydate()
call jcd
call jcl "//TSO     PROC MBR=TSOKEY00"
call jcl "//STEP1   EXEC PGM=IKTCAS00,TIME=1440"
call jcl "//PARMLIB   DD  DSN="zzparmlib"(&MBR),DISP=SHR,FREE=CLOSE"
call jcl "//PRINTOUT  DD  SYSOUT=*,FREE=CLOSE"
call jcl "//*"
call clsout opds,'TSO'
RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of TSO STARTUP PROC.                                */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*=====================================*/
/*  Build the TSO LOGON PROC.          */
/*=====================================*/
tsoproc:
IF SYMBOL("TSOPROC") = 'LIT' THEN DO
   Say "TSOPROC name not defined in @PARMS member, no TSO PROC created."
   RETURN
END

SAY "Building TSO LOGON PROC" tsoproc"."

call setout opds,tsoproc    /* Set output member name.  */

call jcd
call jcc "TSO LOGON PROC: "tsoproc"."
call jcc "Built dynamically by RESCUE exec, "mydate()
call jcd
p = substr(tsoproc,1,8)
call jcl "//"p" PROC"
call jcl "//IKJACCNT EXEC PGM=IKJEFT01,DYNAMNBR=200,PARM='%ISPALLOC'"

/* Add ISPPLIBs */
libs = xdslist('ISPPLIB')
DO x = 1 TO WORDS(libs) BY 2
   IF x = 1 THEN,
   call jcl "//ISPPLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add ISPMLIBs */
libs = xdslist('ISPMLIB')
DO x = 1 TO WORDS(libs) BY 2
   IF x = 1 THEN,
   call jcl "//ISPMLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add ISPSLIBs */
libs = xdslist('ISPSLIB')
DO x = 1 TO WORDS(libs) BY 2
   IF x = 1 THEN,
   call jcl "//ISPSLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add ISPLLIBs */
libs = xdslist('ISPLLIB')
DO x = 1 TO WORDS(libs) BY 2
   IF x = 1 THEN,
   call jcl "//ISPLLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add ISPTLIBs */
libs = xdslist('ISPTLIB')
DO x = 1 TO WORDS(libs) BY 2
   IF x = 1 THEN,
   call jcl "//ISPTLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add SYSPROCs */
libs = xdslist('SYSPROC')
DO x = 1 TO WORDS(libs) BY 2
   IF x = 1 THEN,
   call jcl "//SYSPROC  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add SYSHELPs */
libs = xdslist('SYSHELP')
DO x = 1 TO WORDS(libs) BY 2
   IF x = 1 THEN,
   call jcl "//SYSHELP  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add SYSLBC */
libs = xdslist('SYSLBC')
IF words(libs) > 0 THEN DO
   call jcl "//SYSLBC   DD DISP=SHR,DSN="WORD(libs,1)
END

/* Add MISC LOGON statements. */

call jcl "//SYSPRINT DD TERM=TS,SYSOUT=Z"
call jcl "//SYSTERM  DD TERM=TS,SYSOUT=Z"
call jcl "//SYSIN    DD TERM=TS "

call clsout opds,tsoproc

RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of TSOPROC member.                                  */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*=====================================*/
/*  Build the VTAM startup PROC.       */
/*=====================================*/
vtamproc:
SAY "Building VTAM PROC."
call setout opds,'VTAM' /* Set output member name.  */

call jcd
call jcc "VTAM Started procedure."
call jcc "Built dynamically by RESCUE exec, "mydate()
call jcd
call jcl "//VTAM     EXEC PGM=ISTINM01,REGION=0M,"
call jcl "//         DPRTY=(15,15),TIME=1440,PERFORM=8"

/* Add VTAMLSTs */
libs = xdslist('VTAMLST')
DO x = 1 TO WORDS(libs) BY 2
   IF x = 1 THEN,
   call jcl "//VTAMLST  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add VTAMLIBs */
libs = xdslist('VTAMLIB')
DO x = 1 TO WORDS(libs) BY 2
   IF x = 1 THEN,
   call jcl "//VTAMLIB  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END
libs = xdslist('SISTCLIB')
IF WORDS(libs) > 0 THEN,
call jcl "//SISTCLIB DD DISP=SHR,DSN="WORD(libs,1)
call jcl "//SYSABEND DD SYSOUT=*,HOLD=YES"

call clsout opds,'VTAM'

RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of VTAM PROC.                                       */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*=====================================*/
/*  Build Master JCL deck (MSTJCL01)   */
/*=====================================*/
mstrjcl:
SAY "Building MSTJCL01 PARMLIB member."
call setout opds,'MSTJCL01' /* Set output member name.  */

call jcl "//MSTJCL01 JOB MSGLEVEL=(1,1),TIME=1440"
call jcd
call jcc "Master JCL."
call jcc "Built dynamically by RESCUE exec, "mydate()
call jcd
call jcl "//         EXEC PGM=IEEMB860,DPRTY=(15,15)"
call jcl "//STCINRDR DD SYSOUT=(A,INTRDR)"
call jcl "//TSOINRDR DD SYSOUT=(A,INTRDR)"

/* Add PROCLIBs */
libs = xdslist('PROCLIB')
DO x = 1 TO WORDS(libs) BY 2
   IF x = 1 THEN,
   call jcl "//IEFPDSI  DD DISP=SHR,DSN="WORD(libs,x)
   ELSE,
   call jcl "//         DD DISP=SHR,DSN="WORD(libs,x)
END

/* Add SYSUADSs */
libs = xdslist('SYSUADS')
IF WORDS(libs) > 0 THEN,
   call jcl "//SYSUADS  DD DISP=SHR,DSN="WORD(libs,1)

/* Add SYSLBCs */
libs = xdslist('SYSLBC')
IF WORDS(libs) > 0 THEN,
   call jcl "//SYSLBC   DD DISP=SHR,DSN="WORD(libs,1)

call clsout opds,'MSTJCL01'

RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of MSTRJCL01.                                       */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*=========================================================*/
/* Create IGDSMS member from ZIGDSMS contents plus entries */
/* for the ACDS and COMMDS files.                          */
/*=========================================================*/
igdsms:

SAY "Building IGDSMS00 SMS PARMLIB member."
/*---------------------------------------------------------*/
/* If no member found, set stem count to 0 for later, and  */
/* plan to write output to ZIGDSMS.                        */
/*---------------------------------------------------------*/
stat = setinp(ipds,'ZIGDSMS')  /* Open member ZIGDSMS for input. */
IF stat = 'MEMBER NOT FOUND' THEN DO
   SAY "IGDSMS00 not created, model ZIGDSMS not found."
   RETURN
END
libs1 = xdslist('ACDS')
libs2 = xdslist('COMMDS')
IF WORDS(libs1) = 0 THEN DO
   SAY "IGDSMS00 not built -- ACDS must be defined in @DATASET."
   RETURN
END
IF WORDS(libs1) = 0 THEN DO
   SAY "IGDSMS00 not built -- COMMDS must be defined in @DATASET."
   RETURN
END

smsacds = WORD(libs1,1)  /* Pick first (hopefully only) ACDS ent. */
smscommds = WORD(libs2,1)  /* Pick first (hopefully only) COMM ent. */

/*---------------------------------------------------------*/
/* Build IGDSMS00 member.                                  */
/*---------------------------------------------------------*/
call setout opds,'IGDSMS00'           /* Write to IGDSMS00  */
/* Code ACDS and COMMDS to start member.                   */
call jcl "SMS ACDS("smsacds")"
call jcl "    COMMDS("smscommds")"

/* Finish member with ZIGDSMS contents.                    */
DO xx = 1 TO INPUT.0
   call jcl INPUT.xx
END

call clsout opds

RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of IGDSMS00.                                        */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*=========================================================*/
/* Build COUPLE00 member.                                  */
/*=========================================================*/
couple:

SAY "Building COUPLE00 PARMLIB member."
/*---------------------------------------------------------*/
/* Build COUPLE00 member.                                  */
/*---------------------------------------------------------*/
call setout opds,'COUPLE00'          /* Write to COUPLE00  */
call jcl "/*-------------------------------------------------------*/"
call jcl "/* COUPLExx                                              */"
call jcl "/* Built dynamically by ZCLONE exec, "mydate()"          */"
call jcl "/*-------------------------------------------------------*/"
xcflibs  = xdslist('XCF')
wlmlibs  = xdslist('WLM')
logrlibs = xdslist('LOGR')

IF WORDS(xcflibs" "wlmlibs" "logrlibs) > 0 THEN makecouple = 1
ELSE makecouple = 0

/* If we have no couple datasets, write a SYSPLEX LOCAL stmt.        */
IF \makecouple THEN DO
   call jcl "COUPLE SYSPLEX(LOCAL)"
   RETURN
END

/* Otherwise create a couple member with couple datasets.            */
IF WORDS(xcflibs) > 0 THEN DO
   call jcl "    COUPLE SYSPLEX("sysplex")"
   DO ##xx = 1 TO WORDS(xcflibs) BY 4
      zsDSN = WORD(xcflibs,##xx)
      call jcl "             PCOUPLE("zsDSN")"
      zsDSN = WORD(xcflibs,##xx+2)
      call jcl "             ACOUPLE("zsDSN")"
   END
END

IF WORDS(wlmlibs) > 0 THEN DO
   call jcl "        DATA TYPE(WLM)"
   DO ##xx = 1 TO WORDS(wlmlibs) BY 4
      zsDSN = WORD(wlmlibs,##xx)
      call jcl "             PCOUPLE("zsDSN")"
      zsDSN = WORD(wlmlibs,##xx+2)
      call jcl "             ACOUPLE("zsDSN")"
   END
END

IF WORDS(logrlibs) > 0 THEN DO
   call jcl "        DATA TYPE(LOGR)"
   DO ##xx = 1 TO WORDS(logrlibs) BY 4
      zsDSN = WORD(logrlibs,##xx)
      call jcl "             PCOUPLE("zsDSN")"
      zsDSN = WORD(logrlibs,##xx+2)
      call jcl "             ACOUPLE("zsDSN")"
   END
END

call clsout opds

RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of COUPLE00.                                        */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*=====================================*/
/*  Build the VATLST00 PARMLIB member. */
/*=====================================*/
vatlst:

SAY "Building VATLST00 PARMLIB member"
call setout opds,'VATLST00' /* Set output member name.  */

call jcl "VATDEF IPLUSE(PRIVATE),SYSUSE(STORAGE)"
DO zz = 1 TO 99
   IF \isblank("VOLSER"zz) & \isblank("ADDR"zz) THEN DO
      zvolser = VALUE("VOLSER"zz)
      call jcl zvolser",1,0,"DEVTYPE"    ,Y"
   END
END

call clsout opds

RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of VATLST00.                                        */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*=====================================*/
/*  Build the IEASYS00 PARMLIB member. */
/*=====================================*/
ieasys:

SAY "Building IEASYS00 PARMLIB member"
call setinp ipds, 'ZIEASYS'
call setout opds,'IEASYS00'
DO xx = 1 TO INPUT.0
   call jcl INPUT.xx
END

/*- - - - - - - - - - - - - - - - - - -*/
/* PAGE= parameter                     */
/*- - - - - - - - - - - - - - - - - - -*/
libs = xdslist('PGPLPA')   /* Get name of PLPA PAGE ds.   */
zsDS = WORD(libs,1)
stmt = "PAGE=("zsDS","
call jcl stmt              /* Write it to IEASYS00        */

libs = xdslist('PGCOMMON') /* Get name of COMMON PAGE ds. */
zsDS = WORD(libs,1)
stmt = "      "zsDS","
call jcl stmt              /* Write it to IEASYS00        */

libs = xdslist('PGLOCAL')  /* Get name of LOCAL PAGE dsns */
DO x = 1 TO WORDS(libs) BY 2
   zsDS = WORD(libs,x)
   stmt = "      "zsDS","
   IF (x+1) >= WORDS(libs) THEN stmt = stmt"L,),"
   call jcl stmt
END

/*- - - - - - - - - - - - - - - - - - -*/
/* LOGREC= parameter                   */
/*- - - - - - - - - - - - - - - - - - -*/
libs = xdslist('LOGREC')   /* Get name of LOGREC ds.      */
IF WORDS(libs) > 1 THEN DO
   zsDS = WORD(libs,1)
   call jcl "LOGREC="zsDS","
END

/*- - - - - - - - - - - - - - - - - - -*/
/* SYSNAME=parameter                   */
/*- - - - - - - - - - - - - - - - - - -*/
call jcl "SYSNAME="smfid

call clsinp ipds, 'ZIEASYS'
call clsout opds, 'IEASYS00'

RETURN
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of IEASYS00.                                        */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions - v3.8 ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
IF isblank('@DATASET') THEN zzdsmem = '@DATASET'
ELSE zzdsmem = @DATASET
call setinp ipds,zzdsmem,'D.'
DO ###xx = 1 TO D.0
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN zcontin = 1
   ELSE zcontin = 0
   zrest = STRIP(zrest,"T")
   zrest = STRIP(zrest,"T","-")
   zrest = STRIP(zrest,"T","+")
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */
/*---------------------------------------------------------*/
dsdefined:
ARG #x##dsn2
DO #x#x2 = 1 TO DS.0
   IF DS.#x#x2.verb /= "DATASET" THEN ITERATE
   IF SYMBOL("DS."#x#x2".NEWNAME") = "VAR" THEN,
      #x##dsn = DS.#x#x2.NEWNAME
   ELSE #x##dsn = DS.#x#x2.DSN
   IF #x##dsn2 = #x##dsn THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.  The list  */
/* returned is a space delimited list of dsn+volume pairs, */
/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */
/* The parse_dataset routine must have already be run for  */
/* this routine to work.                                   */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ###xx = 1 TO DS.0
   IF DS.###xx.verb /= "DATASET" THEN ITERATE
   IF attrib(##prm,DS.###xx.PARM) THEN DO
      IF SYMBOL("DS."###xx".NEWNAME") = "VAR" THEN,
      ###dslst = ###dslst" "DS.###xx.NEWNAME DS.###xx.VOL
      ELSE,
      ###dslst = ###dslst" "DS.###xx.DSN DS.###xx.VOL
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* dstype - Return dataset type.                           */
/*---------------------------------------------------------*/
dstype:
ARG ##ds
##x = OUTTRAP('##y.',25)
"LISTD '"##ds"'"
##rc = rc
##x = OUTTRAP('OFF')
IF ##rc > 0 THEN RETURN "ERROR"
ELSE RETURN WORD(##y.3,WORDS(##y.3))

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),ZCLONE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
IF \setinp(ipds,zzprms,'PARMS.') THEN DO
   SAY "Error: Unable to allocate parms member:"ipds"("zzprms")."
   RETURN 0
END
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/* ' .     /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
/* IF r = "" THEN ITERATE */
   r = varsub(r)
   INTERPRET q '= "'r'"'
END
RETURN 1

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem, ##mode
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
IF ##mode = "" THEN ##mode = "SHR"
"ALLOC FI(output) DA('"##ds"("##mem")') "##mode
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
IF SYSDSN("'"##ds2"("##mem2")'") /= "OK" THEN RETURN 0
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(opds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(opds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str ##str2 '.' .
RETURN ##str2

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*---------------------------------------------------------*/
/* nonblank - Determine if a variable is blank or undef.   */
/*---------------------------------------------------------*/
isblank:
PARSE ARG #prm
IF VALUE(#prm) = "" THEN RETURN 1
IF SYMBOL(#prm) = = "LIT" THEN RETURN 1
RETURN 0

/*-------------------------------------------*/
/* Variable substitution.  Return a string   */
/* with all variables interpolated.  Vars    */
/* either be vars coded in the rexx exec     */
/* itself, or parms coded in the @PARMS file.*/
/*-------------------------------------------*/
varsub:
PARSE ARG ####str
####i = POS("&",####str)
DO WHILE ####i > 0
   ####str0 = SUBSTR(####str,1,####i-1)
   ####str2 = SUBSTR(####str,####i)
   ####str2 = TRANSLATE(####str2,"               "," &./()*&%$#@:<>")
   ####str2 = WORD(####str2,1)
   ####l = LENGTH(####str2)+1
   ####str3 = SUBSTR(####str,####i+####l)
   IF ####str2 = ZCLONE THEN ####str2 = ipds
   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)
   ####str = ####str0""####str2""####str3
   ####i = POS("&",####str)
END
RETURN ####str

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Add a text line to a queue.  (actually a  */
/* stem variable.)  This allows us to manage */
/* the output from various processes and     */
/* give the user a more orderly output.      */
/* The "queue" names must be numbers, due to */
/* the vagaries of the rexx interpreter.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* To store a line in queue #1:              */
/*   call qu 1,'Hello World!!'               */
/* To print all lines from queue #1:         */
/*   DO x = 1 TO q.1.0                       */
/*      SAY q.1.x                            */
/*   END                                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qu:
PARSE ARG #q,#data
#ctr = VALUE(q.#q.0)
IF DATATYPE(#ctr) /= 'NUM' THEN DO
   q.#q.0 = 0
   #ctr = 0
END
#ctr=#ctr+1; q.#q.0=#ctr
q.#q.#ctr = #data
return
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Print out all lines of a queue.           */
/* #q   = Queue number to print (1..n)       */
/* #box = 1 -> print line within box chars.  */
/* #box = 0 -> print line w/no box chars.    */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qup:
PARSE ARG #q,#box
IF #box /= 1 THEN #box = 0
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN
DO ##x = 1 TO q.#q.0
   IF #box THEN say box(q.#q.##x)
   ELSE            say q.#q.##x
END
RETURN

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Queue has lines: 0|1                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/
quhaslines:
PARSE ARG #q
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0
ELSE RETURN 1

/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Get volume for a given dataset.           */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getvol:
PARSE ARG ####d
DO ####x=1 TO DS.0
   IF \isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME
   ELSE                               ####d2 = DS.####x.DSN
   IF ####d = ####d2 THEN RETURN DS.####x.VOL
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* InsertIntoMember:  Insert some text into  */
/* a member, but only if a search string is  */
/* found/not found.  If ##negative is set to */
/* 1, then only insert if the search string  */
/* is not found.  Otherwise, only insert the */
/* string if the search string IS found.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
insertIntoMember:
PARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative

IF setinp(##ds, ##mem) THEN DO
   ##foun=0
   DO ##xx = 1 TO INPUT.0
      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1
   END
   IF ##negative  = 1 &  ##foun THEN RETURN 0
   IF ##negative /= 1 & \##foun THEN RETURN 0
   call clsinp ##ds, ##mem
   call setout ##ods, ##omem
   DO ##xx = 1 TO INPUT.0
      call jcl INPUT.##xx
   END
END
ELSE DO
   call setout ##ods, ##omem
END
call jcl ##txt
call clsout ##ds, ##mem
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* hasParms - True if any of the coded parms */
/* are present for a dataset.                */
/*- - - - - - - - - - - - - - - - - - - - - -*/
hasParms:
PARSE ARG ##prms, ##dsprms
##dsprms = TRANSLATE(##dsprms,' ',',')
DO ####hp = 1 TO WORDS(##prms)
   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* vsam_part:  Return name of DATA or INDEX  */
/* component of a VSAM file.                 */
/*- - - - - - - - - - - - - - - - - - - - - -*/
vsam_part:
ARG ##part,##ds
##x = OUTTRAP('##y.',25)
"LISTC ENT('"ds"')"
##rc = rc
##x = OUTTRAP('OFF')
DO ##x = 1 TO ##y.0
   say ##y.##x
   PARSE VAR ##y.##x (##part) "------- " zzdsn .
   IF zzdsn /= "" THEN RETURN zzdsn
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* volsym:  If USESYM=YES in @PARMS, then    */
/* substitute "&SYSRn" for the volser passed.*/
/* Otherwise, just spit back the volser.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
volsym:
PARSE ARG ##volser
IF isblank("USESYM") THEN RETURN ##volser
IF USESYM /= "YES" & USERSYM /= "1" THEN RETURN ##volser

DO ##zz = 1 TO 99
   IF \isblank("VOLSER"##zz) & \isblank("ADDR"##zz) THEN DO
      ###zvolser = VALUE("VOLSER"##zz)
      IF ##volser = ###zvolser THEN RETURN "&SYSR"##zz
   END
END

RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getssa: Return the appropriate SSA for a  */
/* dataset.  If usercat is defined and an    */
/* alias to the usercat would be applied to  */
/* this dataset, then return the SSAU value. */
/* Else, return the SSA value (for the mcat).*/
/*- - - - - - - - - - - - - - - - - - - - - -*/
getssa:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN SSA

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) & \isblank("NEWUCAT") THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN SSAU
   END
END

RETURN SSA

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getcat: Return the appropriate catalog in */
/* which to catalog a dataset--either the    */
/* mastercat or usercat.                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getcat:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN NEWMCAT

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT
   END
END

RETURN NEWMCAT

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- end low level functions -------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
./ ADD NAME=#MISC
/*---------------------------------------------------Rexx--*/
/* ZCLONE  - Build JCL and other elements for cloning a    */
/*           z/OS system.                                  */
/*---------------------------------------------------------*/
/* #MISC    - Do various other tasks.                      */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
ARG jobnum ipds opds zzprms .
IF \varinit() THEN RETURN 1 /* Read parms, initialize vars. */
call parse_dataset

/*=========================================================*/
/* JOB: Misc.                                              */
/*=========================================================*/
Say "Building Job "jobnum": Misc. tasks."
call setout opds,'JOB'jobnum
call jobcard jobnum

call logrec           /* Initialize logrec dataset.        */
call syncuads         /* SYNC UADS ds.                     */
call dumpfmt          /* Format DUMP datasets.             */
call couple           /* Couple datasets.                  */

/*---------------------------------------------------------*/
/* COUPLEnn member:  For now, we only support operation    */
/* in sysplex-local mode using   COUPLE SYSPLEX(LOCAL)     */
/*---------------------------------------------------------*/
/* call couple    */       /* Create couple datasets.           */

call clsout opds,'JOB'jobnum
RETURN

/*---------------------------------------------------------*/
/* Format LOGREC dataset.                                  */
/*---------------------------------------------------------*/
logrec:
libs = xdslist('LOGREC')
IF WORDS(libs) > 0 THEN DO
   logrec = WORD(libs,1)
   volser = WORD(libs,2)
END
ELSE logrec = ""

call jcd
call jcc "Job "jobnum
call jcd
call jcc "LOGREC  - Format LOGREC dataset."
call jcd
call jcc mydate()" "comment
call jcd
/* Format LOGREC dataset if any entry in @dataset was found with */
/* the LOGREC parm coded.    */
zzssa = getssa(logrec)
IF logrec /= "" THEN DO
   call jcc "LOGREC  - Format the LOGREC dataset."
   call jcd
   call jcl "//LOGREC   EXEC PGM=IFCDIP00"
   call jcl "//SERERDS  DD DISP=SHR,DSN="zzssa""logrec","
   call jcl "//         UNIT="devtype",VOL=SER="volser
   call jcl "//*"
END

RETURN

/*---------------------------------------------------------*/
/* SYNC UADS if SYSUADS and SYSLBC datasets were found in  */
/* @DATASET.                                               */
/*---------------------------------------------------------*/
syncuads:
libs = xdslist('SYSUADS')
IF WORDS(libs) > 0 THEN sysuads = WORD(libs,1)
ELSE sysuads = ""
libs = xdslist('SYSLBC')
IF WORDS(libs) > 0 THEN syslbc = WORD(libs,1)
ELSE syslbc = ""
IF sysuads = "" | syslbc = "" THEN DO
   Say "SYSUADS and SYSLBC datasets not defined in @DATASET-Exiting."
   RETURN
END

/* Found the SYSUADS and SYSLBC, so build the SYNC JCL. */
libs = xdslist('SYSUADS')
uadsvolser = WORD(libs,2)
libs = xdslist('SYSLBC')
lbcvolser = WORD(libs,2)
zzssa = getssa(sysuads)
call jcd
call jcc "SYNCUADS - Sync UADS / Brodcast dataset."
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//SYNCUADS EXEC PGM=IKJEFT01,DYNAMNBR=15 "
call jcl "//SYSPRINT DD SYSOUT=* "
call jcl "//SYSIN    DD DUMMY "
call jcl "//SYSUADS  DD DISP=SHR,DSN="zzssa""sysuads","
call jcl "//         UNIT="devtype",VOL=SER="uadsvolser
zzssa = getssa(syslbc)
call jcl "//SYSLBC   DD DISP=SHR,DSN="zzssa""syslbc","
call jcl "//         UNIT="devtype",VOL=SER="lbcvolser
call jcl "//SYSTSPRT DD SYSOUT=* "
call jcl "//SYSTSIN  DD * "
call jcl "  ACCOUNT       "
call jcl "  SYNC          "
call jcl "  END           "
call jcl "//*"

RETURN

/*---------------------------------------------------------*/
/* JCL to format any DUMP datasets found in @DATASET.      */
/*---------------------------------------------------------*/
dumpfmt:
libs = xdslist('DUMP')
IF WORDS(libs) = 0 THEN DO
   Say "No DUMP datasets found in @DATASET - None will be formatted."
   RETURN
END

/* Found some dump datasets, so format them.        */
call jcd
call jcc "FMTDUMP  - Format DUMP datasets."
call jcd
call jcc mydate()" "comment
call jcd

DO xx = 1 TO WORDS(libs) BY 2
   dmpds = WORD(libs,xx)
   volser = WORD(libs,xx+1)
   zzssa = getssa(dmpds)
   call jcl "//DMPINT0 EXEC PGM=IEBGENER"
   call jcl "//SYSPRINT DD SYSOUT=*"
   call jcl "//SYSIN    DD DUMMY"
   call jcl "//SYSUT1   DD DUMMY,"
   call jcl "//         LRECL=4160,BLKSIZE=4160,RECFM=FB,DSORG=PS"
   call jcl "//SYSUT2   DD DSN="zzssa""dmpds",DISP=SHR,"
   call jcl "//         UNIT="devtype",VOL=SER="volser
   call jcl "//*"
END

RETURN

/*---------------------------------------------------------*/
/* JCL  to create XCF, WLM and LOGR couple datasets.       */
/*---------------------------------------------------------*/
couple:
xcflibs  = xdslist('XCF')
wlmlibs  = xdslist('WLM')
logrlibs = xdslist('LOGR')

IF WORDS(xcflibs" "wlmlibs" "logrlibs) > 0 THEN makecouple = 1
ELSE makecouple = 0

/* If we have couple datasets to make, write JCL.   */
IF makecouple THEN DO
   call jcd
   call jcc "COUPLE - Create XCF, WLM and LOGR datasets."
   call jcd
   call jcc mydate()" "comment
   call jcd
   call jcl "//ALCCDS   EXEC PGM=IXCL1DSU"
   call jcl "//STEPLIB   DD DSN=SYS1.MIGLIB,DISP=SHR"
   call jcl "//SYSPRINT DD SYSOUT=*"
   call jcl "//SYSIN     DD *"
END

DO ##xx = 1 TO WORDS(xcflibs) BY 2
   dsn = WORD(xcflibs,##xx); volser = WORD(xcflibs,##xx+1)
   call jcl " "
   call jcl "  DEFINEDS SYSPLEX("sysplex")"
   call jcl "       DSN("ssa""dsn")"
   call jcl "       VOLSER("volser")"
   call jcl "       MAXSYSTEM(8)"
   call jcl "       CATALOG"
   call jcl "    DATA TYPE(SYSPLEX)"
   call jcl "       ITEM NAME(GROUP)    NUMBER(50)"
   call jcl "       ITEM NAME(MEMBER)   NUMBER(100)"
   call jcl "       ITEM NAME(GRS)      NUMBER(1)"
END

DO ##xx = 1 TO WORDS(wlmlibs) BY 2
   dsn = WORD(wlmlibs,##xx); volser = WORD(wlmlibs,##xx+1)
   call jcl " "
   call jcl "  DEFINEDS SYSPLEX("sysplex")"
   call jcl "       DSN("ssa""dsn")"
   call jcl "       VOLSER("volser")"
   call jcl "       MAXSYSTEM(8)"
   call jcl "       CATALOG"
   call jcl " DATA TYPE(WLM)"
   call jcl "      ITEM NAME(APPLENV) NUMBER(100)"
   call jcl "      ITEM NAME(POLICY) NUMBER(10)  "
   call jcl "      ITEM NAME(SCHENV) NUMBER(100) "
   call jcl "      ITEM NAME(SRVCLASS) NUMBER(30)"
   call jcl "      ITEM NAME(SVAEAEXT) NUMBER(5) "
   call jcl "      ITEM NAME(SVDCREXT) NUMBER(5) "
   call jcl "      ITEM NAME(SVDEFEXT) NUMBER(5) "
   call jcl "      ITEM NAME(SVSEAEXT) NUMBER(5) "
   call jcl "      ITEM NAME(WORKLOAD) NUMBER(35)"
END


DO ##xx = 1 TO WORDS(logrlibs) BY 2
   dsn = WORD(logrlibs,##xx); volser = WORD(logrlibs,##xx+1)
   call jcl " "
   call jcl "  DEFINEDS SYSPLEX("sysplex")"
   call jcl "       DSN("ssa""dsn")"
   call jcl "       VOLSER("volser")"
   call jcl "       MAXSYSTEM(8)"
   call jcl "       CATALOG"
   call jcl "    DATA TYPE(LOGR)"
   call jcl "         ITEM NAME(LSR) NUMBER(10)"
   call jcl "         ITEM NAME(LSTRR) NUMBER(10)"
   call jcl "         ITEM NAME(DSEXTENT) NUMBER(10)"
END


RETURN

/*---------------------------------------------------------*/
/* JCL  to create TSO ALIASES.                             */
/*---------------------------------------------------------*/
tsoalias:
IF isblank('tsoid1') THEN DO
   call qu 1,'Warning: TSOID1 not defined.'
   RETURN
END

xcflibs  = xdslist('XCF')
wlmlibs  = xdslist('WLM')
logrlibs = xdslist('LOGR')

IF WORDS(xcflibs" "wlmlibs" "logrlibs) > 0 THEN makecouple = 1
ELSE makecouple = 0

/* If we have couple datasets to make, write JCL.   */
IF makecouple THEN DO
   call jcd
   call jcc "COUPLE - Create XCF, WLM and LOGR datasets."
   call jcd
   call jcc mydate()" "comment
   call jcd
   call jcl "//ALCCDS   EXEC PGM=IXCL1DSU"
   call jcl "//STEPLIB   DD DSN=SYS1.MIGLIB,DISP=SHR"
   call jcl "//SYSPRINT DD SYSOUT=*"
   call jcl "//SYSIN     DD *"
END

DO ##xx = 1 TO WORDS(xcflibs) BY 2
   dsn = WORD(xcflibs,##xx); volser = WORD(xcflibs,##xx+1)
   call jcl " "
   call jcl "  DEFINEDS SYSPLEX("sysplex")"
   call jcl "       DSN("ssa""dsn")"
   call jcl "       VOLSER("volser")"
   call jcl "       MAXSYSTEM(8)"
   call jcl "       CATALOG"
   call jcl "    DATA TYPE(SYSPLEX)"
   call jcl "       ITEM NAME(GROUP)    NUMBER(50)"
   call jcl "       ITEM NAME(MEMBER)   NUMBER(100)"
   call jcl "       ITEM NAME(GRS)      NUMBER(1)"
END

DO ##xx = 1 TO WORDS(wlmlibs) BY 2
   dsn = WORD(wlmlibs,##xx); volser = WORD(wlmlibs,##xx+1)
   call jcl " "
   call jcl "  DEFINEDS SYSPLEX("sysplex")"
   call jcl "       DSN("ssa""dsn")"
   call jcl "       VOLSER("volser")"
   call jcl "       MAXSYSTEM(8)"
   call jcl "       CATALOG"
   call jcl " DATA TYPE(WLM)"
   call jcl "      ITEM NAME(APPLENV) NUMBER(100)"
   call jcl "      ITEM NAME(POLICY) NUMBER(10)  "
   call jcl "      ITEM NAME(SCHENV) NUMBER(100) "
   call jcl "      ITEM NAME(SRVCLASS) NUMBER(30)"
   call jcl "      ITEM NAME(SVAEAEXT) NUMBER(5) "
   call jcl "      ITEM NAME(SVDCREXT) NUMBER(5) "
   call jcl "      ITEM NAME(SVDEFEXT) NUMBER(5) "
   call jcl "      ITEM NAME(SVSEAEXT) NUMBER(5) "
   call jcl "      ITEM NAME(WORKLOAD) NUMBER(35)"
END


DO ##xx = 1 TO WORDS(logrlibs) BY 2
   dsn = WORD(logrlibs,##xx); volser = WORD(logrlibs,##xx+1)
   call jcl " "
   call jcl "  DEFINEDS SYSPLEX("sysplex")"
   call jcl "       DSN("ssa""dsn")"
   call jcl "       VOLSER("volser")"
   call jcl "       MAXSYSTEM(8)"
   call jcl "       CATALOG"
   call jcl "    DATA TYPE(LOGR)"
   call jcl "         ITEM NAME(LSR) NUMBER(10)"
   call jcl "         ITEM NAME(LSTRR) NUMBER(10)"
   call jcl "         ITEM NAME(DSEXTENT) NUMBER(10)"
END


RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions - v3.8 ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
IF isblank('@DATASET') THEN zzdsmem = '@DATASET'
ELSE zzdsmem = @DATASET
call setinp ipds,zzdsmem,'D.'
DO ###xx = 1 TO D.0
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN zcontin = 1
   ELSE zcontin = 0
   zrest = STRIP(zrest,"T")
   zrest = STRIP(zrest,"T","-")
   zrest = STRIP(zrest,"T","+")
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */
/*---------------------------------------------------------*/
dsdefined:
ARG #x##dsn2
DO #x#x2 = 1 TO DS.0
   IF DS.#x#x2.verb /= "DATASET" THEN ITERATE
   IF SYMBOL("DS."#x#x2".NEWNAME") = "VAR" THEN,
      #x##dsn = DS.#x#x2.NEWNAME
   ELSE #x##dsn = DS.#x#x2.DSN
   IF #x##dsn2 = #x##dsn THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.  The list  */
/* returned is a space delimited list of dsn+volume pairs, */
/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */
/* The parse_dataset routine must have already be run for  */
/* this routine to work.                                   */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ###xx = 1 TO DS.0
   IF DS.###xx.verb /= "DATASET" THEN ITERATE
   IF attrib(##prm,DS.###xx.PARM) THEN DO
      IF SYMBOL("DS."###xx".NEWNAME") = "VAR" THEN,
      ###dslst = ###dslst" "DS.###xx.NEWNAME DS.###xx.VOL
      ELSE,
      ###dslst = ###dslst" "DS.###xx.DSN DS.###xx.VOL
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* dstype - Return dataset type.                           */
/*---------------------------------------------------------*/
dstype:
ARG ##ds
##x = OUTTRAP('##y.',25)
"LISTD '"##ds"'"
##rc = rc
##x = OUTTRAP('OFF')
IF ##rc > 0 THEN RETURN "ERROR"
ELSE RETURN WORD(##y.3,WORDS(##y.3))

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),ZCLONE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
IF \setinp(ipds,zzprms,'PARMS.') THEN DO
   SAY "Error: Unable to allocate parms member:"ipds"("zzprms")."
   RETURN 0
END
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/* ' .     /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
/* IF r = "" THEN ITERATE */
   r = varsub(r)
   INTERPRET q '= "'r'"'
END
RETURN 1

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem, ##mode
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
IF ##mode = "" THEN ##mode = "SHR"
"ALLOC FI(output) DA('"##ds"("##mem")') "##mode
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
IF SYSDSN("'"##ds2"("##mem2")'") /= "OK" THEN RETURN 0
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(opds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(opds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str ##str2 '.' .
RETURN ##str2

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*---------------------------------------------------------*/
/* nonblank - Determine if a variable is blank or undef.   */
/*---------------------------------------------------------*/
isblank:
PARSE ARG #prm
IF VALUE(#prm) = "" THEN RETURN 1
IF SYMBOL(#prm) = = "LIT" THEN RETURN 1
RETURN 0

/*-------------------------------------------*/
/* Variable substitution.  Return a string   */
/* with all variables interpolated.  Vars    */
/* either be vars coded in the rexx exec     */
/* itself, or parms coded in the @PARMS file.*/
/*-------------------------------------------*/
varsub:
PARSE ARG ####str
####i = POS("&",####str)
DO WHILE ####i > 0
   ####str0 = SUBSTR(####str,1,####i-1)
   ####str2 = SUBSTR(####str,####i)
   ####str2 = TRANSLATE(####str2,"               "," &./()*&%$#@:<>")
   ####str2 = WORD(####str2,1)
   ####l = LENGTH(####str2)+1
   ####str3 = SUBSTR(####str,####i+####l)
   IF ####str2 = ZCLONE THEN ####str2 = ipds
   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)
   ####str = ####str0""####str2""####str3
   ####i = POS("&",####str)
END
RETURN ####str

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Add a text line to a queue.  (actually a  */
/* stem variable.)  This allows us to manage */
/* the output from various processes and     */
/* give the user a more orderly output.      */
/* The "queue" names must be numbers, due to */
/* the vagaries of the rexx interpreter.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* To store a line in queue #1:              */
/*   call qu 1,'Hello World!!'               */
/* To print all lines from queue #1:         */
/*   DO x = 1 TO q.1.0                       */
/*      SAY q.1.x                            */
/*   END                                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qu:
PARSE ARG #q,#data
#ctr = VALUE(q.#q.0)
IF DATATYPE(#ctr) /= 'NUM' THEN DO
   q.#q.0 = 0
   #ctr = 0
END
#ctr=#ctr+1; q.#q.0=#ctr
q.#q.#ctr = #data
return
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Print out all lines of a queue.           */
/* #q   = Queue number to print (1..n)       */
/* #box = 1 -> print line within box chars.  */
/* #box = 0 -> print line w/no box chars.    */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qup:
PARSE ARG #q,#box
IF #box /= 1 THEN #box = 0
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN
DO ##x = 1 TO q.#q.0
   IF #box THEN say box(q.#q.##x)
   ELSE            say q.#q.##x
END
RETURN

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Queue has lines: 0|1                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/
quhaslines:
PARSE ARG #q
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0
ELSE RETURN 1

/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Get volume for a given dataset.           */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getvol:
PARSE ARG ####d
DO ####x=1 TO DS.0
   IF \isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME
   ELSE                               ####d2 = DS.####x.DSN
   IF ####d = ####d2 THEN RETURN DS.####x.VOL
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* InsertIntoMember:  Insert some text into  */
/* a member, but only if a search string is  */
/* found/not found.  If ##negative is set to */
/* 1, then only insert if the search string  */
/* is not found.  Otherwise, only insert the */
/* string if the search string IS found.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
insertIntoMember:
PARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative

IF setinp(##ds, ##mem) THEN DO
   ##foun=0
   DO ##xx = 1 TO INPUT.0
      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1
   END
   IF ##negative  = 1 &  ##foun THEN RETURN 0
   IF ##negative /= 1 & \##foun THEN RETURN 0
   call clsinp ##ds, ##mem
   call setout ##ods, ##omem
   DO ##xx = 1 TO INPUT.0
      call jcl INPUT.##xx
   END
END
ELSE DO
   call setout ##ods, ##omem
END
call jcl ##txt
call clsout ##ds, ##mem
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* hasParms - True if any of the coded parms */
/* are present for a dataset.                */
/*- - - - - - - - - - - - - - - - - - - - - -*/
hasParms:
PARSE ARG ##prms, ##dsprms
##dsprms = TRANSLATE(##dsprms,' ',',')
DO ####hp = 1 TO WORDS(##prms)
   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* vsam_part:  Return name of DATA or INDEX  */
/* component of a VSAM file.                 */
/*- - - - - - - - - - - - - - - - - - - - - -*/
vsam_part:
ARG ##part,##ds
##x = OUTTRAP('##y.',25)
"LISTC ENT('"ds"')"
##rc = rc
##x = OUTTRAP('OFF')
DO ##x = 1 TO ##y.0
   say ##y.##x
   PARSE VAR ##y.##x (##part) "------- " zzdsn .
   IF zzdsn /= "" THEN RETURN zzdsn
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* volsym:  If USESYM=YES in @PARMS, then    */
/* substitute "&SYSRn" for the volser passed.*/
/* Otherwise, just spit back the volser.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
volsym:
PARSE ARG ##volser
IF isblank("USESYM") THEN RETURN ##volser
IF USESYM /= "YES" & USERSYM /= "1" THEN RETURN ##volser

DO ##zz = 1 TO 99
   IF \isblank("VOLSER"##zz) & \isblank("ADDR"##zz) THEN DO
      ###zvolser = VALUE("VOLSER"##zz)
      IF ##volser = ###zvolser THEN RETURN "&SYSR"##zz
   END
END

RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getssa: Return the appropriate SSA for a  */
/* dataset.  If usercat is defined and an    */
/* alias to the usercat would be applied to  */
/* this dataset, then return the SSAU value. */
/* Else, return the SSA value (for the mcat).*/
/*- - - - - - - - - - - - - - - - - - - - - -*/
getssa:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN SSA

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) & \isblank("NEWUCAT") THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN SSAU
   END
END

RETURN SSA

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getcat: Return the appropriate catalog in */
/* which to catalog a dataset--either the    */
/* mastercat or usercat.                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getcat:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN NEWMCAT

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT
   END
END

RETURN NEWMCAT

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- end low level functions -------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
./ ADD NAME=#RFDSNT
/*---------------------------------------------------Rexx--*/
/* ZCLONE  - Build JCL and other elements for cloning a    */
/*           z/OS system.                                  */
/*---------------------------------------------------------*/
/* #RFDSNT - RACF Dataset Name Table (ICHRDSNT)            */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
ARG jobnum ipds opds zzprms .
IF \varinit() THEN RETURN 1 /* Read parms, initialize vars. */
call parse_dataset

IF rfdsnt /= 'YES' THEN DO
   Say "RFDSNT parameter not specified - ICHRDSNT assembly not created."
   RETURN
END

call makedsnt         /* Build the DSN table.              */
call iealpa           /* Build MLPA member to use ICHRDSNT.*/

exit

/*=========================================================*/
/* JOB: RACF Dataset Name Table (ICHRDSNT)                 */
/*=========================================================*/
makedsnt:

Say "Building Job "jobnum": Assemble ICHRDSNT table."
libs = xdslist('ZLINKLIB') /* Get ds info for RESCUE.LINKLIB. */
ds = WORD(libs,1); volume = WORD(libs,2)
libs = xdslist('RACFDS')  /* Get ds info for RACF DS.        */
racfds = WORD(libs,1)
call setout opds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "RFDSNT   - Assemble RACF dataset name table (ICHRDSNT)"
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//STEP1    EXEC ASMACL,PARM.C='OBJECT,NODECK',"
call jcl "// PARM.L='SIZE=(320K,250K)' "
call jcl "//C.SYSLIB DD  DSN=SYS1.MACLIB,DISP=SHR "
call jcl "//         DD  DSN=SYS1.MODGEN,DISP=SHR "
call jcl "//SYSIN    DD  * "
call jcl "ICHRDSNT CSECT "
call jcl "         DC    AL1(1)             NUMBER OF RACF DATA"
call jcl "         DC    CL44'"racfds"'     RACF PRIMARY DATASET"
call jcl "         DC    CL44' '            RACF BACKUP DATASET"
call jcl "         DC    AL1(255)           RESIDENT INDEX BLKS"
call jcl "         DC    XL1'81'            DUPLICATE ALL EXCEPT"
call jcl "         END"
call jcl "//L.SYSLMOD     DD DSN="ssa""ds",DISP=SHR,"
call jcl "//  UNIT="devtype",VOL=SER="volume
call jcl "//L.SYSIN       DD *"
call jcl "  NAME ICHRDSNT(R) "

call clsout opds,'JOB'jobnum
RETURN

/*=========================================================*/
/* Create IEALPA member from ZIEALPA contents plus an      */
/* entry we'll build for ICHRDSNT.                         */
/*=========================================================*/
iealpa:
libs = xdslist('ZLINKLIB')   /* Get ds info for ZCLONE LINKLIB. */
ds = WORD(libs,1); volume = WORD(libs,2)
srch = "ICHRDSNT"
txt = "INCLUDE LIBRARY("ds") MODULES( ICHRDSNT )"
call InsertIntoMember ipds,'ZIEALPA',opds,'IEALPA00',txt,srch,1

RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions - v3.8 ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
IF isblank('@DATASET') THEN zzdsmem = '@DATASET'
ELSE zzdsmem = @DATASET
call setinp ipds,zzdsmem,'D.'
DO ###xx = 1 TO D.0
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN zcontin = 1
   ELSE zcontin = 0
   zrest = STRIP(zrest,"T")
   zrest = STRIP(zrest,"T","-")
   zrest = STRIP(zrest,"T","+")
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */
/*---------------------------------------------------------*/
dsdefined:
ARG #x##dsn2
DO #x#x2 = 1 TO DS.0
   IF DS.#x#x2.verb /= "DATASET" THEN ITERATE
   IF SYMBOL("DS."#x#x2".NEWNAME") = "VAR" THEN,
      #x##dsn = DS.#x#x2.NEWNAME
   ELSE #x##dsn = DS.#x#x2.DSN
   IF #x##dsn2 = #x##dsn THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.  The list  */
/* returned is a space delimited list of dsn+volume pairs, */
/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */
/* The parse_dataset routine must have already be run for  */
/* this routine to work.                                   */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ###xx = 1 TO DS.0
   IF DS.###xx.verb /= "DATASET" THEN ITERATE
   IF attrib(##prm,DS.###xx.PARM) THEN DO
      IF SYMBOL("DS."###xx".NEWNAME") = "VAR" THEN,
      ###dslst = ###dslst" "DS.###xx.NEWNAME DS.###xx.VOL
      ELSE,
      ###dslst = ###dslst" "DS.###xx.DSN DS.###xx.VOL
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* dstype - Return dataset type.                           */
/*---------------------------------------------------------*/
dstype:
ARG ##ds
##x = OUTTRAP('##y.',25)
"LISTD '"##ds"'"
##rc = rc
##x = OUTTRAP('OFF')
IF ##rc > 0 THEN RETURN "ERROR"
ELSE RETURN WORD(##y.3,WORDS(##y.3))

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),ZCLONE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
IF \setinp(ipds,zzprms,'PARMS.') THEN DO
   SAY "Error: Unable to allocate parms member:"ipds"("zzprms")."
   RETURN 0
END
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/* ' .     /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
/* IF r = "" THEN ITERATE */
   r = varsub(r)
   INTERPRET q '= "'r'"'
END
RETURN 1

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem, ##mode
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
IF ##mode = "" THEN ##mode = "SHR"
"ALLOC FI(output) DA('"##ds"("##mem")') "##mode
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
IF SYSDSN("'"##ds2"("##mem2")'") /= "OK" THEN RETURN 0
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(opds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(opds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str ##str2 '.' .
RETURN ##str2

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*---------------------------------------------------------*/
/* nonblank - Determine if a variable is blank or undef.   */
/*---------------------------------------------------------*/
isblank:
PARSE ARG #prm
IF VALUE(#prm) = "" THEN RETURN 1
IF SYMBOL(#prm) = = "LIT" THEN RETURN 1
RETURN 0

/*-------------------------------------------*/
/* Variable substitution.  Return a string   */
/* with all variables interpolated.  Vars    */
/* either be vars coded in the rexx exec     */
/* itself, or parms coded in the @PARMS file.*/
/*-------------------------------------------*/
varsub:
PARSE ARG ####str
####i = POS("&",####str)
DO WHILE ####i > 0
   ####str0 = SUBSTR(####str,1,####i-1)
   ####str2 = SUBSTR(####str,####i)
   ####str2 = TRANSLATE(####str2,"               "," &./()*&%$#@:<>")
   ####str2 = WORD(####str2,1)
   ####l = LENGTH(####str2)+1
   ####str3 = SUBSTR(####str,####i+####l)
   IF ####str2 = ZCLONE THEN ####str2 = ipds
   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)
   ####str = ####str0""####str2""####str3
   ####i = POS("&",####str)
END
RETURN ####str

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Add a text line to a queue.  (actually a  */
/* stem variable.)  This allows us to manage */
/* the output from various processes and     */
/* give the user a more orderly output.      */
/* The "queue" names must be numbers, due to */
/* the vagaries of the rexx interpreter.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* To store a line in queue #1:              */
/*   call qu 1,'Hello World!!'               */
/* To print all lines from queue #1:         */
/*   DO x = 1 TO q.1.0                       */
/*      SAY q.1.x                            */
/*   END                                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qu:
PARSE ARG #q,#data
#ctr = VALUE(q.#q.0)
IF DATATYPE(#ctr) /= 'NUM' THEN DO
   q.#q.0 = 0
   #ctr = 0
END
#ctr=#ctr+1; q.#q.0=#ctr
q.#q.#ctr = #data
return
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Print out all lines of a queue.           */
/* #q   = Queue number to print (1..n)       */
/* #box = 1 -> print line within box chars.  */
/* #box = 0 -> print line w/no box chars.    */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qup:
PARSE ARG #q,#box
IF #box /= 1 THEN #box = 0
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN
DO ##x = 1 TO q.#q.0
   IF #box THEN say box(q.#q.##x)
   ELSE            say q.#q.##x
END
RETURN

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Queue has lines: 0|1                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/
quhaslines:
PARSE ARG #q
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0
ELSE RETURN 1

/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Get volume for a given dataset.           */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getvol:
PARSE ARG ####d
DO ####x=1 TO DS.0
   IF \isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME
   ELSE                               ####d2 = DS.####x.DSN
   IF ####d = ####d2 THEN RETURN DS.####x.VOL
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* InsertIntoMember:  Insert some text into  */
/* a member, but only if a search string is  */
/* found/not found.  If ##negative is set to */
/* 1, then only insert if the search string  */
/* is not found.  Otherwise, only insert the */
/* string if the search string IS found.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
insertIntoMember:
PARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative

IF setinp(##ds, ##mem) THEN DO
   ##foun=0
   DO ##xx = 1 TO INPUT.0
      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1
   END
   IF ##negative  = 1 &  ##foun THEN RETURN 0
   IF ##negative /= 1 & \##foun THEN RETURN 0
   call clsinp ##ds, ##mem
   call setout ##ods, ##omem
   DO ##xx = 1 TO INPUT.0
      call jcl INPUT.##xx
   END
END
ELSE DO
   call setout ##ods, ##omem
END
call jcl ##txt
call clsout ##ds, ##mem
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* hasParms - True if any of the coded parms */
/* are present for a dataset.                */
/*- - - - - - - - - - - - - - - - - - - - - -*/
hasParms:
PARSE ARG ##prms, ##dsprms
##dsprms = TRANSLATE(##dsprms,' ',',')
DO ####hp = 1 TO WORDS(##prms)
   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* vsam_part:  Return name of DATA or INDEX  */
/* component of a VSAM file.                 */
/*- - - - - - - - - - - - - - - - - - - - - -*/
vsam_part:
ARG ##part,##ds
##x = OUTTRAP('##y.',25)
"LISTC ENT('"ds"')"
##rc = rc
##x = OUTTRAP('OFF')
DO ##x = 1 TO ##y.0
   say ##y.##x
   PARSE VAR ##y.##x (##part) "------- " zzdsn .
   IF zzdsn /= "" THEN RETURN zzdsn
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* volsym:  If USESYM=YES in @PARMS, then    */
/* substitute "&SYSRn" for the volser passed.*/
/* Otherwise, just spit back the volser.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
volsym:
PARSE ARG ##volser
IF isblank("USESYM") THEN RETURN ##volser
IF USESYM /= "YES" & USERSYM /= "1" THEN RETURN ##volser

DO ##zz = 1 TO 99
   IF \isblank("VOLSER"##zz) & \isblank("ADDR"##zz) THEN DO
      ###zvolser = VALUE("VOLSER"##zz)
      IF ##volser = ###zvolser THEN RETURN "&SYSR"##zz
   END
END

RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getssa: Return the appropriate SSA for a  */
/* dataset.  If usercat is defined and an    */
/* alias to the usercat would be applied to  */
/* this dataset, then return the SSAU value. */
/* Else, return the SSA value (for the mcat).*/
/*- - - - - - - - - - - - - - - - - - - - - -*/
getssa:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN SSA

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) & \isblank("NEWUCAT") THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN SSAU
   END
END

RETURN SSA

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getcat: Return the appropriate catalog in */
/* which to catalog a dataset--either the    */
/* mastercat or usercat.                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getcat:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN NEWMCAT

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT
   END
END

RETURN NEWMCAT

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- end low level functions -------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
./ ADD NAME=#RFSTC
/*---------------------------------------------------Rexx--*/
/* ZCLONE  - Build JCL and other elements for cloning a    */
/*           z/OS system.                                  */
/*---------------------------------------------------------*/
/* #RFSTC  - RACF Started Task Table (ICHRIN03)            */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
ARG jobnum ipds opds zzprms .
IF \varinit() THEN RETURN 1 /* Read parms, initialize vars. */
call parse_dataset

IF rfstc /= 'YES' THEN DO
   Say "RFSTC parameter not specified - ICHRIN03 assembly not created."
   RETURN
END

call makestc          /* Build the STC table.              */
call iealpa           /* Build MLPA member to use ICHRIN03.*/
call defids           /* Create RACF groups/IDs as needed. */

exit

/*=========================================================*/
/* JOB: RACF Started Task Table (ICHRDSNT)                 */
/*=========================================================*/
makestc:

Say "Building Job "jobnum": Assemble ICHRIN03 table."
libs = xdslist('RLINK')   /* Get ds info for RESCUE.LINKLIB. */
ds = WORD(libs,1); volser = WORD(libs,2)
call setout opds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "RFDSNT   - Assemble RACF Started Task Table (ICHRIN03)"
call jcd
call jcc mydate()" "comment
call jcd
call jcl "//STEP1    EXEC ASMACL,PARM.C='OBJECT,NODECK',"
call jcl "// PARM.L='SIZE=(320K,250K)' "
call jcl "//C.SYSLIB DD  DSN=SYS1.MACLIB,DISP=SHR "
call jcl "//         DD  DSN=SYS1.MODGEN,DISP=SHR "
call jcl "//SYSIN    DD  * "
call jcl "ICHRIN03 CSECT                                               "
call jcl "TABSTART DC    AL2(NUMENTR)              NUMBER OF ENTRIES   "

privflag = "X'8000000000000000'"
stdflag  = "X'0000000000000000'"

/*------------------------------------------------------------------*/
/* Use STC's from @PARMS.  RFSTCx = VTAM, $RESCUE, $STC             */
/* p1 = Task name, p2 = RACF ID, p3 = RACF Grp.                     */
/*------------------------------------------------------------------*/
stc.0 = 0
DO xx = 1 TO 99
   IF VALUE("RFSTC"xx) = "RFSTC"xx THEN LEAVE
   ent = VALUE("RFSTC"xx)
   PARSE VAR ent zztask ',' zzid ',' zzgrp .
   zztask = strip(zztask,"B")
   zzid = strip(zzid,"B")
   zzgrp  = strip(zzgrp,"B")
   stc.xx = substr(zztask,1,8)""substr(zzid,1,8)""substr(zzgrp,1,8)
END
stc.0 = xx-1
/*------------------------------------------------------------------*/
/* Loop through the entries we've built, and put them in DC stmts.  */
/* Assume trusted and priviledged for all defined tasks.            */
/*------------------------------------------------------------------*/
DO xx = 1 TO stc.0
   call jcl "         DC    C'"stc.xx"',"privflag
END
/*------------------------------------------------------------------*/
/* Finish up the source for the table, and the rest of the JCL.     */
/*------------------------------------------------------------------*/
call jcl "         DC    C'*       =       STC     ',"stdflag
call jcl "NUMENTR  EQU   (*-TABSTART-2)/32+X'8000'"
call jcl "         DC    C'&SYSDATE' "
call jcl "         DC    C'&SYSTIME' "
call jcl "         END "
call jcl "//L.SYSLMOD     DD DSN="ssa""ds",DISP=SHR,"
call jcl "//  UNIT=SYSALLDA,VOL=SER="volser
call jcl "//L.SYSIN       DD *"
call jcl "  NAME ICHRIN03(R) "

call clsout opds,'JOB'jobnum

RETURN

/*=========================================================*/
/* Create IEALPA member from ZIEALPA contents plus an      */
/* entry we'll build for ICHRIN03.                         */
/*=========================================================*/
iealpa:
libs = xdslist('ZLINKLIB')   /* Get ds info for RESCUE.LINKLIB. */
ds = WORD(libs,1); volume = WORD(libs,2)
srch = "ICHRIN03"
txt = "INCLUDE LIBRARY("ds") MODULES( ICHRIN03 )"
call InsertIntoMember ipds,'ZIEALPA',opds,'IEALPA00',txt,srch,1

RETURN

/*=========================================================*/
/* JOB: Define RACF IDs needed for RESCUE system.          */
/* JOB: ID submitting job mist have RACF SPECIAL.          */
/*=========================================================*/
defids:

Say "Building Job "jobnum": Define RACF IDs and Groups for STCs."
call setout opds,'JOB'jobnum
call jobcard jobnum
call jcd
call jcc "Job "jobnum
call jcd
call jcc "RFSTCDEF - Create RACF IDs and groups for started tasks."
call jcd
/*---------------------------------------------------------*/
/* Be sure we have RACF special.                           */
/*---------------------------------------------------------*/
IF \racfspec() THEN DO
   call jcc "*** NOTE: ***"
   call jcc "Userid "USERID()" was used to build this job, but does "
   call jcc "not have the RACF SPECIAL attribute.  If "USERID()" is "
   call jcc "used to run this job, it should first be granted the   "
   call jcc "SPECIAL attribute or the equivalent specific privileges "
   call jcc "needed be to run successfully. RACF violations will  "
   call jcc "result if this is not done."
   call jcd
END
ELSE DO
   call jcc "NOTE: Be sure that the ID used to run this job has the"
   call jcc "RACF SPECIAL attribute, or the equivalent specific    "
   call jcc "privileges required."
   call jcd
END
call jcc mydate()" "comment
call jcd
call jcl "//TSO      EXEC PGM=IKJEFT01,REGION=4M"
call jcl "//SYSPRINT DD SYSOUT=*"
call jcl "//SYSIN    DD DUMMY   "
call jcl "//SYSTSPRT DD SYSOUT=*"
call jcl "//SYSTSIN  DD *"

/*------------------------------------------------------------------*/
/* Delete RACF IDs and Groups.                                      */
/*------------------------------------------------------------------*/
/* Use RFSTCx parms from @PARMS to get userids to be defined.       */
/* Delete each GROUP and ID first, but only if they are not already */
/* defined to the driving system.                                   */
/* jobs to be re-run if desired.                                    */
/*------------------------------------------------------------------*/
DO xx = 1 TO 99
   IF VALUE("RFSTC"xx) = "RFSTC"xx THEN LEAVE
   ent = VALUE("RFSTC"xx)
   ent = translate(ent,' ',',')
   PARSE VAR ent zztask zzid zzgrp .
   zztask = strip(zztask,"B"); zzid = strip(zzid,"B");
   zzgrp  = strip(zzgrp,"B")
   /* Delete ID if needed. */
   IF ckstcid(zzid) THEN DO
      c1 = " DELUSER  "zzid
      IF \idthere(zzid) THEN DO
         call jcl " "
         call jcl c1
      END
      ELSE DO
      /* Comment out the commands, because the ID was already there. */
         SAY zzid" is already defined to RACF, and was not deleted."
         call jcl " "
         e1  = " "zzid" is already defined to RACF, and was"
         e2  = " not deleted.  Select an ID that does not"
         e3  = " already exist, and change the RFSTC statements"
         e4  = " in the @PARMS member and rerun the rescue execs."
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(e1,1,60)" */"
         call jcl " /*"substr(e2,1,60)" */"
         call jcl " /*"substr(e3,1,60)" */"
         call jcl " /*"substr(e4,1,60)" */"
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(c1,1,60)" */"
      END
   END
END
DO xx = 1 TO 99
   IF VALUE("RFSTC"xx) = "RFSTC"xx THEN LEAVE
   ent = VALUE("RFSTC"xx)
   ent = translate(ent,' ',',')
   PARSE VAR ent zztask zzid zzgrp .
   zztask = strip(zztask,"B"); zzid = strip(zzid,"B");
   zzgrp  = strip(zzgrp,"B")
   /* Delete group if needed. */
   IF ckstcgrp(zzgrp) THEN DO
      c1 = " DELGROUP "zzgrp
      IF \grpthere(zzgrp) THEN DO
         call jcl " "
         call jcl c1
      END
      ELSE DO
         SAY zzgrp" is already defined to RACF, and was not deleted."
         call jcl " "
         e1  = " "zzgrp" is already defined to RACF, and was"
         e2  = " not deleted.  Select a Group that does not"
         e3  = " already exist, and change the RFSTC statements"
         e4  = " in the @PARMS member and rerun the rescue execs."
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(e1,1,60)" */"
         call jcl " /*"substr(e2,1,60)" */"
         call jcl " /*"substr(e3,1,60)" */"
         call jcl " /*"substr(e4,1,60)" */"
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(c1,1,60)" */"
      END
   END
END
DROP STCID.
DROP STCGRP.

/*------------------------------------------------------------------*/
/* Define RACF IDs and Groups.                                      */
/*------------------------------------------------------------------*/
/* Use RFSTCx parms from @PARMS to get userids to be defined.       */
/* Define each group and user as needed, but only if they are not   */
/* defined yet. Code a DELGROUP and DELUSER statement to allow the  */
/* jobs to be re-run if desired.                                    */
/*------------------------------------------------------------------*/
DO xx = 1 TO 99
   IF VALUE("RFSTC"xx) = "RFSTC"xx THEN LEAVE
   ent = VALUE("RFSTC"xx)
   ent = translate(ent,' ',',')
   PARSE VAR ent zztask zzid zzgrp .
   zztask = strip(zztask,"B"); zzid = strip(zzid,"B");
   zzgrp  = strip(zzgrp,"B")
   /* Define group if needed. */
   IF ckstcgrp(zzgrp) THEN DO
      c1 = " ADDGROUP "zzgrp" OWNER(SYS1) SUP(SYS1) +"
      c2 = " OMVS(gid(0))"
      IF \grpthere(zzgrp) THEN DO
         call jcl " "
         call jcl c1
         call jcl c2
      END
      ELSE DO
         SAY zzgrp" is already defined to RACF, and was not created."
         call jcl " "
         e1  = " "zzgrp" is already defined to RACF, and was"
         e2  = " not created.  Select a Group that does not"
         e3  = " already exist, and change the RFSTC statements"
         e4  = " in the @PARMS member and rerun the rescue execs."
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(e1,1,60)" */"
         call jcl " /*"substr(e2,1,60)" */"
         call jcl " /*"substr(e3,1,60)" */"
         call jcl " /*"substr(e4,1,60)" */"
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(c1,1,60)" */"
         call jcl " /*"substr(c2,1,60)" */"
      END
   END
END
DO xx = 1 TO 99
   IF VALUE("RFSTC"xx) = "RFSTC"xx THEN LEAVE
   ent = VALUE("RFSTC"xx)
   ent = translate(ent,' ',',')
   PARSE VAR ent zztask zzid zzgrp .
   zztask = strip(zztask,"B"); zzid = strip(zzid,"B");
   zzgrp  = strip(zzgrp,"B")
   /* Define ID if needed. */
   IF ckstcid(zzid) THEN DO
      c1 = " ADDUSER  "zzid" OWNER(SYS1) DFLTGRP("zzgrp") +"
      c2 = " OPERATIONS NOPASSWORD NAME('Rescue System') + "
      c3 = " OMVS(uid(0) home('/') program('/bin/sh') )"
      IF \idthere(zzid) THEN DO
         call jcl " "
         call jcl c1
         call jcl c2
         call jcl c3
      END
      ELSE DO
      /* Comment out the commands, because the ID was already there. */
         SAY zzid" is already defined to RACF, and was not created."
         call jcl " "
         e1  = " "zzid" is already defined to RACF, and was"
         e2  = " not created.  Select an ID that does not"
         e3  = " already exist, and change the RFSTC statements"
         e4  = " in the @PARMS member and rerun the rescue execs."
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(e1,1,60)" */"
         call jcl " /*"substr(e2,1,60)" */"
         call jcl " /*"substr(e3,1,60)" */"
         call jcl " /*"substr(e4,1,60)" */"
         call jcl " /*"substr("",1,61,'-')"*/"
         call jcl " /*"substr(c1,1,60)" */"
         call jcl " /*"substr(c1,1,60)" */"
         call jcl " /*"substr(c2,1,60)" */"
         call jcl " /*"substr(c3,1,60)" */"
      END
   END
END

/*-------------------------------------------*/
/*- Define the TSO PROC to RACF             -*/
/*-------------------------------------------*/
call jcl " "
call jcl " RDEFINE TSOPROC "tsoproc" UACC(READ)"
call jcl " RALTER  TSOPROC "tsoproc" UACC(READ)"
call jcl " SETROPTS RACLIST(TSOPROC) REFRESH"
call jcl " "

call clsout opds,'JOB'jobnum

RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- Program specific functions ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*-------------------------------------------*/
/*-ckstcid - Check if we need to process     */
/*-this stc id.  If not, return 0.  If so,   */
/*-return 1.                                 */
/*-------------------------------------------*/
ckstcid:
ARG ##id
IF STCID.0 = "STCID.0" THEN stcid.0 = 0
DO ##x = 1 TO stcid.0
   IF ##id = stcid.##x THEN RETURN 0
END
##x34 = stcid.0
##x34 = ##x34 + 1
stcid.0 = ##x34
stcid.##x34 = ##id
RETURN 1

ckstcgrp:
ARG ##grp
IF STCGRP.0 = "STCGRP.0" THEN stcgrp.0 = 0
DO ##x = 1 TO stcgrp.0
   IF ##grp = stcgrp.##x THEN RETURN 0
END
##x34 = stcgrp.0
##x34 = ##x34 + 1
stcgrp.0 = ##x34
stcgrp.##x34 = ##grp
RETURN 1

/*---------------------------------------------------------*/
/* idisthere  - Says if a RACF ID is defined.              */
/* grpisthere - Says if a RACF ID is defined.              */
/*---------------------------------------------------------*/
idthere:
ARG ##id
x = outtrap('list.',1)
"LU "##id
 cc = rc
x = outtrap('OFF')
RETURN (cc = 0)

grpthere:
ARG ##grp
x = outtrap('list.',1)
"LG "##grp
 cc = rc
x = outtrap('OFF')
RETURN (cc = 0)

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions - v3.8 ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
IF isblank('@DATASET') THEN zzdsmem = '@DATASET'
ELSE zzdsmem = @DATASET
call setinp ipds,zzdsmem,'D.'
DO ###xx = 1 TO D.0
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN zcontin = 1
   ELSE zcontin = 0
   zrest = STRIP(zrest,"T")
   zrest = STRIP(zrest,"T","-")
   zrest = STRIP(zrest,"T","+")
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */
/*---------------------------------------------------------*/
dsdefined:
ARG #x##dsn2
DO #x#x2 = 1 TO DS.0
   IF DS.#x#x2.verb /= "DATASET" THEN ITERATE
   IF SYMBOL("DS."#x#x2".NEWNAME") = "VAR" THEN,
      #x##dsn = DS.#x#x2.NEWNAME
   ELSE #x##dsn = DS.#x#x2.DSN
   IF #x##dsn2 = #x##dsn THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.  The list  */
/* returned is a space delimited list of dsn+volume pairs, */
/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */
/* The parse_dataset routine must have already be run for  */
/* this routine to work.                                   */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ###xx = 1 TO DS.0
   IF DS.###xx.verb /= "DATASET" THEN ITERATE
   IF attrib(##prm,DS.###xx.PARM) THEN DO
      IF SYMBOL("DS."###xx".NEWNAME") = "VAR" THEN,
      ###dslst = ###dslst" "DS.###xx.NEWNAME DS.###xx.VOL
      ELSE,
      ###dslst = ###dslst" "DS.###xx.DSN DS.###xx.VOL
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* dstype - Return dataset type.                           */
/*---------------------------------------------------------*/
dstype:
ARG ##ds
##x = OUTTRAP('##y.',25)
"LISTD '"##ds"'"
##rc = rc
##x = OUTTRAP('OFF')
IF ##rc > 0 THEN RETURN "ERROR"
ELSE RETURN WORD(##y.3,WORDS(##y.3))

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),ZCLONE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
IF \setinp(ipds,zzprms,'PARMS.') THEN DO
   SAY "Error: Unable to allocate parms member:"ipds"("zzprms")."
   RETURN 0
END
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/* ' .     /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
/* IF r = "" THEN ITERATE */
   r = varsub(r)
   INTERPRET q '= "'r'"'
END
RETURN 1

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem, ##mode
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
IF ##mode = "" THEN ##mode = "SHR"
"ALLOC FI(output) DA('"##ds"("##mem")') "##mode
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
IF SYSDSN("'"##ds2"("##mem2")'") /= "OK" THEN RETURN 0
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(opds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(opds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str ##str2 '.' .
RETURN ##str2

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*---------------------------------------------------------*/
/* nonblank - Determine if a variable is blank or undef.   */
/*---------------------------------------------------------*/
isblank:
PARSE ARG #prm
IF VALUE(#prm) = "" THEN RETURN 1
IF SYMBOL(#prm) = = "LIT" THEN RETURN 1
RETURN 0

/*-------------------------------------------*/
/* Variable substitution.  Return a string   */
/* with all variables interpolated.  Vars    */
/* either be vars coded in the rexx exec     */
/* itself, or parms coded in the @PARMS file.*/
/*-------------------------------------------*/
varsub:
PARSE ARG ####str
####i = POS("&",####str)
DO WHILE ####i > 0
   ####str0 = SUBSTR(####str,1,####i-1)
   ####str2 = SUBSTR(####str,####i)
   ####str2 = TRANSLATE(####str2,"               "," &./()*&%$#@:<>")
   ####str2 = WORD(####str2,1)
   ####l = LENGTH(####str2)+1
   ####str3 = SUBSTR(####str,####i+####l)
   IF ####str2 = ZCLONE THEN ####str2 = ipds
   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)
   ####str = ####str0""####str2""####str3
   ####i = POS("&",####str)
END
RETURN ####str

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Add a text line to a queue.  (actually a  */
/* stem variable.)  This allows us to manage */
/* the output from various processes and     */
/* give the user a more orderly output.      */
/* The "queue" names must be numbers, due to */
/* the vagaries of the rexx interpreter.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* To store a line in queue #1:              */
/*   call qu 1,'Hello World!!'               */
/* To print all lines from queue #1:         */
/*   DO x = 1 TO q.1.0                       */
/*      SAY q.1.x                            */
/*   END                                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qu:
PARSE ARG #q,#data
#ctr = VALUE(q.#q.0)
IF DATATYPE(#ctr) /= 'NUM' THEN DO
   q.#q.0 = 0
   #ctr = 0
END
#ctr=#ctr+1; q.#q.0=#ctr
q.#q.#ctr = #data
return
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Print out all lines of a queue.           */
/* #q   = Queue number to print (1..n)       */
/* #box = 1 -> print line within box chars.  */
/* #box = 0 -> print line w/no box chars.    */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qup:
PARSE ARG #q,#box
IF #box /= 1 THEN #box = 0
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN
DO ##x = 1 TO q.#q.0
   IF #box THEN say box(q.#q.##x)
   ELSE            say q.#q.##x
END
RETURN

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Queue has lines: 0|1                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/
quhaslines:
PARSE ARG #q
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0
ELSE RETURN 1

/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Get volume for a given dataset.           */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getvol:
PARSE ARG ####d
DO ####x=1 TO DS.0
   IF \isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME
   ELSE                               ####d2 = DS.####x.DSN
   IF ####d = ####d2 THEN RETURN DS.####x.VOL
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* InsertIntoMember:  Insert some text into  */
/* a member, but only if a search string is  */
/* found/not found.  If ##negative is set to */
/* 1, then only insert if the search string  */
/* is not found.  Otherwise, only insert the */
/* string if the search string IS found.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
insertIntoMember:
PARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative

IF setinp(##ds, ##mem) THEN DO
   ##foun=0
   DO ##xx = 1 TO INPUT.0
      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1
   END
   IF ##negative  = 1 &  ##foun THEN RETURN 0
   IF ##negative /= 1 & \##foun THEN RETURN 0
   call clsinp ##ds, ##mem
   call setout ##ods, ##omem
   DO ##xx = 1 TO INPUT.0
      call jcl INPUT.##xx
   END
END
ELSE DO
   call setout ##ods, ##omem
END
call jcl ##txt
call clsout ##ds, ##mem
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* hasParms - True if any of the coded parms */
/* are present for a dataset.                */
/*- - - - - - - - - - - - - - - - - - - - - -*/
hasParms:
PARSE ARG ##prms, ##dsprms
##dsprms = TRANSLATE(##dsprms,' ',',')
DO ####hp = 1 TO WORDS(##prms)
   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* vsam_part:  Return name of DATA or INDEX  */
/* component of a VSAM file.                 */
/*- - - - - - - - - - - - - - - - - - - - - -*/
vsam_part:
ARG ##part,##ds
##x = OUTTRAP('##y.',25)
"LISTC ENT('"ds"')"
##rc = rc
##x = OUTTRAP('OFF')
DO ##x = 1 TO ##y.0
   say ##y.##x
   PARSE VAR ##y.##x (##part) "------- " zzdsn .
   IF zzdsn /= "" THEN RETURN zzdsn
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* volsym:  If USESYM=YES in @PARMS, then    */
/* substitute "&SYSRn" for the volser passed.*/
/* Otherwise, just spit back the volser.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
volsym:
PARSE ARG ##volser
IF isblank("USESYM") THEN RETURN ##volser
IF USESYM /= "YES" & USERSYM /= "1" THEN RETURN ##volser

DO ##zz = 1 TO 99
   IF \isblank("VOLSER"##zz) & \isblank("ADDR"##zz) THEN DO
      ###zvolser = VALUE("VOLSER"##zz)
      IF ##volser = ###zvolser THEN RETURN "&SYSR"##zz
   END
END

RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getssa: Return the appropriate SSA for a  */
/* dataset.  If usercat is defined and an    */
/* alias to the usercat would be applied to  */
/* this dataset, then return the SSAU value. */
/* Else, return the SSA value (for the mcat).*/
/*- - - - - - - - - - - - - - - - - - - - - -*/
getssa:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN SSA

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) & \isblank("NEWUCAT") THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN SSAU
   END
END

RETURN SSA

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getcat: Return the appropriate catalog in */
/* which to catalog a dataset--either the    */
/* mastercat or usercat.                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getcat:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN NEWMCAT

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT
   END
END

RETURN NEWMCAT

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- end low level functions -------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
./ ADD NAME=#VALIDAT
/*---------------------------------------------------Rexx--*/
/* VALIDAT - Validate the @PARMS and @DATASET members.     */
/*---------------------------------------------------------*/
/* This member attempts to find problems with the PARMS    */
/* and DATASET members that would cause problems with the  */
/* build.                                                  */
/*---------------------------------------------------------*/
/* 07/16/2007 John C. Miller                               */
/*---------------------------------------------------------*/
ARG ipds opds zzprms .

IF \varinit() THEN RETURN 1 /* Read parms, initialize vars. */

has_errors = 0

IF VALIDPARMS = 'NO' THEN DO
   call qu 1,,
   '--------------------- Validity Checking Bypassed -----------------'
   call qu 1,""
   return has_errors
END

call parse_dataset     /* Parse dataset list.              */

/*---------------------------------------------------------*/
/* PARMS                                                   */
/*---------------------------------------------------------*/
heading='PARMS'
call qu 1,,
'---------------------- Starting validation -----------------------'
/*-----------*/
/* JOBCARDx  */
/*-----------*/
IF isblank('jobcard1') THEN DO
   has_errors = 1
   call qu 1,'Error: JOBCARD'
   call qu 1,,
   'JOBCARD1 must be a valid JOB statement.  JOBCARD2-10 are optional'
   call qu 1,' '
END

/*-----------*/
/* TSOPROC   */
/*-----------*/
IF isblank('tsoproc') THEN DO
   has_errors = 1
   call qu 1,'Error: TSOPROC'
   call qu 1,,
   'TSOPROC must be a valid TSO PROC name.'
   call qu 1,' '
END

/*-----------*/
/* TSOIDS    */
/*-----------*/
IF isblank('tsoid1') THEN DO
   has_errors = 1
   call qu 1,'Error: TSOID'
   call qu 1,,
   'You must specify at least one TSO Userid in the TSOID1 parm field.'
   call qu 1,' '
END

/*-----------*/
/* DEVTYPE   */
/*-----------*/
IF isblank('devtype') THEN DO
   has_errors = 1
   call qu 1,'Error: DEVTYPE'
   call qu 1,,
   'You must specify a valid generic (e.g. 3390, 3390, etc.) in the'
   call qu 1,,
   'DEVTYPE field.  You can also specify a valid esoteric (e.g. SYSDA)'
   call qu 1,,
   'if defined on your system.'
   call qu 1,' '
END

/*-----------*/
/* VOLSERnn  */
/* ADDRnn    */
/*-----------*/
IF SYMBOL("VOLSER1") /= "VAR" | VALUE("VOLSER1") = "" THEN DO
   has_errors = 1
   call qu 1,'Error: VOLSER'
   call qu 1,,
   'At least one VOLSER/ADDR pair (VOLSER1/ADDR1) is required.'
END
IF SYMBOL("ADDR1") /= "VAR" | VALUE("ADDR1") = "" THEN DO
   has_errors = 1
   call qu 1,'Error: VOLSER'
   call qu 1,,
   'At least one VOLSER/ADDR pair (VOLSER1/ADDR1) is required.'
END
DO y = 1 TO 99
   IF \isblank("VOLSER"y) THEN DO
      zzvol = VALUE("VOLSER"y)
      IF LENGTH(zzvol) > 6 THEN DO
         has_errors = 1
         call qu 1,'Error: VOLSER'
         call qu 1,,
         '   VOLSER'y' value 'zzvol' must be less than 6 chars.'
         call qu 1," "
      END
      IF isblank("ADDR"y) THEN DO
         has_errors = 1
         call qu 1,'Error: ADDR'
         call qu 1,,
         '   VOLSER'y' was specified, but ADDR'y' was also needed. '
         call qu 1," "
      END
   END
END
DO y = 1 TO 99
   IF \isblank("ADDR"y) THEN DO
      zzadr = VALUE("ADDR"y)
      IF LENGTH(zzadr) > 4 THEN DO
         has_errors = 1
         call qu 1,'Error: ADDR'
         call qu 1,,
         'ADDR'y' value 'zzadr' invalid.  Must be less than 5 chars.'
         call qu 1," "
      END
      IF isblank("VOLSER"y) THEN DO
         has_errors = 1
         call qu 1,'Error: VOLSER'
         call qu 1,,
         '   ADDR'y' was specified, but VOLSER'y' was also needed. '
         call qu 1," "
      END
   END
END

/*-----------*/
/* Assorted  */
/*-----------*/
IF isblank('ioconfigid') THEN DO
   has_errors = 1
   call qu 1,'Error: IOCONFIGID'
   call qu 1,,
   '   IOCONFIGID must have coded one of the valid system config'
   call qu 1,,
   '   values as defined in your IODF.  Use HCD option 1.1 to see   '
   call qu 1,,
   '   what system config values are defined in an IODF file.'
   call qu 1," "
END

IF isblank('smfid') THEN DO
   has_errors = 1
   call qu 1,'Error: SMFID'
   call qu 1,,
   'SMFID must have coded the 4 character SMF ID of your choosing.'
   call qu 1," "
END

IF isblank('newmcat') THEN DO
   has_errors = 1
   call qu 1,'Error: NEWMCAT'
   call qu 1,,
   'NEWMCAT must have coded the name of the new RESCUE system master'
   call qu 1,,
   'catalog.'
   call qu 1," "
END

IF isblank('oldmcat') THEN DO
   has_errors = 1
   call qu 1,'Error: OLDMCAT'
   call qu 1,,
   'OLDMCAT must have coded the name of the driving system master'
   call qu 1,,
   'catalog. '
   call qu 1," "
END

IF isblank('sysres') THEN DO
   has_errors = 1
   call qu 1,'Error: SYSRES'
   call qu 1,,
   'SYSRES must have coded the volser of your IPL volume.'
   call qu 1," "
END

/*---------------------------------------------------------*/
/* JES2                                                    */
/*---------------------------------------------------------*/

/*----------*/
/* SPOOLPRF */
/*----------*/
IF isblank("spoolprf") THEN DO
   call qu 1,,
   'Warning: SPOOLPRF:'
   call qu 1,,
   '   SPOOLPRF Value not coded in @PARMS, using a value of 4.'
   call qu 1,""
END
IF spoolprf < 4 | spoolprf > 6 THEN DO
   call qu 1,,
   'Warning: SPOOLPRF:'
   call qu 1,,
   '   SPOOLPRF value must be 4 through 6. Using a value of 4.'
   call qu 1,""
END

/*----------*/
/* HASPCKPT */
/*----------*/
libs = xdslist('HASPCKPT')
IF WORDS(libs) = 0 THEN DO
   has_errors = 1
   call qu 1,'Error: HASPCKPT'
   call qu 1,,
   '   No HASCKPT dataset has been defined. Make sure you have at least'
   call qu 1,,
   '   one JES2 CKPT dataset defined in the @DATASET member, and that'
   call qu 1,,
   '   it has PARM(HASPCKPT) on the entry.'
   call qu 1,' '
END
IF WORDS(libs) > 4 THEN DO
   call qu 1,'Warning: HASPCKPT'
   call qu 1,,
   '   More than two JES2 CKPT datasets were defined.  The first two '
   call qu 1,,
   '   datasets will be defined as CKPT1 and CKPT2 respectively, and'
   call qu 1,,
   '   others will be defined as specified, but not used as JES2 CKPT '
   call qu 1,,
   'datasets.'
   call qu 1,' '
END

/*---------------------------------------------------------*/
/* Analyze the @DATASET member for:                        */
/* - Make sure datasets exist when necessary;              */
/* - Make sure a defined volume for a ds exists.           */
/*---------------------------------------------------------*/
dscheck1:
DO ###xx = 1 TO DS.0
   /*--------------------------------------------------*/
   /* If DATASET ALLOC coded, be sure SPACE is coded   */
   /* and either MODEL or DCB is coded.                */
   /*--------------------------------------------------*/
   IF DS.###xx.verb = "DATASET" & DS.###xx.option = "ALLOC" THEN DO
      zzDSN  = DS.###xx.DSN
      zbDCB  = (SYMBOL("DS."###xx".DCB")   = "VAR")
      zbMOD  = (SYMBOL("DS."###xx".MODEL") = "VAR")
      zbSPA  = (SYMBOL("DS."###xx".SPACE") = "VAR")
      zbSMF  = hasParms("SMF",DS.###xx.PARM)
      zbLOGR = hasparms("WLM LOGR XCF",DS.###xx.PARM)
      zzEXCEPTIONS = "STGINDEX PGPLPA PGCOMMON PGLOCAL"
      zbPAG = hasParms(zzEXCEPTIONS,DS.###xx.PARM)
      IF \(zbSPA | zbLOGR) THEN DO
         call qu 1,'Error: 'zzdsn
         call qu 1,,
         '   SPACE not coded for an ALLOC only dsn.'
         call qu 1," "
         has_errors = 1
      END
      IF \(zbMOD | zbDCB | zbSMF | zbPAG | zbLOGR) THEN DO
         call qu 1,'Error: 'zzdsn
         call qu 1,,
         '   Either MODEL or DCB must be coded for ALLOC only dsn.'
         call qu 1," "
         has_errors = 1
      END
   END

   /*--------------------------------------------------*/
   /* For certain types of datasets, give an error if  */
   /* the COPY verb was specified.                     */
   /*--------------------------------------------------*/
   zzNoCopyParms = " SMF HASPACE HASPCKPT"
   zzPARM        = DS.###xx.PARM
   zzThisDSN     = DS.###xx.DSN
   zzThisOPTION  = DS.###xx.OPTION

   trace off
   IF zzThisOPTION = "COPY" THEN,
   DO ###xx2 = 1 TO WORDS(zzNoCopyParms)
      zzThisParm = WORD(zzNoCopyParms,###xx2)
      IF POS(zzThisParm,zzPARM) > 0 THEN DO
         call qu 1,'Error: 'zzThisDSN
         call qu 1,,
         '   Invalid dataset type for COPY mode:' zzThisParm
         call qu 1,,
         '   'zzThisParm' datasets should be coded as ALLOC, and have'
         call qu 1,,
         '   SPACE coded, and either MODEL or DCB coded.'
         call qu 1," "
         has_errors = 1
      END
   END

   /*--------------------------------------------------*/
   /* If MODEL() is coded, make sure it exists.        */
   /*--------------------------------------------------*/
   IF SYMBOL("DS."###xx".MODEL") = "VAR" THEN DO
      xxdsn = DS.###xx.MODEL
      stat = SYSDSN("'"xxdsn"'")
      IF stat /= 'OK' THEN DO
         call qu 1,'Error: 'xxdsn
         call qu 1,,
         '   Model dataset not found: 'xxdsn
         call qu 1," "
         has_errors = 1
      END
   END

   /*--------------------------------------------------*/
   /* If DATASET COPY coded, make sure "copy from"     */
   /* dataset exists.                                  */
   /*--------------------------------------------------*/
   IF DS.###xx.verb = "DATASET" & DS.###xx.option = "COPY" THEN DO
      xxdsn = DS.###xx.DSN
      stat = SYSDSN("'"XXdsn"'")
      IF stat /= 'OK' THEN DO
         call qu 1,'Error: 'xxdsn' - Dataset not found.'
         call qu 1," "
         has_errors = 1
      END
   END

   /*--------------------------------------------------*/
   /* If RACF dataset is being copied, make sure SPACE */
   /* is coded. This is because we use IRRUT400 to do  */
   /* the COPY, and it can't tell how bit the src      */
   /* RACF dataset is.                                 */
   /*--------------------------------------------------*/
   IF hasParms("RACFDS",DS.###xx.PARM) & isblank("DS."###xx".SPACE") ,
   THEN DO
      xxdsn = DS.###xx.DSN
      call qu 1,'Error: RACFDS'
      call qu 1,,
      '   COPY of RACF dataset requires a SPACE parameter.'
      call qu 1," "
      has_errors = 1
   END
END

/*---------------------------------------------------------*/
/* Check all MEMCOPY statements to be sure both IN and OUT */
/* datasets exist.                                         */
/*---------------------------------------------------------*/
memcopycheck:
DO ###xx = 1 TO DS.0
   /*- - - - - - - - - - - - - - - - - - - - - - */
   /* If not a MEMCOPY then skip to next record  */
   /* Otherwise copy some variables out of the   */
   /* DS. stem var.                              */
   /*- - - - - - - - - - - - - - - - - - - - - - */
   IF DS.###xx.verb /= "MEMCOPY" THEN ITERATE
   zzIN  = DS.###xx.IN
   zzOUT = DS.###xx.OUT
   zzMEM = DS.###xx.M
   /* SAY zzOUT zzMEM dsdefined(zzOUT)           */
   /*- - - - - - - - - - - - - - - - - - - - - - */
   /* Check OUT ds - Must be defined by a        */
   /* DATASET COPY or DATASET ALLOC command.     */
   /*- - - - - - - - - - - - - - - - - - - - - - */
   IF \dsdefined(zzOUT) THEN DO
      has_errors=1
      call qu 1,"Error: MEMCOPY-OUT"
      call qu 1,"MEMCOPY OUT dataset "zzOUT" is not defined with either"
      call qu 1,"a DATASET COPY or DATASET ALLOC statement."
   END
   /*- - - - - - - - - - - - - - - - - - - - - - */
   /* Check IN ds - Should either exist now, or  */
   /* be created with a DATASET ALLOC or COPY.   */
   /*- - - - - - - - - - - - - - - - - - - - - - */
   IF SYSDSN("'"zzIN"'") /= 'OK' & \dsdefined(zzIN) THEN DO
      has_errors=1
      call qu 1,"Error: MEMCOPY-IN"
      call qu 1,"MEMCOPY IN dataset "zzIN "does not exist, and is also "
      call qu 1,"not defined as a new dataset with a DATASET stmt."
   END
END

/*---------------------------------------------------------*/
/* Check to ensure that there is at least one dataset      */
/* coded in @DATASET for each of certain parm values.      */
/* Other datasets must be coded once and only once.        */
/*---------------------------------------------------------*/
dscheck2:
IF \check_parm_present('SYSUADS')   THEN call error_parm('SYSUADS')
IF \check_parm_present('SYSLBC')    THEN call error_parm('SYSLBC')
IF \check_parm_present('HASPACE')   THEN call error_parm('HASPACE')
IF \check_parm_present1('PGPLPA')   THEN call error_parm1('PGPLPA')
IF \check_parm_present1('PGCOMMON') THEN call error_parm1('PGCOMMON')
IF \check_parm_present('PGLOCAL')   THEN call error_parm('PGLOCAL')

IF \check_parm_present1('ZLINKLIB') THEN call error_parm1('ZLINKLIB')
IF \check_parm_present1('ZPROCLIB') THEN call error_parm1('ZPROCLIB')
IF \check_parm_present1('ZPARMLIB') THEN call error_parm1('ZPARMLIB')
IF \check_parm_present1('ZSYSPROC') THEN call error_parm1('ZSYSPROC')
IF \check_parm_present1('IPLPARM')     THEN,
   call error_parm1('IPLPARM'),,
   "No IPLPARM file was specified in the @DATASET member."
IF \check_parm_present1('IODF')     THEN,
   call error_parm1('IODF'),,
   "No IODF file was specified in the @DATASET member."
IF \check_parm_present1('ACDS')     THEN,
   call error_parm1('SMS: ACDS'),,
   "No ACDS file was specified in the @DATASET member."
IF \check_parm_present1('COMMDS')     THEN,
   call error_parm1('SMS: COMMDS'),,
   "No COMMDS file was specified in the @DATASET member."

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of dscheck                                          */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

call qu 1,,
'--------------------- End of validity checking -------------------'
call qu 1,""

call qup 1

return has_errors

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- program specific functions ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*-------------------------------------------*/
/* Make sure volume coded in a @DATASET      */
/* entry has been defined in @PARMS.         */
/*-------------------------------------------*/
check_volume:
ARG ##vol
DO y = 1 TO 99
   IF \isblank("VOLSER"y) THEN,
      IF ##prm = VALUE("VOLSER"y) THEN RETURN 1
END
RETURN 0

/*-------------------------------------------*/
/* Make sure parm "x" is defined in at least */
/* one entry in @DATASET.                    */
/*-------------------------------------------*/
check_parm_present:
ARG ##prm
##libs = xdslist(##prm)
RETURN WORDS(##libs) > 0

warn_parm:
ARG ##prm,##msg
call qu 1,"Warning: "##prm
IF ##msg = "" THEN ##msg =,
   "   No dataset was defined with this PARM value."
call qu 1,##msg
call qu 1,,
##prm": This may cause problems with the target system."
RETURN

error_parm:
ARG ##prm,##msg
call qu 1,"Error: "##prm
IF ##msg = "" THEN ##msg =,
"   At least one dataset must be defined with this PARM value."
call qu 1,##msg
has_errors = 1
RETURN

check_parm_present1:
ARG ##prm
##libs = xdslist(##prm)
RETURN WORDS(##libs) = 2

error_parm1:
ARG ##prm,##msg
call qu 1,"Error: "##prm
IF ##msg = "" THEN ##msg =,
   "   One and only one dataset must be defined with this PARM value."
call qu 1,##msg
has_errors = 1
RETURN


/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions - v3.8 ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
IF isblank('@DATASET') THEN zzdsmem = '@DATASET'
ELSE zzdsmem = @DATASET
call setinp ipds,zzdsmem,'D.'
DO ###xx = 1 TO D.0
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN zcontin = 1
   ELSE zcontin = 0
   zrest = STRIP(zrest,"T")
   zrest = STRIP(zrest,"T","-")
   zrest = STRIP(zrest,"T","+")
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */
/*---------------------------------------------------------*/
dsdefined:
ARG #x##dsn2
DO #x#x2 = 1 TO DS.0
   IF DS.#x#x2.verb /= "DATASET" THEN ITERATE
   IF SYMBOL("DS."#x#x2".NEWNAME") = "VAR" THEN,
      #x##dsn = DS.#x#x2.NEWNAME
   ELSE #x##dsn = DS.#x#x2.DSN
   IF #x##dsn2 = #x##dsn THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.  The list  */
/* returned is a space delimited list of dsn+volume pairs, */
/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */
/* The parse_dataset routine must have already be run for  */
/* this routine to work.                                   */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ###xx = 1 TO DS.0
   IF DS.###xx.verb /= "DATASET" THEN ITERATE
   IF attrib(##prm,DS.###xx.PARM) THEN DO
      IF SYMBOL("DS."###xx".NEWNAME") = "VAR" THEN,
      ###dslst = ###dslst" "DS.###xx.NEWNAME DS.###xx.VOL
      ELSE,
      ###dslst = ###dslst" "DS.###xx.DSN DS.###xx.VOL
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* dstype - Return dataset type.                           */
/*---------------------------------------------------------*/
dstype:
ARG ##ds
##x = OUTTRAP('##y.',25)
"LISTD '"##ds"'"
##rc = rc
##x = OUTTRAP('OFF')
IF ##rc > 0 THEN RETURN "ERROR"
ELSE RETURN WORD(##y.3,WORDS(##y.3))

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),ZCLONE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
IF \setinp(ipds,zzprms,'PARMS.') THEN DO
   SAY "Error: Unable to allocate parms member:"ipds"("zzprms")."
   RETURN 0
END
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/* ' .     /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
/* IF r = "" THEN ITERATE */
   r = varsub(r)
   INTERPRET q '= "'r'"'
END
RETURN 1

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem, ##mode
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
IF ##mode = "" THEN ##mode = "SHR"
"ALLOC FI(output) DA('"##ds"("##mem")') "##mode
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
IF SYSDSN("'"##ds2"("##mem2")'") /= "OK" THEN RETURN 0
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(opds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(opds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str ##str2 '.' .
RETURN ##str2

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*---------------------------------------------------------*/
/* nonblank - Determine if a variable is blank or undef.   */
/*---------------------------------------------------------*/
isblank:
PARSE ARG #prm
IF VALUE(#prm) = "" THEN RETURN 1
IF SYMBOL(#prm) = = "LIT" THEN RETURN 1
RETURN 0

/*-------------------------------------------*/
/* Variable substitution.  Return a string   */
/* with all variables interpolated.  Vars    */
/* either be vars coded in the rexx exec     */
/* itself, or parms coded in the @PARMS file.*/
/*-------------------------------------------*/
varsub:
PARSE ARG ####str
####i = POS("&",####str)
DO WHILE ####i > 0
   ####str0 = SUBSTR(####str,1,####i-1)
   ####str2 = SUBSTR(####str,####i)
   ####str2 = TRANSLATE(####str2,"               "," &./()*&%$#@:<>")
   ####str2 = WORD(####str2,1)
   ####l = LENGTH(####str2)+1
   ####str3 = SUBSTR(####str,####i+####l)
   IF ####str2 = ZCLONE THEN ####str2 = ipds
   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)
   ####str = ####str0""####str2""####str3
   ####i = POS("&",####str)
END
RETURN ####str

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Add a text line to a queue.  (actually a  */
/* stem variable.)  This allows us to manage */
/* the output from various processes and     */
/* give the user a more orderly output.      */
/* The "queue" names must be numbers, due to */
/* the vagaries of the rexx interpreter.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* To store a line in queue #1:              */
/*   call qu 1,'Hello World!!'               */
/* To print all lines from queue #1:         */
/*   DO x = 1 TO q.1.0                       */
/*      SAY q.1.x                            */
/*   END                                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qu:
PARSE ARG #q,#data
#ctr = VALUE(q.#q.0)
IF DATATYPE(#ctr) /= 'NUM' THEN DO
   q.#q.0 = 0
   #ctr = 0
END
#ctr=#ctr+1; q.#q.0=#ctr
q.#q.#ctr = #data
return
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Print out all lines of a queue.           */
/* #q   = Queue number to print (1..n)       */
/* #box = 1 -> print line within box chars.  */
/* #box = 0 -> print line w/no box chars.    */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qup:
PARSE ARG #q,#box
IF #box /= 1 THEN #box = 0
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN
DO ##x = 1 TO q.#q.0
   IF #box THEN say box(q.#q.##x)
   ELSE            say q.#q.##x
END
RETURN

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Queue has lines: 0|1                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/
quhaslines:
PARSE ARG #q
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0
ELSE RETURN 1

/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Get volume for a given dataset.           */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getvol:
PARSE ARG ####d
DO ####x=1 TO DS.0
   IF \isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME
   ELSE                               ####d2 = DS.####x.DSN
   IF ####d = ####d2 THEN RETURN DS.####x.VOL
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* InsertIntoMember:  Insert some text into  */
/* a member, but only if a search string is  */
/* found/not found.  If ##negative is set to */
/* 1, then only insert if the search string  */
/* is not found.  Otherwise, only insert the */
/* string if the search string IS found.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
insertIntoMember:
PARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative

IF setinp(##ds, ##mem) THEN DO
   ##foun=0
   DO ##xx = 1 TO INPUT.0
      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1
   END
   IF ##negative  = 1 &  ##foun THEN RETURN 0
   IF ##negative /= 1 & \##foun THEN RETURN 0
   call clsinp ##ds, ##mem
   call setout ##ods, ##omem
   DO ##xx = 1 TO INPUT.0
      call jcl INPUT.##xx
   END
END
ELSE DO
   call setout ##ods, ##omem
END
call jcl ##txt
call clsout ##ds, ##mem
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* hasParms - True if any of the coded parms */
/* are present for a dataset.                */
/*- - - - - - - - - - - - - - - - - - - - - -*/
hasParms:
PARSE ARG ##prms, ##dsprms
##dsprms = TRANSLATE(##dsprms,' ',',')
DO ####hp = 1 TO WORDS(##prms)
   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* vsam_part:  Return name of DATA or INDEX  */
/* component of a VSAM file.                 */
/*- - - - - - - - - - - - - - - - - - - - - -*/
vsam_part:
ARG ##part,##ds
##x = OUTTRAP('##y.',25)
"LISTC ENT('"ds"')"
##rc = rc
##x = OUTTRAP('OFF')
DO ##x = 1 TO ##y.0
   say ##y.##x
   PARSE VAR ##y.##x (##part) "------- " zzdsn .
   IF zzdsn /= "" THEN RETURN zzdsn
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* volsym:  If USESYM=YES in @PARMS, then    */
/* substitute "&SYSRn" for the volser passed.*/
/* Otherwise, just spit back the volser.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
volsym:
PARSE ARG ##volser
IF isblank("USESYM") THEN RETURN ##volser
IF USESYM /= "YES" & USERSYM /= "1" THEN RETURN ##volser

DO ##zz = 1 TO 99
   IF \isblank("VOLSER"##zz) & \isblank("ADDR"##zz) THEN DO
      ###zvolser = VALUE("VOLSER"##zz)
      IF ##volser = ###zvolser THEN RETURN "&SYSR"##zz
   END
END

RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getssa: Return the appropriate SSA for a  */
/* dataset.  If usercat is defined and an    */
/* alias to the usercat would be applied to  */
/* this dataset, then return the SSAU value. */
/* Else, return the SSA value (for the mcat).*/
/*- - - - - - - - - - - - - - - - - - - - - -*/
getssa:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN SSA

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) & \isblank("NEWUCAT") THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN SSAU
   END
END

RETURN SSA

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getcat: Return the appropriate catalog in */
/* which to catalog a dataset--either the    */
/* mastercat or usercat.                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getcat:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN NEWMCAT

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT
   END
END

RETURN NEWMCAT

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- end low level functions -------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
./ ADD NAME=@DATASET
*--------------------------------------------------------------------*
*  EXAMPLE: Build a single-volume (3390-9) zOS rescue system.        *
*--------------------------------------------------------------------*
*  Note:  Several different symbolic variables are used in the VOL() *
*         parameter below.  For this particular system build, all of *
*         the variables (e.g. &CATVOL, &SYSVL1, &SYSVL2, etc.) point *
*         to the same physical volume, as we are building a single   *
*         volume RESCUE system.  This relationship is set up in the  *
*         @PARMS member.  Setting it up this way makes it a simpler  *
*         matter to spread the datasets out over multiple volumes    *
*         if/when desired.                                           *
*         If no VOL() is coded, the first volume &VOLSER1 is used.   *
*--------------------------------------------------------------------*
*  Dataset Definitions:                                              *
*--------------------------------------------------------------------*
*  Supported verbs are:                                              *
*  DATASET                                                           *
*  MEMCOPY                                                           *
*--------------------------------------------------------------------*
*  DATASET verb:                                                     *
*     The DATASET verb is used to define datasets that are to be     *
*     created on the new system.  They are either copied or          *
*     allocated, as specified by the COPY or ALLOC suboptions resp-  *
*     ectively.                                                      *
*  DATASET COPY PARAMETERS:                                          *
*  -  PARM(parms) One or more comma separated parameters that tell   *
*     what the dataset is used for, or special attributes that it    *
*     has.  The PARM field is used by the zClone execs to identify   *
*     datasets to be coded in PROCs, PARMLIB members, and other      *
*     special handling needs (like formatting LOGREC e.g.).          *
*     - HASPACE   The dataset is a JES2 spool dataset.               *
*     - HASPCKPT  The dataset is a JES2 checkpoint dataset.          *
*     - SYSUADS   The dataset is the UADS dataset.                   *
*     - SYSLBC    The dataset is the BRODCAST dataset.               *
*     - ISPPLIB   ISPF panel lib to be added to ISPPLIB concat.      *
*     - ISPMLIB   ISPF msg lib to be added to ISPMLIB concat.        *
*     - ISPSLIB   ISPF skel lib to be added to ISSPLIB concat.       *
*     - ISPTLIB   ISPF table lib to be added to ISTPLIB concat.      *
*     - SYSPROC   Lib to be in SYSPROC concatenation.                *
*     - VTAMLST   Lib to be in VTAMLST concatenation.                *
*     - VTAMLIB   Lib to be in VTAMLIB concatenation.                *
*     - APF,LNK   Lib to be in APF list or LNKLST respectively.      *
*     - LPA       Lib to be in LPALST.                               *
*     - ACDS      Dataset is the SMS ACDS.                           *
*     - COMMDS    Dataset is the SMS COMMDS.                         *
*     - RLSE      Space should be released after copy.               *
*     - SMF       MANx VSAM file tb formatted as SMF dataset.        *
*     The following should be coded once and only once, and are used *
*     by the ZCLONE execs to build various system components.        *
*     - ZLINKLIB  Dataset is the ZCLONE utility LINKLIB.             *
*     - ZPROCLIB  Dataset is the ZCLONE utility PROCLIB.             *
*     - ZPARMLIB  Dataset is the ZCLONE utility PARMLIB.             *
*     - ZSYSPROC  Dataset is the ZCLONE utility SYSPROC (clist) lib. *
*--------------------------------------------------------------------*
*  REQUIRED - DON'T DELETE THE NEXT SET OF ENTRIES FROM HERE UNTIL   *
*     |       THE NEXT COMMENT BLOCK. THESE ARE BASIC PARTS OF THE   *
*     |       RESCUE SYSTEM BUILD PROCESS, AND THE EXEC MAY BREAK IF *
*     V       THESE STATEMENTS ARE ALTERED.                          *
*--------------------------------------------------------------------*

 DATASET ALLOC DSN(SYS1.Z&CLN.CLIST) MODEL(SYS1.PARMLIB) -
               SPACE(CYL,(2,0,15)) PARM(ZSYSPROC,SYSPROC)

 DATASET ALLOC DSN(SYS1.Z&CLN.PARMLIB) SPACE(CYL,(1,0,15)) -
               MODEL(SYS1.PARMLIB) PARM(ZPARMLIB,PARMLIB)

 DATASET ALLOC DSN(SYS1.Z&CLN.LINKLIB) SPACE(CYL,(2,0,25)) -
               MODEL(SYS1.LINKLIB) PARM(ZLINKLIB,APF,LNK)

 DATASET ALLOC DSN(SYS1.Z&CLN.PROCLIB) SPACE(CYL,(2,0,25)) -
               MODEL(SYS1.PARMLIB) PARM(ZPROCLIB,PROCLIB)

 DATASET ALLOC DSN(SYS1.IPLPARM) SPACE(CYL,(2,0,25)) -
               MODEL(SYS1.PARMLIB) PARM(IPLPARM)

 MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.CLIST)   M(ZISPALOC,ISPALLOC)
 MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZCOMMND,COMMND00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(COUPLE00)
 MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZIEALPA,IEALPA00)
 MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZIEFSSN,IEFSSN00)
 MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZTSOKEY,TSOKEY00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(BPXPRM00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(IEASYM00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(IEASYS00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(IGDSMS00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(JES2PARM)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(LPALST00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(MSTJCL01)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(PROGA0)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(PROGL0)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(VATLST00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(&TSOPROC)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(JES2)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(TSO)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(VTAM)
 MEMCOPY IN(&OPDS) OUT(SYS1.IPLPARM) M(LOAD00)

*--------------------------------------------------------------------*
*  END OF REQUIRED STATEMENTS.                                       *
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
* Local datasets - Assorted PDS's and members that we want.          *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(SYS2.LINKLIB) PARM(APF,LNK) VOL(&CATVOL)
 DATASET COPY  DSN(SYS2.CMDPROC) PARM(SYSPROC) VOL(&CATVOL)
 DATASET COPY  DSN(COMPJM.CNTL)  VOL(&CATVOL)
 DATASET COPY  DSN(COMPJM.EXEC)  VOL(&CATVOL)
 DATASET ALLOC DSN(SYS2.ISPPLIB) MODEL(SYS1.PARMLIB) -
         SPACE(CYL,(2,0,15)) PARM(ISPPLIB)  VOL(&CATVOL)
 DATASET COPY  DSN(SYS2.TCPIP)   VOL(&CATVOL)
 MEMCOPY IN(CPAC.CMDPROC) OUT(SYS1.Z&CLN.CLIST)   M(@HCD)
 MEMCOPY IN(CPAC.CMDPROC) OUT(SYS1.Z&CLN.CLIST)   M(@ISMF)
 MEMCOPY IN(SYS2.ISPPLIB) OUT(SYS2.ISPPLIB)       M(ISR@PRIM)

*--------------------------------------------------------------------*
*  OMVS Datasets:                                                    *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(OMVS.ROOT)     VOL(&HFSVOL)  MOUNT('/')
 DATASET COPY  DSN(OMVS.ETC)      VOL(&HFSVOL)  MOUNT('/etc')
 DATASET COPY  DSN(OMVS.AFOROOT)  VOL(&HFSVOL)  MOUNT('/usr/lib/ssh')
 DATASET COPY  DSN(OMVS.VAR)      VOL(&HFSVOL)  MOUNT('/var')
 DATASET COPY  DSN(OMVS.SIBMROOT) VOL(&HFSVOL)  MOUNT('/usr/lpp/pli')
 DATASET COPY  DSN(OMVS.SIGYROOT) VOL(&HFSVOL)  -
               MOUNT('/usr/lpp/cobol')

*--------------------------------------------------------------------*
*  Page and other system VSAM datasets.                              *
*--------------------------------------------------------------------*
 DATASET ALLOC DSN(PAGE.Z&CLN.PLPA)    SPACE(CYL,(150)) PARM(PGPLPA) -
         VOL(&CATVOL)
 DATASET ALLOC DSN(PAGE.Z&CLN.COMMON) SPACE(CYL,(150)) PARM(PGCOMMON) -
         VOL(&CATVOL)
 DATASET ALLOC DSN(PAGE.Z&CLN.LOCAL1) SPACE(CYL,(150)) PARM(PGLOCAL) -
         VOL(&CATVOL)
 DATASET ALLOC DSN(PAGE.Z&CLN.LOCAL2) SPACE(CYL,(150)) PARM(PGLOCAL) -
         VOL(&CATVOL)
 DATASET ALLOC DSN(SYS1.STGINDEX) SPACE(CYL,(5)) -
         VOL(&SYSVL1)      PARM(STGINDEX)

*--------------------------------------------------------------------*
* Couple datasets.                                                   *
*--------------------------------------------------------------------*
 DATASET ALLOC DSN(SYS1.COUPLE.PLEXP) VOL(&CATVOL) PARM(XCF)
 DATASET ALLOC DSN(SYS1.COUPLE.PLEXB) VOL(&SYSVL1) PARM(XCF)
 DATASET ALLOC DSN(SYS1.COUPLE.WLMP)  VOL(&CATVOL) PARM(WLM)
 DATASET ALLOC DSN(SYS1.COUPLE.WLMB)  VOL(&SYSVL1) PARM(WLM)
 DATASET ALLOC DSN(SYS1.COUPLE.LOGRP) VOL(&CATVOL) PARM(LOGR)
 DATASET ALLOC DSN(SYS1.COUPLE.LOGRB) VOL(&SYSVL1) PARM(LOGR)

*--------------------------------------------------------------------*
*  MVS Datasets:                                                     *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(SYS1.IODF00.CLUSTER) PARM(IODF) VOL(&CATVOL)
 DATASET COPY  DSN(SYS1.DFSMS.ACDS)     PARM(ACDS) VOL(&CATVOL)
 DATASET COPY  DSN(SYS1.DFSMS.SCDS)     VOL(&CATVOL)
 DATASET COPY  DSN(SYS1.DFSMS.COMMDS)   PARM(COMMDS) VOL(&CATVOL)
 DATASET COPY  DSN(SYS1.SDWWDLPA)        PARM(LPA)
 DATASET COPY  DSN(SYS1.SIEALNKE)        PARM(APF,LNK)
 DATASET COPY  DSN(SYS1.SIEAMIGE)        PARM(APF,LNK)
 DATASET COPY  DSN(SYS1.LINKLIB)         PARM(RLSE,APF,LNK)
 DATASET COPY  DSN(SYS1.SHASLNKE)        PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SHASMIG)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.LPALIB)          PARM(RLSE)
 DATASET COPY  DSN(SYS1.MACLIB)          PARM(RLSE)
 DATASET COPY  DSN(SYS1.MIGLIB)          PARM(RLSE,APF)
 DATASET COPY  DSN(SYS1.NUCLEUS)
 DATASET COPY  DSN(SYS1.PARMLIB)         PARM(PARMLIB)
 DATASET COPY  DSN(CPAC.PARMLIB)         PARM(PARMLIB)
 DATASET COPY  DSN(CPAC.CMDPROC)         PARM(CMPDPROC)
 DATASET COPY  DSN(SYS1.IBM.PARMLIB)     PARM(PARMLIB)
 DATASET COPY  DSN(SYS1.PROCLIB)         PARM(PROCLIB)
 DATASET COPY  DSN(CPAC.PROCLIB)         PARM(PROCLIB)
 DATASET COPY  DSN(SYS1.IBM.PROCLIB)     PARM(PROCLIB)
 DATASET COPY  DSN(SYS1.SAMPLIB)         PARM(RLSE)
 DATASET COPY  DSN(SYS1.SVCLIB)          PARM(RLSE)
 DATASET COPY  DSN(SYS1.UADS)            PARM(SYSUADS) VOL(&CATVOL)
 DATASET COPY  DSN(SYS1.BRODCAST)        PARM(SYSLBC) VOL(&CATVOL)

 DATASET ALLOC DSN(SYS1.HASPCKP1)        PARM(HASPCKPT) VOL(&CATVOL) -
         MODEL(SYS1.HASPCKPT) SPACE(CYL,10)

 DATASET ALLOC DSN(SYS1.HASPCKP2)        PARM(HASPCKPT) VOL(&CATVOL) -
         MODEL(SYS1.HASPCKPT) SPACE(CYL,10)

 DATASET ALLOC DSN(SYS1.HASPACE)         PARM(HASPACE) -
         MODEL(SYS1.HASPACE)  SPACE(CYL,500) VOL(&CATVOL)

 DATASET ALLOC DSN(SYS1.LOGREC)          PARM(LOGREC) VOL(&CATVOL) -
         MODEL(SYS1.CPAC.LOGREC) SPACE(CYL,5)

 DATASET ALLOC DSN(SYS1.MAN1)  PARM(SMF) SPACE(CYL,(10)) VOL(&CATVOL)
 DATASET ALLOC DSN(SYS1.MAN2)  PARM(SMF) SPACE(CYL,(10)) VOL(&CATVOL)
 DATASET ALLOC DSN(SYS1.MAN3)  PARM(SMF) SPACE(CYL,(10)) VOL(&CATVOL)

 DATASET ALLOC DSN(SYS1.DUMP00)          PARM(DUMP) SPACE(CYL,(25)) -
         MODEL(SYS1.DUMP01) VOL(&CATVOL)

 DATASET ALLOC DSN(SYS1.DUMP01)          PARM(DUMP) SPACE(CYL,(25)) -
         MODEL(SYS1.DUMP01) VOL(&CATVOL)

 DATASET COPY  DSN(SYS1.CSSLIB)          PARM(RLSE,LNK)
 DATASET COPY  DSN(EOY.SEOYLOAD)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(EOX.SEPHLOD1)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(GIM.SGIMLMD0)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(CEE.SCEERUN)          PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(CEE.SCEERUN2)         PARM(LNK,APF)
 DATASET COPY  DSN(FFST.V120ESA.SEPWMOD2) PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(FFST.V120ESA.SEPWMOD4) PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SICELINK)        PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SORTLIB)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(IOE.SIOELMOD)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SIOALMOD)        PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(CBC.SCLBDLL)          PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SERBLINK)        PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(CEE.SCEELPA)          PARM(RLSE,LNK,APF,LPA)
 DATASET COPY  DSN(SYS1.SERBLPA)         PARM(RLSE,LPA)
 DATASET COPY  DSN(SYS1.CMDLIB)          PARM(RLSE,LNK)
 DATASET COPY  DSN(SYS1.DAE)
 DATASET COPY  DSN(SYS1.HELP)            PARM(RLSE,SYSHELP)
 DATASET COPY  DSN(SYS1.IMAGELIB)        PARM(RLSE)
 DATASET COPY  DSN(SYS1.SBDTHELP)        PARM(RLSE,SYSHELP)
 DATASET COPY  DSN(SYS1.HELPENP)         PARM(RLSE,SYSHELP)

*--------------------------------------------------------------------*
* HCD ISPF libraries                                                 *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(SYS1.SCBDHENU) PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SCBDCLST) PARM(RLSE,SYSPROC)
 DATASET COPY  DSN(SYS1.SCBDMENU) PARM(RLSE,ISPMLIB)
 DATASET COPY  DSN(SYS1.SCBDPENU) PARM(RLSE,ISPPLIB)
 DATASET COPY  DSN(SYS1.SCBDTENU) PARM(RLSE,ISPTLIB)

*--------------------------------------------------------------------*
* ISPF Libraries                                                     *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(ISP.SISPHELP) PARM(RLSE,SYSHELP)
 DATASET COPY  DSN(ISP.SISPTENU) PARM(RLSE,ISPTLIB)
 DATASET COPY  DSN(ISP.SISPSLIB) PARM(RLSE,ISPSLIB)
 DATASET COPY  DSN(ISP.SISPMENU) PARM(RLSE,ISPMLIB)
 DATASET COPY  DSN(ISP.SISPSENU) PARM(RLSE,ISPSLIB)
 DATASET COPY  DSN(ISP.SISPLOAD) PARM(RLSE,LNK,ISPLLIB)
 DATASET COPY  DSN(ISP.SISPPENU) PARM(RLSE,ISPPLIB)
 DATASET COPY  DSN(ISP.SISPCLIB) PARM(RLSE,SYSPROC)
 DATASET COPY  DSN(ISP.SISPLPA)  PARM(RLSE,LPA)

*--------------------------------------------------------------------*
* TCPIP datasets                                                     *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(TCPIP.SEZALPA) PARM(RLSE,APF,LPA)
 DATASET COPY  DSN(TCPIP.SEZALOAD) PARM(RLSE,APF,LNK)
 DATASET COPY  DSN(TCPIP.SEZALNK2) PARM(RLSE,APF,LNK)
 DATASET COPY  DSN(TCPIP.SEZATCP) PARM(RLSE)
 DATASET COPY  DSN(TCPIP.SEZAINST) PARM(LNK)
 DATASET COPY  DSN(TCPIP.HOSTS.LOCAL)

*--------------------------------------------------------------------*
* RACF DATASET AND ISPF LIBRARIES                                    *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(SYS1.RACFP1)  PARM(RACFDS) MODE(RACF) -
               SPACE(CYL,(25)) VOL(&CATVOL)
 DATASET COPY  DSN(  SYS1.HRFCLST) PARM(RLSE,SYSPROC)
 DATASET COPY  DSN(  SYS1.HRFMSG)  PARM(RLSE,ISPMLIB)
 DATASET COPY  DSN(  SYS1.HRFPANL) PARM(RLSE,ISPPLIB)
 DATASET COPY  DSN(  SYS1.HRFSKEL) PARM(RLSE,ISPSLIB)

*--------------------------------------------------------------------*
* ISMF ISPF libraries                                                *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(SYS1.DGTCLIB)   PARM(RLSE,SYSPROC)
 DATASET COPY  DSN(SYS1.DGTLLIB)   PARM(RLSE,ISPLLIB)
 DATASET COPY  DSN(SYS1.DGTMLIB)   PARM(RLSE,ISPMLIB)
 DATASET COPY  DSN(SYS1.DGTPLIB)   PARM(RLSE,ISPPLIB)
 DATASET COPY  DSN(SYS1.DGTSLIB)   PARM(RLSE,ISPSLIB)
 DATASET COPY  DSN(SYS1.DGTTLIB)   PARM(RLSE,ISPTLIB)

*--------------------------------------------------------------------*
* SDSF Datasets                                                      *
*--------------------------------------------------------------------*
 DATASET ALLOC DSN(ISF.HASPINDX) SPACE(CYL,5) MODEL(ISF.HASPINDX)
 DATASET COPY  DSN(ISF.SISFHELP)   PARM(RLSE,ISPTLIB)
 DATASET COPY  DSN(ISF.SISFMOD1)   PARM(RLSE,LNK)
 DATASET COPY  DSN(ISF.SISFLINK)   PARM(RLSE,LNK)
 DATASET COPY  DSN(ISF.SISFLOAD)   PARM(RLSE,LNK)
 DATASET COPY  DSN(ISF.SISFLPA)    PARM(RLSE,LPA)
 DATASET COPY  DSN(ISF.SISFMLIB)   PARM(RLSE,ISPMLIB)
 DATASET COPY  DSN(ISF.SISFPLIB)   PARM(RLSE,ISPPLIB)
 DATASET COPY  DSN(ISF.SISFTLIB)   PARM(RLSE,ISPTLIB)
 DATASET COPY  DSN(ISF.SISFSLIB)   PARM(RLSE,ISPSLIB)
 DATASET COPY  DSN(ISF.SISFSRC)    PARM(RLSE)
*--------------------------------------------------------------------*
* VTAM / NCP DATASETS                                                *
*--------------------------------------------------------------------*
 DATASET COPY  DSN( CPAC.VTAMLST)  PARM(VTAMLST)     VOL(&CATVOL)
 DATASET ALLOC DSN( CPAC.VTAMLIB)  SPACE(CYL,3) MODEL(SYS1.VTAMLIB)
*DATASET COPY  DSN( CPAC.VTAMLIB)  PARM(VTAMLIB,APF) VOL(&CATVOL)
 DATASET COPY  DSN( SYS1.VTAMLIB)  PARM(VTAMLIB,APF)
 DATASET COPY  DSN( SYS1.SISTCLIB) PARM(SISTCLIB,APF,RLSE)
 DATASET COPY  DSN( SYS1.SISTMAC1) PARM(RLSE)

*--------------------------------------------------------------------*
* HLASM DATASETS                                                     *
*--------------------------------------------------------------------*
 DATASET COPY  DSN( ASM.SASMMAC1 ) PARM(RLSE)        VOL(&CATVOL)
 DATASET COPY  DSN( ASM.SASMMAC2 ) PARM(RLSE)        VOL(&CATVOL)
 DATASET COPY  DSN( ASM.SASMMOD1 ) PARM(RLSE,LNK)    VOL(&CATVOL)
 DATASET COPY  DSN( ASM.SASMMOD2 ) PARM(RLSE,LNK)    VOL(&CATVOL)
 DATASET COPY  DSN( ASM.SASMPUT2 ) PARM(RLSE)        VOL(&CATVOL)
 DATASET COPY  DSN( ASM.SASMSAM1 ) PARM(RLSE)        VOL(&CATVOL)
 DATASET COPY  DSN( ASM.SASMSAM2 ) PARM(RLSE)        VOL(&CATVOL)
./ ADD NAME=@DATA2
*--------------------------------------------------------------------*
*  EXAMPLE: Build a single-volume (3390-9) zOS rescue system.        *
*--------------------------------------------------------------------*
*  Note:  Several different symbolic variables are used in the VOL() *
*         parameter below.  For this particular system build, all of *
*         the variables (e.g. &CATVOL, &SYSVL1, &SYSVL2, etc.) point *
*         to the same physical volume, as we are building a single   *
*         volume RESCUE system.  This relationship is set up in the  *
*         @PARMS member.  Setting it up this way makes it a simpler  *
*         matter to spread the datasets out over multiple volumes    *
*         if/when desired.                                           *
*         If no VOL() is coded, the first volume &VOLSER1 is used.   *
*--------------------------------------------------------------------*
*  Dataset Definitions:                                              *
*--------------------------------------------------------------------*
*  Supported verbs are:                                              *
*  DATASET                                                           *
*  MEMCOPY                                                           *
*--------------------------------------------------------------------*
*  DATASET verb:                                                     *
*     The DATASET verb is used to define datasets that are to be     *
*     created on the new system.  They are either copied or          *
*     allocated, as specified by the COPY or ALLOC suboptions resp-  *
*     ectively.                                                      *
*  DATASET COPY PARAMETERS:                                          *
*  -  PARM(parms) One or more comma separated parameters that tell   *
*     what the dataset is used for, or special attributes that it    *
*     has.  The PARM field is used by the zClone execs to identify   *
*     datasets to be coded in PROCs, PARMLIB members, and other      *
*     special handling needs (like formatting LOGREC e.g.).          *
*     - HASPACE   The dataset is a JES2 spool dataset.               *
*     - HASPCKPT  The dataset is a JES2 checkpoint dataset.          *
*     - SYSUADS   The dataset is the UADS dataset.                   *
*     - SYSLBC    The dataset is the BRODCAST dataset.               *
*     - ISPPLIB   ISPF panel lib to be added to ISPPLIB concat.      *
*     - ISPMLIB   ISPF msg lib to be added to ISPMLIB concat.        *
*     - ISPSLIB   ISPF skel lib to be added to ISSPLIB concat.       *
*     - ISPTLIB   ISPF table lib to be added to ISTPLIB concat.      *
*     - SYSPROC   Lib to be in SYSPROC concatenation.                *
*     - VTAMLST   Lib to be in VTAMLST concatenation.                *
*     - VTAMLIB   Lib to be in VTAMLIB concatenation.                *
*     - APF,LNK   Lib to be in APF list or LNKLST respectively.      *
*     - LPA       Lib to be in LPALST.                               *
*     - ACDS      Dataset is the SMS ACDS.                           *
*     - COMMDS    Dataset is the SMS COMMDS.                         *
*     - RLSE      Space should be released after copy.               *
*     - SMF       MANx VSAM file tb formatted as SMF dataset.        *
*     The following should be coded once and only once, and are used *
*     by the ZCLONE execs to build various system components.        *
*     - ZLINKLIB  Dataset is the ZCLONE utility LINKLIB.             *
*     - ZPROCLIB  Dataset is the ZCLONE utility PROCLIB.             *
*     - ZPARMLIB  Dataset is the ZCLONE utility PARMLIB.             *
*     - ZSYSPROC  Dataset is the ZCLONE utility SYSPROC (clist) lib. *
*--------------------------------------------------------------------*
*  REQUIRED - DON'T DELETE THE NEXT SET OF ENTRIES FROM HERE UNTIL   *
*     |       THE NEXT COMMENT BLOCK. THESE ARE BASIC PARTS OF THE   *
*     |       RESCUE SYSTEM BUILD PROCESS, AND THE EXEC MAY BREAK IF *
*     V       THESE STATEMENTS ARE ALTERED.                          *
*--------------------------------------------------------------------*

 DATASET ALLOC DSN(SYS1.&SYSNAME.CLIST) MODEL(SYS1.PARMLIB) -
               SPACE(CYL,(2,0,15)) PARM(ZSYSPROC,SYSPROC)

 DATASET ALLOC DSN(SYS1.Z&CLN.PARMLIB) SPACE(CYL,(1,0,15)) -
               MODEL(SYS1.PARMLIB) PARM(ZPARMLIB,PARMLIB)

 DATASET ALLOC DSN(SYS1.Z&CLN.LINKLIB) SPACE(CYL,(2,0,25)) -
               MODEL(SYS1.LINKLIB) PARM(ZLINKLIB,APF,LNK)

 DATASET ALLOC DSN(SYS1.Z&CLN.PROCLIB) SPACE(CYL,(2,0,25)) -
               MODEL(SYS1.PARMLIB) PARM(ZPROCLIB,PROCLIB)

 DATASET ALLOC DSN(SYS1.IPLPARM) SPACE(CYL,(2,0,25)) -
               MODEL(SYS1.PARMLIB) PARM(IPLPARM) VOL(&CATVOL)

 MEMCOPY IN(&IPDS) OUT(SYS1.&SYSNAME.CLIST)   M(ZISPALOC,ISPALLOC)
 MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZCOMMND,COMMND00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(COUPLE00)
 MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZIEALPA,IEALPA00)
 MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZIEFSSN,IEFSSN00)
 MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZTSOKEY,TSOKEY00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(BPXPRM00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(IEASYM00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(IEASYS00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(IGDSMS00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(JES2PARM)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(LPALST00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(MSTJCL01)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(PROGA0)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(PROGL0)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(VATLST00)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(&TSOPROC)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(JES2)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(TSO)
 MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(VTAM)
 MEMCOPY IN(&OPDS) OUT(SYS1.IPLPARM) M(LOAD00)

*--------------------------------------------------------------------*
*  END OF REQUIRED STATEMENTS.                                       *
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
* Local datasets - Assorted PDS's and members that we want.          *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(SYS2.LINKLIB) PARM(APF,LNK) VOL(&CATVOL)
 DATASET COPY  DSN(SYS2.CMDPROC) PARM(SYSPROC) VOL(&CATVOL)
 DATASET COPY  DSN(SYSJCM1.CNTL)  VOL(&CATVOL)
 DATASET COPY  DSN(SYSJCM1.EXEC)  VOL(&CATVOL)
 DATASET ALLOC DSN(SYS2.ISPPLIB) MODEL(SYS1.PARMLIB) -
         SPACE(CYL,(2,0,15)) PARM(ISPPLIB)  VOL(&CATVOL)
 DATASET COPY  DSN(SYS2.TCPIP)   VOL(&CATVOL)
 MEMCOPY IN(CPAC.CMDPROC) OUT(SYS1.&SYSNAME.CLIST)   M(@HCD)
 MEMCOPY IN(CPAC.CMDPROC) OUT(SYS1.&SYSNAME.CLIST)   M(@ISMF)
 MEMCOPY IN(SYS2.ISPPLIB) OUT(SYS2.ISPPLIB)       M(ISR@PRIM)

*--------------------------------------------------------------------*
*  OMVS Datasets:                                                    *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(OMVS.ROOT)     VOL(&HFSVOL)  MOUNT('/')
 DATASET COPY  DSN(OMVS.ETC)      VOL(&HFSVOL)  MOUNT('/etc')
*DATASET COPY  DSN(OMVS.AFOROOT)  VOL(&HFSVOL)  MOUNT('/usr/lib/ssh')
 DATASET COPY  DSN(OMVS.VAR)      VOL(&HFSVOL)  MOUNT('/var')
*DATASET COPY  DSN(OMVS.SIBMROOT) VOL(&HFSVOL)  MOUNT('/usr/lpp/pli')
 DATASET COPY  DSN(OMVS.SIGYROOT) VOL(&HFSVOL)  -
               MOUNT('/usr/lpp/cobol')

*--------------------------------------------------------------------*
*  Page and other system VSAM datasets.                              *
*--------------------------------------------------------------------*
 DATASET ALLOC DSN(PAGE.&SYSNAME.PLPA) SPACE(CYL,(150)) PARM(PGPLPA) -
         VOL(&CATVOL)
 DATASET ALLOC DSN(PAGE.&SYSNAME.COMMON) SPACE(CYL,(150)) PARM(PGCOMMON) -
         VOL(&CATVOL)
 DATASET ALLOC DSN(PAGE.&SYSNAME.LOCAL1) SPACE(CYL,(150)) PARM(PGLOCAL) -
         VOL(&CATVOL)
 DATASET ALLOC DSN(PAGE.&SYSNAME.LOCAL2) SPACE(CYL,(150)) PARM(PGLOCAL) -
         VOL(&CATVOL)
 DATASET ALLOC DSN(SYS1.&SYSNAME.STGINDEX) SPACE(CYL,(5)) -
         NEWNAME(SYS1.&SYSNAME.STGINDEX) -
         VOL(&SYSVL1) PARM(STGINDEX)

*--------------------------------------------------------------------*
* Couple datasets.                                                   *
*--------------------------------------------------------------------*
 DATASET ALLOC DSN(SYS1.COUPLE.PLEXP) VOL(&CATVOL) PARM(XCF)
 DATASET ALLOC DSN(SYS1.COUPLE.PLEXB) VOL(&SYSVL1) PARM(XCF)
 DATASET ALLOC DSN(SYS1.COUPLE.WLMP)  VOL(&CATVOL) PARM(WLM)
 DATASET ALLOC DSN(SYS1.COUPLE.WLMB)  VOL(&SYSVL1) PARM(WLM)
 DATASET ALLOC DSN(SYS1.COUPLE.LOGRP) VOL(&CATVOL) PARM(LOGR)
 DATASET ALLOC DSN(SYS1.COUPLE.LOGRB) VOL(&SYSVL1) PARM(LOGR)

*--------------------------------------------------------------------*
*  MVS Datasets:                                                     *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(SYS1.IODF00.CLUSTER) PARM(IODF) VOL(&CATVOL) -
         NEWNAME(SYS1.IODF00.CLUSTER)
 DATASET COPY  DSN(SYS1.DFSMS.ACDS)     PARM(ACDS) VOL(&CATVOL)
 DATASET COPY  DSN(SYS1.DFSMS.SCDS)     VOL(&CATVOL)
 DATASET COPY  DSN(SYS1.DFSMS.COMMDS)   PARM(COMMDS) VOL(&CATVOL)
 DATASET COPY  DSN(SYS1.SDWWDLPA)        PARM(LPA)
 DATASET COPY  DSN(SYS1.SIEALNKE)        PARM(APF,LNK)
 DATASET COPY  DSN(SYS1.SIEAMIGE)        PARM(APF,LNK)
 DATASET COPY  DSN(SYS1.LINKLIB)         PARM(RLSE,APF,LNK)
 DATASET COPY  DSN(SYS1.SHASLNKE)        PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SHASMIG)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.LPALIB)          PARM(RLSE)
 DATASET COPY  DSN(SYS1.MACLIB)          PARM(RLSE)
 DATASET COPY  DSN(SYS1.MIGLIB)          PARM(RLSE,APF)
 DATASET COPY  DSN(SYS1.NUCLEUS)
 DATASET COPY  DSN(SYS1.PARMLIB)         PARM(PARMLIB,*)
 DATASET COPY  DSN(CPAC.PARMLIB)         PARM(PARMLIB)
 DATASET COPY  DSN(CPAC.CMDPROC)         PARM(CMPDPROC)
 DATASET COPY  DSN(SYS1.IBM.PARMLIB)     PARM(PARMLIB)
 DATASET COPY  DSN(SYS1.PROCLIB)         PARM(PROCLIB)
 DATASET COPY  DSN(CPAC.PROCLIB)         PARM(PROCLIB)
 DATASET COPY  DSN(SYS1.IBM.PROCLIB)     PARM(PROCLIB)
 DATASET COPY  DSN(SYS1.SAMPLIB)         PARM(RLSE)
 DATASET COPY  DSN(SYS1.SVCLIB)          PARM(RLSE)
 DATASET COPY  DSN(SYS1.UADS)            PARM(SYSUADS) VOL(&SYSVL1)
 DATASET COPY  DSN(SYS1.BRODCAST)        PARM(SYSLBC) VOL(&SYSVL1)

 DATASET ALLOC DSN(SYS1.HASPCKP1)        PARM(HASPCKPT) VOL(&SYSVL1) -
         MODEL(SYS1.HASPCKPT) SPACE(CYL,10)

 DATASET ALLOC DSN(SYS1.HASPCKP2)        PARM(HASPCKPT) VOL(&SYSVL1) -
         MODEL(SYS1.HASPCKPT) SPACE(CYL,10)

 DATASET ALLOC DSN(SYS1.HASPACE)         PARM(HASPACE) -
         MODEL(SYS1.HASPACE)  SPACE(CYL,500) VOL(&SYSVL1)

 DATASET ALLOC DSN(SYS1.&SYSNAME.LOGREC)  PARM(LOGREC) VOL(&CATVOL) -
         MODEL(SYS1.CPAC.LOGREC) SPACE(CYL,5)

 DATASET ALLOC DSN(SYS1.&SYSNAME.MAN1) PARM(SMF) -
         SPACE(CYL,(10)) VOL(&CATVOL)
 DATASET ALLOC DSN(SYS1.&SYSNAME.MAN2) PARM(SMF) -
         SPACE(CYL,(10)) VOL(&CATVOL)
 DATASET ALLOC DSN(SYS1.&SYSNAME.MAN3) PARM(SMF) -
         SPACE(CYL,(10)) VOL(&CATVOL)

 DATASET ALLOC DSN(SYS1.&SYSNAME.DUMP00) PARM(DUMP) SPACE(CYL,(25)) -
         MODEL(SYS1.DUMP01) VOL(&CATVOL)

 DATASET ALLOC DSN(SYS1.&SYSNAME.DUMP01) PARM(DUMP) SPACE(CYL,(25)) -
         MODEL(SYS1.DUMP01) VOL(&CATVOL)

 DATASET COPY  DSN(SYS1.CSSLIB)          PARM(RLSE,LNK)
 DATASET COPY  DSN(EOY.SEOYLOAD)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(EOX.SEPHLOD1)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(GIM.SGIMLMD0)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(CEE.SCEERUN)          PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(CEE.SCEERUN2)         PARM(LNK,APF)
 DATASET COPY  DSN(FFST.V120ESA.SEPWMOD2) PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(FFST.V120ESA.SEPWMOD4) PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SICELINK)        PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SORTLIB)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(IOE.SIOELMOD)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SIOALMOD)        PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(CBC.SCLBDLL)          PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SERBLINK)        PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(CEE.SCEELPA)          PARM(RLSE,LNK,APF,LPA)
 DATASET COPY  DSN(SYS1.SERBLPA)         PARM(RLSE,LPA)
 DATASET COPY  DSN(SYS1.CMDLIB)          PARM(RLSE,LNK)
 DATASET COPY  DSN(SYS1.DAE)
 DATASET COPY  DSN(SYS1.HELP)            PARM(RLSE,SYSHELP)
 DATASET COPY  DSN(SYS1.IMAGELIB)        PARM(RLSE)
 DATASET COPY  DSN(SYS1.SBDTHELP)        PARM(RLSE,SYSHELP)
 DATASET COPY  DSN(SYS1.HELPENP)         PARM(RLSE,SYSHELP)

*--------------------------------------------------------------------*
* HCD ISPF libraries                                                 *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(SYS1.SCBDHENU) PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SCBDCLST) PARM(RLSE,SYSPROC)
 DATASET COPY  DSN(SYS1.SCBDMENU) PARM(RLSE,ISPMLIB)
 DATASET COPY  DSN(SYS1.SCBDPENU) PARM(RLSE,ISPPLIB)
 DATASET COPY  DSN(SYS1.SCBDTENU) PARM(RLSE,ISPTLIB)

*--------------------------------------------------------------------*
* ISPF Libraries                                                     *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(ISP.SISPHELP) PARM(RLSE,SYSHELP)
 DATASET COPY  DSN(ISP.SISPTENU) PARM(RLSE,ISPTLIB)
 DATASET COPY  DSN(ISP.SISPSLIB) PARM(RLSE,ISPSLIB)
 DATASET COPY  DSN(ISP.SISPMENU) PARM(RLSE,ISPMLIB)
 DATASET COPY  DSN(ISP.SISPSENU) PARM(RLSE,ISPSLIB)
 DATASET COPY  DSN(ISP.SISPLOAD) PARM(RLSE,LNK,ISPLLIB)
 DATASET COPY  DSN(ISP.SISPPENU) PARM(RLSE,ISPPLIB)
 DATASET COPY  DSN(ISP.SISPCLIB) PARM(RLSE,SYSPROC)
 DATASET COPY  DSN(ISP.SISPLPA)  PARM(RLSE,LPA)

*--------------------------------------------------------------------*
* TCPIP datasets                                                     *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(TCPIP.SEZALPA) PARM(RLSE,APF,LPA)
 DATASET COPY  DSN(TCPIP.SEZALOAD) PARM(RLSE,APF,LNK)
 DATASET COPY  DSN(TCPIP.SEZALNK2) PARM(RLSE,APF,LNK)
 DATASET COPY  DSN(TCPIP.SEZATCP) PARM(RLSE)
 DATASET COPY  DSN(TCPIP.SEZAINST) PARM(LNK)
 DATASET COPY  DSN(TCPIP.HOSTS.LOCAL)

*--------------------------------------------------------------------*
* RACF DATASET AND ISPF LIBRARIES                                    *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(SYS1.RACF)    PARM(RACFDS) MODE(RACF) -
               SPACE(CYL,(25)) VOL(&CATVOL)              -
               NEWNAME(SYS1.&SYSNAME.RACF)
 DATASET COPY  DSN(  SYS1.HRFCLST) PARM(RLSE,SYSPROC)
 DATASET COPY  DSN(  SYS1.HRFMSG)  PARM(RLSE,ISPMLIB)
 DATASET COPY  DSN(  SYS1.HRFPANL) PARM(RLSE,ISPPLIB)
 DATASET COPY  DSN(  SYS1.HRFSKEL) PARM(RLSE,ISPSLIB)

*--------------------------------------------------------------------*
* ISMF ISPF libraries                                                *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(SYS1.DGTCLIB)   PARM(RLSE,SYSPROC)
 DATASET COPY  DSN(SYS1.DGTLLIB)   PARM(RLSE,ISPLLIB)
 DATASET COPY  DSN(SYS1.DGTMLIB)   PARM(RLSE,ISPMLIB)
 DATASET COPY  DSN(SYS1.DGTPLIB)   PARM(RLSE,ISPPLIB)
 DATASET COPY  DSN(SYS1.DGTSLIB)   PARM(RLSE,ISPSLIB)
 DATASET COPY  DSN(SYS1.DGTTLIB)   PARM(RLSE,ISPTLIB)

*--------------------------------------------------------------------*
* SDSF Datasets                                                      *
*--------------------------------------------------------------------*
 DATASET ALLOC DSN(ISF.HASPINDX) SPACE(CYL,5) MODEL(ISF.HASPINDX)
 DATASET COPY  DSN(ISF.SISFHELP)   PARM(RLSE,ISPTLIB)
 DATASET COPY  DSN(ISF.SISFMOD1)   PARM(RLSE,LNK)
 DATASET COPY  DSN(ISF.SISFLINK)   PARM(RLSE,LNK)
 DATASET COPY  DSN(ISF.SISFLOAD)   PARM(RLSE,LNK)
 DATASET COPY  DSN(ISF.SISFLPA)    PARM(RLSE,LPA)
 DATASET COPY  DSN(ISF.SISFMLIB)   PARM(RLSE,ISPMLIB)
 DATASET COPY  DSN(ISF.SISFPLIB)   PARM(RLSE,ISPPLIB)
 DATASET COPY  DSN(ISF.SISFTLIB)   PARM(RLSE,ISPTLIB)
 DATASET COPY  DSN(ISF.SISFSLIB)   PARM(RLSE,ISPSLIB)
 DATASET COPY  DSN(ISF.SISFSRC)    PARM(RLSE)
*--------------------------------------------------------------------*
* VTAM / NCP DATASETS                                                *
*--------------------------------------------------------------------*
 DATASET COPY  DSN( CPAC.VTAMLST)  PARM(VTAMLST)     VOL(&CATVOL)
 DATASET ALLOC DSN( CPAC.VTAMLIB)  SPACE(CYL,3) MODEL(SYS1.VTAMLIB)
*DATASET COPY  DSN( CPAC.VTAMLIB)  PARM(VTAMLIB,APF) VOL(&CATVOL)
 DATASET COPY  DSN( SYS1.VTAMLIB)  PARM(VTAMLIB,APF)
 DATASET COPY  DSN( SYS1.SISTCLIB) PARM(SISTCLIB,APF,RLSE)
 DATASET COPY  DSN( SYS1.SISTMAC1) PARM(RLSE)

*--------------------------------------------------------------------*
* HLASM DATASETS                                                     *
*--------------------------------------------------------------------*
 DATASET COPY  DSN( ASM.SASMMAC1 ) PARM(RLSE)        VOL(&CATVOL)
 DATASET COPY  DSN( ASM.SASMMAC2 ) PARM(RLSE)        VOL(&CATVOL)
 DATASET COPY  DSN( ASM.SASMMOD1 ) PARM(RLSE,LNK)    VOL(&CATVOL)
 DATASET COPY  DSN( ASM.SASMMOD2 ) PARM(RLSE,LNK)    VOL(&CATVOL)
 DATASET COPY  DSN( ASM.SASMPUT2 ) PARM(RLSE)        VOL(&CATVOL)
 DATASET COPY  DSN( ASM.SASMSAM1 ) PARM(RLSE)        VOL(&CATVOL)
 DATASET COPY  DSN( ASM.SASMSAM2 ) PARM(RLSE)        VOL(&CATVOL)
./ ADD NAME=@DATA3   0108-10016-10018-2021-00296-00283-00000-COMPJM
*--------------------------------------------------------------------*
*  EXAMPLE: Build a single-volume (3390-9) zOS rescue system.        *
*--------------------------------------------------------------------*
*  Note:  Several different symbolic variables are used in the VOL() *
*         parameter below.  For this particular system build, all of *
*         the variables (e.g. &CATVOL, &SYSVL1, &SYSVL2, etc.) point *
*         to the same physical volume, as we are building a single   *
*         volume RESCUE system.  This relationship is set up in the  *
*         @PARMS member.  Setting it up this way makes it a simpler  *
*         matter to spread the datasets out over multiple volumes    *
*         if/when desired.                                           *
*         If no VOL() is coded, the first volume &VOLSER1 is used.   *
*--------------------------------------------------------------------*
*  Dataset Definitions:                                              *
*--------------------------------------------------------------------*
*  Supported verbs are:                                              *
*  DATASET                                                           *
*  MEMCOPY                                                           *
*--------------------------------------------------------------------*
*  DATASET verb:                                                     *
*     The DATASET verb is used to define datasets that are to be     *
*     created on the new system.  They are either copied or          *
*     allocated, as specified by the COPY or ALLOC suboptions resp-  *
*     ectively.                                                      *
*  DATASET COPY PARAMETERS:                                          *
*  -  PARM(parms) One or more comma separated parameters that tell   *
*     what the dataset is used for, or special attributes that it    *
*     has.  The PARM field is used by the zClone execs to identify   *
*     datasets to be coded in PROCs, PARMLIB members, and other      *
*     special handling needs (like formatting LOGREC e.g.).          *
*     - HASPACE   The dataset is a JES2 spool dataset.               *
*     - HASPCKPT  The dataset is a JES2 checkpoint dataset.          *
*     - SYSUADS   The dataset is the UADS dataset.                   *
*     - SYSLBC    The dataset is the BRODCAST dataset.               *
*     - ISPPLIB   ISPF panel lib to be added to ISPPLIB concat.      *
*     - ISPMLIB   ISPF msg lib to be added to ISPMLIB concat.        *
*     - ISPSLIB   ISPF skel lib to be added to ISSPLIB concat.       *
*     - ISPTLIB   ISPF table lib to be added to ISTPLIB concat.      *
*     - SYSPROC   Lib to be in SYSPROC concatenation.                *
*     - VTAMLST   Lib to be in VTAMLST concatenation.                *
*     - VTAMLIB   Lib to be in VTAMLIB concatenation.                *
*     - APF,LNK   Lib to be in APF list or LNKLST respectively.      *
*     - LPA       Lib to be in LPALST.                               *
*     - ACDS      Dataset is the SMS ACDS.                           *
*     - COMMDS    Dataset is the SMS COMMDS.                         *
*     - RLSE      Space should be released after copy.               *
*     - SMF       MANx VSAM file tb formatted as SMF dataset.        *
*     - ******    Catalog this dataset on IPL volume.                *
*     - *         Same as "******"                                   *
*     The following should be coded once and only once, and are used *
*     by the ZCLONE execs to build various system components.        *
*     - ZLINKLIB  Dataset is the ZCLONE utility LINKLIB.             *
*     - ZPROCLIB  Dataset is the ZCLONE utility PROCLIB.             *
*     - ZPARMLIB  Dataset is the ZCLONE utility PARMLIB.             *
*     - ZSYSPROC  Dataset is the ZCLONE utility SYSPROC (clist) lib. *
*--------------------------------------------------------------------*

 DATASET ALLOC DSN(SYS1.IPLPARM) SPACE(CYL,(2,0,25)) -
               MODEL(SYS1.PARMLIB) PARM(IPLPARM) VOL(&CATVOL)

 DATASET ALLOC DSN(SYS1.Z&CLN.CLIST) MODEL(SYS1.PARMLIB) -
               SPACE(CYL,(2,0,15)) PARM(ZSYSPROC,SYSPROC)

 DATASET ALLOC DSN(SYS1.Z&CLN.LINKLIB) SPACE(CYL,(2,0,25)) -
               MODEL(SYS1.LINKLIB) PARM(ZLINKLIB,APF,LNK)

 DATASET ALLOC DSN(SYS1.Z&CLN.PROCLIB) SPACE(CYL,(2,0,25)) -
               MODEL(SYS1.PARMLIB) PARM(ZPROCLIB,PROCLIB)

 MEMCOPY IN(&OPDS) OUT(SYS1.PARMLIB) M(PROGA0)
 MEMCOPY IN(&OPDS) OUT(SYS1.PARMLIB) M(PROGL0)
 MEMCOPY IN(&OPDS) OUT(SYS1.PROCLIB) M(VTAM)
 MEMCOPY IN(SYS2.MVSIMAGE) OUT(SYS1.PARMLIB) M(IEASYM00)
 MEMCOPY IN(&IPDS)         OUT(SYS1.PARMLIB) M(ZCOMMND,COMMND00)
 MEMCOPY IN(&OPDS)         OUT(SYS1.PARMLIB) M(IEASYM00)
 MEMCOPY IN(&OPDS)         OUT(SYS1.PROCLIB) M(JES2)
 MEMCOPY IN(&OPDS)         OUT(SYS1.IPLPARM) M(LOAD00)
 MEMCOPY IN(&IPDS)         OUT(SYS2.CMDPROC) M(ZISPALOC,ISPALLOC)
 MEMCOPY IN(&OPDS)         OUT(SYS1.PARMLIB) M(JES2PARM)
*MEMCOPY IN(SYS2.MVSIMAGE) OUT(SYS1.PARMLIB) M(SMFPRM00)

*--------------------------------------------------------------------*
*  END OF REQUIRED STATEMENTS.                                       *
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
* Local datasets - Assorted PDS's and members that we want.          *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(SYS2.LINKLIB) PARM(APF,LNK) VOL(&CATVOL)
 DATASET COPY  DSN(SYS2.CMDPROC) PARM(SYSPROC) VOL(&CATVOL)
 DATASET COPY  DSN(SYS2.ISPPLIB) PARM(SYSPROC) VOL(&CATVOL)
*DATASET COPY  DSN(SYSJCM1.CNTL)  VOL(&CATVOL)
*DATASET COPY  DSN(SYSJCM1.EXEC)  VOL(&CATVOL)
*
*DATASET COPY  DSN(SYS2.PROD1.TCPIP)     VOL(&CATVOL)
*DATASET COPY  DSN(SYS2.PROD2.TCPIP)     VOL(&CATVOL)
*DATASET COPY  DSN(SYS2.SYSTEMS.TCPIP)   VOL(&CATVOL)
*DATASET COPY  DSN(SYS2.TEST.TCPIP)      VOL(&CATVOL)
*
*DATASET COPY  DSN(SYS2.PROD1.PROCLIB)   VOL(&CATVOL)
*DATASET COPY  DSN(SYS2.PROD2.PROCLIB)   VOL(&CATVOL)
*DATASET COPY  DSN(SYS2.SYSTEMS.PROCLIB) VOL(&CATVOL)
*DATASET COPY  DSN(SYS2.TEST.PROCLIB)    VOL(&CATVOL)

*--------------------------------------------------------------------*
*  OMVS Datasets:                                                    *
*--------------------------------------------------------------------*
*DATASET COPY  DSN(OMVS.ROOT)     VOL(&HFSVOL)  MOUNT('/')
*DATASET COPY  DSN(OMVS.ETC)      VOL(&HFSVOL)  MOUNT('/etc')
*DATASET COPY  DSN(OMVS.VAR)      VOL(&HFSVOL)  MOUNT('/var')
*DATASET COPY  DSN(OMVS.SIGYROOT) VOL(&HFSVOL)  -
               MOUNT('/usr/lpp/cobol')

*--------------------------------------------------------------------*
*  Page and other system VSAM datasets.                              *
*--------------------------------------------------------------------*
*DATASET ALLOC DSN(PAGE.&SYSNAME.PLPA) SPACE(CYL,(150)) PARM(PGPLPA) -
*        VOL(PAGE01)
*DATASET ALLOC DSN(PAGE.&SYSNAME.COMMON) SPACE(CYL,(150)) -
*        PARM(PGCOMMON) VOL(PAGE01)
*DATASET ALLOC DSN(PAGE.&SYSNAME.LOCAL1) SPACE(CYL,(150)) -
*        PARM(PGLOCAL) VOL(PAGE02)
*DATASET ALLOC DSN(PAGE.&SYSNAME.LOCAL2) SPACE(CYL,(150)) -
*        PARM(PGLOCAL) VOL(PAGE02)
*DATASET ALLOC DSN(SYS1.&SYSNAME.STGINDEX) SPACE(CYL,(5)) -
*        NEWNAME(SYS1.&SYSNAME.STGINDEX) -
*        VOL(&CATVOL) PARM(STGINDEX)
*
*--------------------------------------------------------------------*
* Couple datasets.                                                   *
*--------------------------------------------------------------------*
*DATASET ALLOC DSN(SYS1.COUPLE.PLEXP) VOL(&CATVOL) PARM(XCF)
*DATASET ALLOC DSN(SYS1.COUPLE.PLEXB) VOL(&SYSVL1) PARM(XCF)
*DATASET ALLOC DSN(SYS1.COUPLE.WLMP)  VOL(&CATVOL) PARM(WLM)
*DATASET ALLOC DSN(SYS1.COUPLE.WLMB)  VOL(&SYSVL1) PARM(WLM)
*DATASET ALLOC DSN(SYS1.COUPLE.LOGRP) VOL(&CATVOL) PARM(LOGR)
*DATASET ALLOC DSN(SYS1.COUPLE.LOGRB) VOL(&SYSVL1) PARM(LOGR)

*--------------------------------------------------------------------*
*  MVS Datasets:                                                     *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(SYS1.CICSTS32.CPSM.SEYULPA)  PARM(LPA)
 DATASET COPY  DSN(SYS1.CICSTS32.CICS.SDFHLPA)  PARM(LPA)

 DATASET COPY  DSN(SYS1.IODF00.CLUSTER) PARM(IODF) VOL(&CATVOL) -
         NEWNAME(SYS1.IODF00.CLUSTER)
 DATASET COPY  DSN(SYS1.DBBLIB)          VOL(&SYSVL1)
 DATASET COPY  DSN(SYS1.SDWWDLPA)        PARM(LPA)
 DATASET COPY  DSN(SYS1.SIEALNKE)        PARM(APF,LNK)
 DATASET COPY  DSN(SYS1.SIEAMIGE)        PARM(APF,LNK)
 DATASET COPY  DSN(SYS1.LINKLIB)         PARM(RLSE,APF,LNK)
 DATASET COPY  DSN(SYS1.SHASLNKE)        PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SHASMIG)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.LPALIB)          PARM(RLSE)
 DATASET COPY  DSN(SYS1.MACLIB)          PARM(RLSE)
 DATASET COPY  DSN(SYS1.MIGLIB)          PARM(RLSE,APF)
 DATASET COPY  DSN(SYS1.NUCLEUS)
 DATASET COPY  DSN(SYS1.PARMLIB)  PARM(PARMLIB,ZPARMLIB)   VOL(&CATVOL)
 DATASET COPY  DSN(CPAC.PARMLIB)         PARM(PARMLIB)
 DATASET COPY  DSN(CPAC.CMDPROC)         PARM(CMPDPROC)
 DATASET COPY  DSN(SYS1.IBM.PARMLIB)     PARM(PARMLIB) VOL(&SYSVL1)
 DATASET COPY  DSN(SYS1.PROCLIB)         PARM(PROCLIB) VOL(&CATVOL)
 DATASET COPY  DSN(CPAC.PROCLIB)         PARM(PROCLIB) VOL(&SYSVL1)
 DATASET COPY  DSN(SYS1.IBM.PROCLIB)     PARM(PROCLIB) VOL(&SYSVL1)
 DATASET COPY  DSN(SYS1.SAMPLIB)         PARM(RLSE)
 DATASET COPY  DSN(SYS1.SVCLIB)          PARM(RLSE)
 DATASET COPY  DSN(SYS1.UADS)            PARM(SYSUADS) VOL(&SYSVL1)
 DATASET COPY  DSN(SYS1.BRODCAST)        PARM(SYSLBC) VOL(&SYSVL1)

 DATASET ALLOC DSN(SYS1.HASPCKP1)        PARM(HASPCKPT) VOL(&CATVOL) -
         MODEL(SYS1.HASPCKPT) SPACE(CYL,15)

 DATASET ALLOC DSN(SYS1.HASPCKP2)        PARM(HASPCKPT) VOL(&CATVOL) -
         MODEL(SYS1.HASPCKPT) SPACE(CYL,10)

 DATASET ALLOC DSN(SYS1.HASPACE)         PARM(HASPACE) -
         MODEL(SYS1.HASPACE)  SPACE(CYL,500) VOL(&CATVOL)

*DATASET ALLOC DSN(SYS1.&SYSNAME.LOGREC)  PARM(LOGREC) VOL(&CATVOL) -
*        MODEL(SYS1.CPAC.LOGREC) SPACE(CYL,5)
*
*DATASET ALLOC DSN(SYS1.&SYSNAME.MAN1) PARM(SMF) -
*        SPACE(CYL,(10)) VOL(&CATVOL)
*DATASET ALLOC DSN(SYS1.&SYSNAME.MAN2) PARM(SMF) -
*        SPACE(CYL,(10)) VOL(&CATVOL)
*DATASET ALLOC DSN(SYS1.&SYSNAME.MAN3) PARM(SMF) -
*        SPACE(CYL,(10)) VOL(&CATVOL)
*
 DATASET COPY  DSN(SYS1.CSSLIB)          PARM(RLSE,LNK)
 DATASET COPY  DSN(EOY.SEOYLOAD)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(EOX.SEPHLOD1)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(GIM.SGIMLMD0)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(CEE.SCEERUN)          PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(CEE.SCEERUN2)         PARM(LNK,APF)
 DATASET COPY  DSN(FFST.V120ESA.SEPWMOD2) PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(FFST.V120ESA.SEPWMOD4) PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SICELINK)        PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SORTLIB)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(IOE.SIOELMOD)         PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SIOALMOD)        PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(CBC.SCLBDLL)          PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SERBLINK)        PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(CEE.SCEELPA)          PARM(RLSE,LNK,APF,LPA)
 DATASET COPY  DSN(SYS1.SERBLPA)         PARM(RLSE,LPA)
 DATASET COPY  DSN(SYS1.CMDLIB)          PARM(RLSE,LNK)
 DATASET COPY  DSN(SYS1.DAE)
 DATASET COPY  DSN(SYS1.HELP)            PARM(RLSE,SYSHELP)
 DATASET COPY  DSN(SYS1.IMAGELIB)        PARM(RLSE)
 DATASET COPY  DSN(SYS1.SBDTHELP)        PARM(RLSE,SYSHELP)
 DATASET COPY  DSN(SYS1.HELPENP)         PARM(RLSE,SYSHELP)

*--------------------------------------------------------------------*
* HCD ISPF libraries                                                 *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(SYS1.SCBDHENU) PARM(RLSE,LNK,APF)
 DATASET COPY  DSN(SYS1.SCBDCLST) PARM(RLSE,SYSPROC)
 DATASET COPY  DSN(SYS1.SCBDMENU) PARM(RLSE,ISPMLIB)
 DATASET COPY  DSN(SYS1.SCBDPENU) PARM(RLSE,ISPPLIB)
 DATASET COPY  DSN(SYS1.SCBDTENU) PARM(RLSE,ISPTLIB)

*--------------------------------------------------------------------*
* ISPF Libraries                                                     *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(ISP.SISPHELP) PARM(RLSE,SYSHELP)
 DATASET COPY  DSN(ISP.SISPTENU) PARM(RLSE,ISPTLIB)
 DATASET COPY  DSN(ISP.SISPSLIB) PARM(RLSE,ISPSLIB)
 DATASET COPY  DSN(ISP.SISPMENU) PARM(RLSE,ISPMLIB)
 DATASET COPY  DSN(ISP.SISPSENU) PARM(RLSE,ISPSLIB)
 DATASET COPY  DSN(ISP.SISPLOAD) PARM(RLSE,LNK,ISPLLIB)
 DATASET COPY  DSN(ISP.SISPPENU) PARM(RLSE,ISPPLIB)
 DATASET COPY  DSN(ISP.SISPCLIB) PARM(RLSE,SYSPROC)
 DATASET COPY  DSN(ISP.SISPLPA)  PARM(RLSE,LPA)

*--------------------------------------------------------------------*
* TCPIP datasets                                                     *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(TCPIP.SEZALPA) PARM(RLSE,APF,LPA)
 DATASET COPY  DSN(TCPIP.SEZALOAD) PARM(RLSE,APF,LNK)
 DATASET COPY  DSN(TCPIP.SEZALNK2) PARM(RLSE,APF,LNK)
 DATASET COPY  DSN(TCPIP.SEZATCP) PARM(RLSE)
 DATASET COPY  DSN(TCPIP.SEZAINST) PARM(LNK)
 DATASET COPY  DSN(TCPIP.HOSTS.LOCAL)

*--------------------------------------------------------------------*
* RACF DATASET AND ISPF LIBRARIES                                    *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(SYS1.RACFP1)  PARM(RACFDS) MODE(RACF) -
               SPACE(CYL,(25)) VOL(&CATVOL)
 DATASET COPY  DSN(  SYS1.HRFCLST) PARM(RLSE,SYSPROC)
 DATASET COPY  DSN(  SYS1.HRFMSG)  PARM(RLSE,ISPMLIB)
 DATASET COPY  DSN(  SYS1.HRFPANL) PARM(RLSE,ISPPLIB)
 DATASET COPY  DSN(  SYS1.HRFSKEL) PARM(RLSE,ISPSLIB)

*--------------------------------------------------------------------*
* ISMF ISPF libraries                                                *
*--------------------------------------------------------------------*
 DATASET COPY  DSN(SYS1.DGTCLIB)   PARM(RLSE,SYSPROC)
 DATASET COPY  DSN(SYS1.DGTLLIB)   PARM(RLSE,ISPLLIB)
 DATASET COPY  DSN(SYS1.DGTMLIB)   PARM(RLSE,ISPMLIB)
 DATASET COPY  DSN(SYS1.DGTPLIB)   PARM(RLSE,ISPPLIB)
 DATASET COPY  DSN(SYS1.DGTSLIB)   PARM(RLSE,ISPSLIB)
 DATASET COPY  DSN(SYS1.DGTTLIB)   PARM(RLSE,ISPTLIB)

*--------------------------------------------------------------------*
* SDSF Datasets                                                      *
*--------------------------------------------------------------------*
 DATASET ALLOC DSN(ISF.HASPINDX) SPACE(CYL,5) MODEL(ISF.HASPINDX)
 DATASET COPY  DSN(ISF.SISFHELP)   PARM(RLSE,ISPTLIB)
 DATASET COPY  DSN(ISF.SISFMOD1)   PARM(RLSE,LNK)
 DATASET COPY  DSN(ISF.SISFLINK)   PARM(RLSE,LNK)
 DATASET COPY  DSN(ISF.SISFLOAD)   PARM(RLSE,LNK)
 DATASET COPY  DSN(ISF.SISFLPA)    PARM(RLSE,LPA)
 DATASET COPY  DSN(ISF.SISFMLIB)   PARM(RLSE,ISPMLIB)
 DATASET COPY  DSN(ISF.SISFPLIB)   PARM(RLSE,ISPPLIB)
 DATASET COPY  DSN(ISF.SISFTLIB)   PARM(RLSE,ISPTLIB)
 DATASET COPY  DSN(ISF.SISFSLIB)   PARM(RLSE,ISPSLIB)
 DATASET COPY  DSN(ISF.SISFSRC)    PARM(RLSE)
*--------------------------------------------------------------------*
* VTAM / NCP DATASETS                                                *
*--------------------------------------------------------------------*
 DATASET COPY  DSN( CPAC.VTAMLST)  PARM(VTAMLST)     VOL(&CATVOL)
 DATASET ALLOC DSN( CPAC.VTAMLIB)  SPACE(CYL,3) MODEL(SYS1.VTAMLIB)
 DATASET COPY  DSN( SYS1.VTAMLIB)  PARM(VTAMLIB,APF)
 DATASET COPY  DSN( SYS1.SISTCLIB) PARM(SISTCLIB,APF,RLSE)
 DATASET COPY  DSN( SYS1.SISTMAC1) PARM(RLSE)

*--------------------------------------------------------------------*
* HLASM DATASETS                                                     *
*--------------------------------------------------------------------*
 DATASET COPY  DSN( ASM.SASMMAC1 ) PARM(RLSE)        VOL(&SYSVL1)
 DATASET COPY  DSN( ASM.SASMMAC2 ) PARM(RLSE)        VOL(&SYSVL1)
 DATASET COPY  DSN( ASM.SASMMOD1 ) PARM(RLSE,LNK)    VOL(&SYSVL1)
 DATASET COPY  DSN( ASM.SASMMOD2 ) PARM(RLSE,LNK)    VOL(&SYSVL1)
 DATASET COPY  DSN( ASM.SASMPUT2 ) PARM(RLSE)        VOL(&SYSVL1)
 DATASET COPY  DSN( ASM.SASMSAM1 ) PARM(RLSE)        VOL(&SYSVL1)
 DATASET COPY  DSN( ASM.SASMSAM2 ) PARM(RLSE)        VOL(&SYSVL1)
./ ADD NAME=@PARMS
*-------------------------------------------------------------------*
*  ZCLONE system parameters.                                        *
*  To assign parms, use statements like: PARM1  = Some Value        *
*-------------------------------------------------------------------*
*  03/10/2007 John C. Miller.                                       *
*-------------------------------------------------------------------*
 CLN        = 210       /* My locally defined variable (JCM).
 SYSPLEX    = HRCPLEX   /* For couple dataset definition.

*-------------------------------------------------------------------*
* Jobcard info.  "COMMENT" is placed in each job.                   *
* Jobname must be 7 chars or less to allow job char to be added.    *
*-------------------------------------------------------------------*
 JOBCARD1   = //COMPJM  JOB (990030,135,60,100),JMILLER,CLASS=A,
 JOBCARD2   = //   NOTIFY=COMPJM,MSGCLASS=X,REGION=6M
 JOBCARD3   = /*JOBPARM LINES=999999
 COMMENT    = John C. Miller

 @DATASET   = @DATASET   /* Contains dataset definitions.  If omitted,
                         /* defaults to @DATASET.

*-------------------------------------------------------------------*
* USESYM = YES means that indirect volume addressing will be used   *
* for NONVSAM datasets. &SYSR2-&SYSRn will be defined.              *
*-------------------------------------------------------------------*
 USESYM     = NO                     /* Use indirect volsers.
 VALIDPARMS = YES                    /* Don't validate parms.

*-------------------------------------------------------------------*
* TSO PROC and Userids to be created on the new system.             *
* TSOPROC should NOT exist on the driving system.  As many TSO ids  *
* as desired can be specified here.                                 *
*-------------------------------------------------------------------*
 TSOPROC    = TSOSYS                  /* TSOPROC to be built.
 TSOID1     = COMPJM                  /* TSO IDs to be defined on the
 TSOID2     = COMPJM2                 /* rescue system.
 TSOID3     =

*-------------------------------------------------------------------*
* Volume parameters.  You must specify at least VOLSER1 and ADDR1.  *
* If you need more space, then specify VOLSER2 & ADDR2 for a second *
* volume, and VOLSER3 & ADDR3 for a third volume, etc.  As many     *
* volumes as desired can be specified here, but there must be an    *
* ADDRn entry for each VOLSERn entry.                               *
* Note:  System symbols will be defined for each volume beyond      *
* VOLSER1.  &SYSR2 - &SYSRn will be defined for VOLSER2 and higher, *
* but only if USESYM = YES in this member.                          *
*-------------------------------------------------------------------*
 DEVTYPE    = 3390                    /* Unit of RESCUE volume.
 ADDR1      = 914A                    /* Unit addr of volume.
 VOLSER1    = ZOS&CLN                 /* VOLSER.

* Optional volume aliases *
 SYSVL1     = &VOLSER1                /* Volume alias.
 SYSVL2     = &VOLSER1                /* Volume alias.
 HFSVOL     = &VOLSER1                /* Volume alias.
 CATVOL     = &VOLSER1                /* Volume alias.
 PAGVL1     = &VOLSER1                /* Volume alias.
 PAGVL2     = &VOLSER1                /* Volume alias.

*-------------------------------------------------------------------*
* WORKVOL - Not needed if you have plenty of PUBLIC mounted disk.   *
* No data is permanently left on this volume.                       *
*-------------------------------------------------------------------*
 WORKVOL    = Z10001                  /* Volser for large work files.

*-------------------------------------------------------------------*
* IOCONFIGID - Use HCD to be sure this value is defined as a valid  *
* IOCONFIG ID in the IODF dataset that you specify.  This value is  *
* inserted in the SYS1.IPLPARM(LOADxx) member.                      *
*-------------------------------------------------------------------*
 IOCONFIGID = UCRPROD                 /* 8 char IO config ID for LOADxx
 SMFID      = Z&CLN                   /* 4 char SMF id for new system.

*-------------------------------------------------------------------*
* Catalog related parms.                                            *
*-------------------------------------------------------------------*
 OLDMCAT    = CATALOG.Z10.MASTER      /* Driving sys master cat.
 NEWMCAT    = CATALOG.Z10.MST&CLN     /* New sys. mastercat name.
 NEWMCATVOL = &CATVOL                 /* New sys. mastercat vol.
 NEWUCAT    = CATALOG.Z10.SYS&CLN     /* New sys. usercat name.
 NEWUCATVOL = &CATVOL                 /* New sys. usercat vol.
 UCATALIAS1 = SMS
 UCATALIAS2 = &TSOID1
 UCATALIAS2 = &TSOID2
 UCATALIAS2 = &TSOID3
 SSA        = SYSZC.                  /* Temp. dsn prefix used to
 SSAU       = SYSUC.                  /* avoid ENQ problems. SSAU is

 SYSRES     = Z10RES                  /* Driving sys sysres volume.
 COMMANDPGM = COMMAND                 /* "COMMAND" pgm is available.
 WAITPGM    = WAIT                    /* "WAIT" pgm is available.

*-------------------------------------------------------------------*
* JES2 Parms.  A SPOOLDEF and CKPTDEF entry will be added to the    *
* ZJES2PRM member to create a final JES2PARM member.  You must      *
* define a SPOOL and at least one CKPT dataset in the @DATASET      *
* member.  The CKPT dataset(s) should have the parm of HASPCKPT,    *
* and the spool dataset should have the parm HASPACE.               *
* SPOOLPRF is the length of the SPOOLDEF VOLUME= parm.  If it is    *
* set to 4, for example, and the volser where the spool dataset is  *
* allocated is RESCUE, then the SPOOLDEF VOLUME=RESC is coded.      *
*-------------------------------------------------------------------*
 SPOOLPRF   = 5                       /* Length of SPOOLDEF prefix.

*-------------------------------------------------------------------*
* RACF Parms.                                                       *
* Note: Some of the RACF actions require RACF SPECIAL to perform.   *
* Any TSO ID can run the RESCUE execs, but the RACF ID used to run  *
* the resulting jobs will need RACF SPECIAL, or specific privileges *
* for various RACF operations (CLAUTH, etc.)                        *
*-------------------------------------------------------------------*
*-------------------------------------------------------------------*
* RFSTCx: Defines STCs for ICHRIN03 started task table.             *
* p1 = Task name, p2 = RACF ID, p3 = RACF group.                    *
* Each task defined will have privileged bit set on, so these tasks *
* should be able to bypass most RACF Access checking.  Commands     *
* for creating the specified IDs and Groups will be generated only  *
* if the IDs/groups DO NOT already exist.                           *
*-------------------------------------------------------------------*
 RFDSNT     = YES                     /* Create RACF ICHRDSNT
 RFSTC      = NO                      /* Create RACF ICHRIN03
 RFTSOPROC  = YES                     /* Define TSOPROC to TSOPROC class

*-------------------------------------------------------------------*
* Started task support:                                             *
* If entries are defined below, then an ICHRIN03 module will be     *
* built with these entries.  An MLPA entry for this ICHRIN03        *
* will be placed in IEALPA00.  Format of RFSTCx is:                 *
* RFSTCx = stcname, racfid, racfgrp  All three parms are required.  *
* This option may be most useful when building a single pack rescue *
* system.  If your RACF dataset already has STARTED class profiles  *
* for the started tasks listed below, then you don't need an STC.   *
*-------------------------------------------------------------------*
*RFSTC1     = RACF,    $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC2     = JES2,    $RESCUE, $STC  /* STCs to go in ICHRIN03
**FSTC3     = VTAM,    $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC4     = TSO,     $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC5     = TCPIP,   $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC6     = OMVS,    $RESCUE, $STC  /* STCs to go in ICHRIN03
./ ADD NAME=@PARM2
*-------------------------------------------------------------------*
*  ZCLONE system parameters.                                        *
*  To assign parms, use statements like: PARM1  = Some Value        *
*-------------------------------------------------------------------*
*  03/10/2007 John C. Miller.                                       *
*-------------------------------------------------------------------*
 CLN        = R01       /* My locally defined variable (JCM).
 SYSPLEX    = HRCPLEX   /* For couple dataset definition.
 SYSNAME    = TEST      /* For LPAR specific dsns.

*-------------------------------------------------------------------*
* Jobcard info.  "COMMENT" is placed in each job.                   *
* Jobname must be 7 chars or less to allow job char to be added.    *
*-------------------------------------------------------------------*
 JOBCARD1   = //SYSJCM1 JOB (990030,135,60,100),JMILLER,CLASS=A,
 JOBCARD2   = //   NOTIFY=SYSJCM1,MSGCLASS=X,REGION=6M
 JOBCARD3   = /*JOBPARM LINES=999999
 COMMENT    = John C. Miller

 @DATASET   = @DATA2     /* Contains dataset definitions.  If omitted,
                         /* defaults to @DATASET.

*-------------------------------------------------------------------*
* USESYM = YES means that indirect volume addressing will be used   *
* for NONVSAM datasets. &SYSR2-&SYSRn will be defined.              *
*-------------------------------------------------------------------*
 USESYM     = YES                    /* Use indirect volsers.
 VALIDPARMS = YES                    /* Don't validate parms.

*-------------------------------------------------------------------*
* TSO PROC and Userids to be created on the new system.             *
* TSOPROC should NOT exist on the driving system.  As many TSO ids  *
* as desired can be specified here.                                 *
*-------------------------------------------------------------------*
 TSOPROC    = TSOSYS                  /* TSOPROC to be built.
 TSOID1     = COMPJM                  /* TSO IDs to be defined on the
 TSOID2     = COMPJM2                 /* rescue system.
 TSOID3     =

*-------------------------------------------------------------------*
* Volume parameters.  You must specify at least VOLSER1 and ADDR1.  *
* If you need more space, then specify VOLSER2 & ADDR2 for a second *
* volume, and VOLSER3 & ADDR3 for a third volume, etc.  As many     *
* volumes as desired can be specified here, but there must be an    *
* ADDRn entry for each VOLSERn entry.                               *
* Note:  System symbols will be defined for each volume beyond      *
* VOLSER1.  &SYSR2 - &SYSRn will be defined for VOLSER2 and higher, *
* but only if USESYM = YES in this member.                          *
*-------------------------------------------------------------------*
 DEVTYPE    = 3390                    /* Unit of RESCUE volume.
 ADDR1      = 0271                    /* UNIT ADDR OF VOLUME.
 VOLSER1    = ZOSRS1                  /* VOLSER.
 ADDR2      = 0270                    /* UNIT ADDR OF VOLUME.
 VOLSER2    = ZOSCAT                  /* VOLSER.

* Optional volume aliases *
 SYSVL1     = &VOLSER1                /* Volume alias.
 SYSVL2     = &VOLSER1                /* Volume alias.
 HFSVOL     = &VOLSER1                /* Volume alias.
 CATVOL     = ZOSCAT                  /* Volume alias.
 PAGVL1     = &VOLSER1                /* Volume alias.
 PAGVL2     = &VOLSER1                /* Volume alias.

*-------------------------------------------------------------------*
* WORKVOL - Not needed if you have plenty of PUBLIC mounted disk.   *
* No data is permanently left on this volume.                       *
*-------------------------------------------------------------------*
 WORKVOL    = Z10001                  /* Volser for large work files.

*-------------------------------------------------------------------*
* IOCONFIGID - Use HCD to be sure this value is defined as a valid  *
* IOCONFIG ID in the IODF dataset that you specify.  This value is  *
* inserted in the SYS1.IPLPARM(LOADxx) member.                      *
*-------------------------------------------------------------------*
 IOCONFIGID = PROD1                   /* 8 char IO config ID for LOADxx
 SMFID      = Z&CLN                   /* 4 char SMF id for new system.

*-------------------------------------------------------------------*
* Catalog related parms.                                            *
*-------------------------------------------------------------------*
 OLDMCAT    = CATALOG.MSTZ110         /* Driving sys master cat.
 NEWMCAT    = CATALOG.MASTER          /* New sys. mastercat name.
 NEWMCATVOL = &CATVOL                 /* New sys. mastercat vol.
 NEWUCAT    = CATALOG.SYSTEM          /* New sys. usercat name.
 NEWUCATVOL = &CATVOL                 /* New sys. usercat vol.
 UCATALIAS1 = SMS
 UCATALIAS2 = &TSOID1
 UCATALIAS2 = &TSOID2
 UCATALIAS2 = &TSOID3
 SSA        = SYSZC.                  /* Temp. dsn prefix used to
 SSAU       = SYSUC.                  /* avoid ENQ problems. SSAU is

 SYSRES     = Z10RES                  /* Driving sys sysres volume.
 COMMANDPGM = COMMAND                 /* "COMMAND" pgm is available.
 WAITPGM    = WAIT                    /* "WAIT" pgm is available.

*-------------------------------------------------------------------*
* JES2 Parms.  A SPOOLDEF and CKPTDEF entry will be added to the    *
* ZJES2PRM member to create a final JES2PARM member.  You must      *
* define a SPOOL and at least one CKPT dataset in the @DATASET      *
* member.  The CKPT dataset(s) should have the parm of HASPCKPT,    *
* and the spool dataset should have the parm HASPACE.               *
* SPOOLPRF is the length of the SPOOLDEF VOLUME= parm.  If it is    *
* set to 4, for example, and the volser where the spool dataset is  *
* allocated is RESCUE, then the SPOOLDEF VOLUME=RESC is coded.      *
*-------------------------------------------------------------------*
 SPOOLPRF   = 5                       /* Length of SPOOLDEF prefix.

*-------------------------------------------------------------------*
* RACF Parms.                                                       *
* Note: Some of the RACF actions require RACF SPECIAL to perform.   *
* Any TSO ID can run the RESCUE execs, but the RACF ID used to run  *
* the resulting jobs will need RACF SPECIAL, or specific privileges *
* for various RACF operations (CLAUTH, etc.)                        *
*-------------------------------------------------------------------*
*-------------------------------------------------------------------*
* RFSTCx: Defines STCs for ICHRIN03 started task table.             *
* p1 = Task name, p2 = RACF ID, p3 = RACF group.                    *
* Each task defined will have privileged bit set on, so these tasks *
* should be able to bypass most RACF Access checking.  Commands     *
* for creating the specified IDs and Groups will be generated only  *
* if the IDs/groups DO NOT already exist.                           *
*-------------------------------------------------------------------*
 RFDSNT     = YES                     /* Create RACF ICHRDSNT
 RFSTC      = NO                      /* Create RACF ICHRIN03
 RFTSOPROC  = YES                     /* Define TSOPROC to TSOPROC class

*-------------------------------------------------------------------*
* Started task support:                                             *
* If entries are defined below, then an ICHRIN03 module will be     *
* built with these entries.  An MLPA entry for this ICHRIN03        *
* will be placed in IEALPA00.  Format of RFSTCx is:                 *
* RFSTCx = stcname, racfid, racfgrp  All three parms are required.  *
* This option may be most useful when building a single pack rescue *
* system.  If your RACF dataset already has STARTED class profiles  *
* for the started tasks listed below, then you don't need an STC.   *
*-------------------------------------------------------------------*
*RFSTC1     = RACF,    $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC2     = JES2,    $RESCUE, $STC  /* STCs to go in ICHRIN03
**FSTC3     = VTAM,    $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC4     = TSO,     $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC5     = TCPIP,   $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC6     = OMVS,    $RESCUE, $STC  /* STCs to go in ICHRIN03
./ ADD NAME=@PARM3   0104-10016-10018-1903-00142-00142-00000-COMPJM
*-------------------------------------------------------------------*
*  ZCLONE system parameters.                                        *
*  To assign parms, use statements like: PARM1  = Some Value        *
*-------------------------------------------------------------------*
*  03/10/2007 John C. Miller.                                       *
*-------------------------------------------------------------------*
 CLN        = R01       /* My locally defined variable (JCM).
 SYSPLEX    = HRCPLEX   /* For couple dataset definition.
 SYSNAME    = TEST      /* For LPAR specific dsns.

*-------------------------------------------------------------------*
* Jobcard info.  "COMMENT" is placed in each job.                   *
* Jobname must be 7 chars or less to allow job char to be added.    *
*-------------------------------------------------------------------*
 JOBCARD1   = //COMPJM  JOB (0),JMILLER,CLASS=A,
 JOBCARD2   = //   NOTIFY=COMPJM,MSGCLASS=X,REGION=6M
 JOBCARD3   = /*JOBPARM LINES=999999
 COMMENT    = John C. Miller

 @DATASET   = @DATA3     /* Contains dataset definitions.  If omitted,
                         /* defaults to @DATASET.

*-------------------------------------------------------------------*
* USESYM = YES means that indirect volume addressing will be used   *
* for NONVSAM datasets. &SYSR2-&SYSRn will be defined.              *
*-------------------------------------------------------------------*
 USESYM     = YES                    /* Use indirect volsers.
 VALIDPARMS = NO                     /* Don't validate parms.

*-------------------------------------------------------------------*
* TSO PROC and Userids to be created on the new system.             *
* TSOPROC should NOT exist on the driving system.  As many TSO ids  *
* as desired can be specified here.                                 *
*-------------------------------------------------------------------*
 TSOPROC    = TSOSYS                  /* TSOPROC to be built.
 TSOID1     = COMPJM                  /* TSO IDs to be defined on the
 TSOID2     = COMPJM2                 /* rescue system.
 TSOID3     =

*-------------------------------------------------------------------*
* Volume parameters.  You must specify at least VOLSER1 and ADDR1.  *
* If you need more space, then specify VOLSER2 & ADDR2 for a second *
* volume, and VOLSER3 & ADDR3 for a third volume, etc.  As many     *
* volumes as desired can be specified here, but there must be an    *
* ADDRn entry for each VOLSERn entry.                               *
* Note:  System symbols will be defined for each volume beyond      *
* VOLSER1.  &SYSR2 - &SYSRn will be defined for VOLSER2 and higher, *
* but only if USESYM = YES in this member.                          *
*-------------------------------------------------------------------*
 DEVTYPE    = 3390                    /* Unit of RESCUE volume.
 ADDR1      = 9150                    /* UNIT ADDR OF VOLUME.
 VOLSER1    = ZOSRS1                  /* VOLSER.
 ADDR2      = 9051                    /* UNIT ADDR OF VOLUME.
 VOLSER2    = ZOSCAT                  /* VOLSER.

* Optional volume aliases *
 SYSVL1     = &VOLSER1                /* Volume alias.
 SYSVL2     = &VOLSER1                /* Volume alias.
 HFSVOL     = &VOLSER1                /* Volume alias.
 CATVOL     = &VOLSER2                /* Volume alias.
 PAGVL1     = &VOLSER1                /* Volume alias.
 PAGVL2     = &VOLSER1                /* Volume alias.

*-------------------------------------------------------------------*
* WORKVOL - Not needed if you have plenty of PUBLIC mounted disk.   *
* No data is permanently left on this volume.                       *
*-------------------------------------------------------------------*
 WORKVOL    = Z10001                  /* Volser for large work files.

*-------------------------------------------------------------------*
* IOCONFIGID - Use HCD to be sure this value is defined as a valid  *
* IOCONFIG ID in the IODF dataset that you specify.  This value is  *
* inserted in the SYS1.IPLPARM(LOADxx) member.                      *
*-------------------------------------------------------------------*
 IOCONFIGID = PROD1                   /* 8 char IO config ID for LOADxx
 SMFID      = Z&CLN                   /* 4 char SMF id for new system.

*-------------------------------------------------------------------*
* Catalog related parms.                                            *
*-------------------------------------------------------------------*
 OLDMCAT    = CATALOG.Z10.MASTER      /* Driving sys master cat.
 NEWMCAT    = CATALOG.MASTER          /* New sys. mastercat name.
 NEWMCATVOL = &CATVOL                 /* New sys. mastercat vol.
 NEWUCAT    = CATALOG.SYSTEM          /* New sys. usercat name.
 NEWUCATVOL = &CATVOL                 /* New sys. usercat vol.
 UCATALIAS1 = &TSOID1
 UCATALIAS2 = &TSOID2
 UCATALIAS3 = &TSOID3
 SSA        = SYSZC.                  /* Temp. dsn prefix used to
 SSAU       = SYSUC.                  /* avoid ENQ problems. SSAU is

 SYSRES     = Z10RES                  /* Driving sys sysres volume.
 COMMANDPGM = COMMAND                 /* "COMMAND" pgm is available.
 WAITPGM    = WAIT                    /* "WAIT" pgm is available.

*-------------------------------------------------------------------*
* JES2 Parms.  A SPOOLDEF and CKPTDEF entry will be added to the    *
* ZJES2PRM member to create a final JES2PARM member.  You must      *
* define a SPOOL and at least one CKPT dataset in the @DATASET      *
* member.  The CKPT dataset(s) should have the parm of HASPCKPT,    *
* and the spool dataset should have the parm HASPACE.               *
* SPOOLPRF is the length of the SPOOLDEF VOLUME= parm.  If it is    *
* set to 4, for example, and the volser where the spool dataset is  *
* allocated is RESCUE, then the SPOOLDEF VOLUME=RESC is coded.      *
*-------------------------------------------------------------------*
 SPOOLPRF   = 5                       /* Length of SPOOLDEF prefix.

*-------------------------------------------------------------------*
* RACF Parms.                                                       *
* Note: Some of the RACF actions require RACF SPECIAL to perform.   *
* Any TSO ID can run the RESCUE execs, but the RACF ID used to run  *
* the resulting jobs will need RACF SPECIAL, or specific privileges *
* for various RACF operations (CLAUTH, etc.)                        *
*-------------------------------------------------------------------*
*-------------------------------------------------------------------*
* RFSTCx: Defines STCs for ICHRIN03 started task table.             *
* p1 = Task name, p2 = RACF ID, p3 = RACF group.                    *
* Each task defined will have privileged bit set on, so these tasks *
* should be able to bypass most RACF Access checking.  Commands     *
* for creating the specified IDs and Groups will be generated only  *
* if the IDs/groups DO NOT already exist.                           *
*-------------------------------------------------------------------*
 RFDSNT     = YES                     /* Create RACF ICHRDSNT
 RFSTC      = NO                      /* Create RACF ICHRIN03
 RFTSOPROC  = YES                     /* Define TSOPROC to TSOPROC class

*-------------------------------------------------------------------*
* Started task support:                                             *
* If entries are defined below, then an ICHRIN03 module will be     *
* built with these entries.  An MLPA entry for this ICHRIN03        *
* will be placed in IEALPA00.  Format of RFSTCx is:                 *
* RFSTCx = stcname, racfid, racfgrp  All three parms are required.  *
* This option may be most useful when building a single pack rescue *
* system.  If your RACF dataset already has STARTED class profiles  *
* for the started tasks listed below, then you don't need an STC.   *
*-------------------------------------------------------------------*
*RFSTC1     = RACF,    $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC2     = JES2,    $RESCUE, $STC  /* STCs to go in ICHRIN03
**FSTC3     = VTAM,    $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC4     = TSO,     $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC5     = TCPIP,   $RESCUE, $STC  /* STCs to go in ICHRIN03
*RFSTC6     = OMVS,    $RESCUE, $STC  /* STCs to go in ICHRIN03
./ ADD NAME=@SUBRL
/*-------------------------------=Rexx----*/
/* @SUBR - EDIT MACRO                     */
/*----------------------------------------*/
/* 08/31/2007 John C. Miller              */
/*----------------------------------------*/
/* Purpose: Replace subroutines in a src. */
/*----------------------------------------*/
ADDRESS ISREDIT
MACRO
member = "SUBR"

/* Get last line of member */
"(LINELST) = LINENUM .ZL"

"F 'low level functions'"
IF rc > 0 THEN signal done
"(LINESTR) = LINENUM .ZCSR"
LINESTR = LINESTR - 2
IF LINESTR < 0 THEN LINESTR = 1

"DELETE "LINESTR LINELST
"COPY "member" AFTER "LINESTR-1
"CHANGE 'setout pds' 'setout opds' ALL"
"CHANGE 'setinp pds' 'setinp ipds' ALL"
"CHANGE 'clsout pds' 'clsout opds' ALL"
"CHANGE 'ARG jobnum ipds opds .' 'ARG jobnum ipds opds zzprms .' ALL"
"CHANGE 'call varinit' 'IF \varinit() THEN RETURN' ALL"
"CHANGE 'F \varinit() THEN RETURN 0' 'F \varinit() THEN RETURN 1' ALL"

done:
"END"
./ ADD NAME=COMMAND
//COMPJMA JOB (990030,135,60,100),JMILLER,CLASS=A,
//        NOTIFY=&SYSUID,MSGCLASS=X,REGION=6M
//  JCLLIB ORDER=('CPAC.PROCLIB')
//ASMACL   EXEC  ASMACL,PARM.L='MAP,LET,LIST,NCAL,AC(1)'
//C.SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//           DD  DSN=SYS1.MODGEN,DISP=SHR
//C.SYSIN    DD  *
COMMAND  TITLE 'C O M M A N D  --  ISSUE SYSTEM OPERATOR COMMANDS V2.0'
***********************************************************************
*                                                                     *
*                           C O M M A N D                             *
*                                                                     *
*                   ISSUE SYSTEM OPERATOR COMMANDS                    *
*                                                                     *
***********************************************************************
*                                                                     *
* NOTE: This version has RACHECK code added to be sure that the       *
* caller has at least READ access to the COMMAND profile of the       *
* APPL RACF class.  To permit use of the COMMAND command:             *
*                                                                     *
*    RDEFINE APPL COMMAND UACC(NONE)                                  *
*    PERMIT  COMMAND CLASS(APPL) ID(userid)                           *
*                                                                     *
* 03/21/2001 John C. Miller                                           *
***********************************************************************
*                                                                     *
*     THIS PROGRAM ACCEPTS SYSTEM OR JES OPERATOR COMMANDS AS         *
*     INPUT AND EXECUTES THEM USING SVC 34. IT MUST BE APF            *
*     AUTHORIZED.                                                     *
*                                                                     *
*     COMMAND CAN OPERATE IN ONE OF THREE MODES:                      *
*                                                                     *
*     1) BATCH OR CALLED PROGRAM                                      *
*        IN THIS MODE COMMAND ACCEPTS INPUT AS EITHER 80-BYTE         *
*        CARD IMAGES FROM SYSIN OR A SINGLE COMMAND FROM THE PARM     *
*        FIELD. THE RESPONSE TO THE OPERATOR COMMAND WILL             *
*        APPEAR ON ALL OPERATOR CONSOLES. FOR EXAMPLE:                *
*                                                                     *
*           //STEP1    EXEC PGM=COMMAND,PARM='VARY 017,ONLINE'        *
*                                                                     *
*           - OR -                                                    *
*                                                                     *
*           //STEP1    EXEC PGM=COMMAND                               *
*           //SYSIN    DD *                                           *
*           VARY 017,ONLINE                                           *
*           /*                                                        *
*                                                                     *
*        IF COMMANDS ARE FETCHED FROM SYSIN, A DELAY OF 2 SECONDS     *
*        WILL BE ADDED BETWEEN COMMANDS.                              *
*                                                                     *
*     2) TSO COMMAND PROCESSOR                                        *
*        IN THIS MODE COMMAND EXPECTS TO FIND THE OPERATOR COMMAND    *
*        DIRECTLY FOLLOWING ON THE TSO INPUT LINE. THE RESPONSE TO    *
*        OS COMMANDS WILL THEN BE DISPLAYED ON THE TSO TERMINAL.      *
*        RESPONSE TO JES COMMANDS WILL APPEAR ON YOUR TERMINAL        *
*        PROVIDED A LOCAL MODIFICATION IS MADE TO JES2 TO ALLOW       *
*        IT TO INTERCEPT THE COMMAND AND SET THE RESPONSE TO TSO.     *
*        OTHERWISE, JES2 COMMANDS WILL APPEAR ON ALL CONSOLES.        *
*        FOR EXAMPLE:                                                 *
*                                                                     *
*           COMMAND D T         <--- (RESPONSE WILL APPEAR ON CRT)    *
*                                                                     *
*     3) CALLABLE SUBROUTINE                                          *
*        IN THIS MODE COMMAND ACCEPTS INPUT ACCORDING TO STANDARD     *
*        OS LINKAGE CONVENTIONS. IN ADDITION TO THE COMMAND ITSELF,   *
*        A SECOND PARAMETER MAY BE PASSED WHICH CONTAINS THE          *
*        CONSOLE NUMBER WHERE YOU WISH THE RESPONSE TO APPEAR.        *
*        (THE SVC 34 WILL ALSO ASSUME THE AUTHORITY OF THAT           *
*        CONSOLE.) FOR EXAMPLE:                                       *
*                                                                     *
*           LA       R1,CMDADDR                                       *
*           LA       R15,=V(COMMAND)                                  *
*           BALR     R14,R15                                          *
*                                                                     *
*           CMDADDR  DC    A(OPERCMD)                                 *
*           CNSADDR  DC    XL1'80',AL3(CONSOLE)                       *
*           OPERCMD  DC    H(3),CL3'D T'                              *
*           CONSOLE  DC    F'5'                                       *
*                                                                     *
*        THIS WOULD MAKE IT APPEAR AS IF 'D T' WERE ISSUED FROM       *
*        CONSOLE 5. (THIS METHOD IS USED BY PROGRAM 'SPY')            *
*                                                                     *
*        COMMAND MAY BE USED TO ISSUE REPLIES TO WTORS.               *
*                                                                     *
*     AUTHOR:                                                         *
*       THE ORIGINAL VERSION OF COMMAND WAS WRITTEN BY MARK SORKIN.   *
*       THE CURRENT VERSION HAS BEEN HEAVILY MODIFIED AT SCE.         *
*       QUESTIONS AND COMMENTS MAY BE SENT TO                         *
*                                                                     *
*          STEVE LANGLEY                                              *
*          SOUTHERN CALIFORNIA EDISON                                 *
*          P.O. BOX 800                                               *
*          ROSEMEAD, CALIF. 91770                                     *
*          1-213-572-3435                                             *
*                                                                     *
*     IMPLEMENTOR:                                          *HMD 07/81*
*       THIS PROGRAM HAS BEEN REVISED AND IMPLEMENTED AT    *HMD 07/81*
*       GTE DATA SERVICES, MARINA DEL REY, CA BY:           *HMD 07/81*
*                                                           *HMD 07/81*
*          HOWARD M. DEAN                                   *HMD 07/81*
*          GTE DATA SERVICES                                *HMD 07/81*
*          4750 LINCOLN BLVD.                               *HMD 07/81*
*          MARINA DEL REY, CALIF. 90291                     *HMD 07/81*
*          PHONE - (213) - 821-0511                         *HMD 07/81*
*                                                           *HMD 07/81*
*       CHANGES MADE BY THE ABOVE ARE MARKED WITH           *HMD 07/81*
*       '*HMD XX/XX*' IN COL 61-71. XX/XX IS THE            *HMD 07/81*
*       CHANGE DATE (MONTH AND YEAR).                       *HMD 07/81*
***********************************************************************
         EJECT
COMMAND  CSECT
         SPACE 3
R0       EQU   0                  REGISTER 0
R1       EQU   1                  REGISTER 1
R2       EQU   2                  WORK REGISTER
R3       EQU   3                  WORK REGISTER
R4       EQU   4                  WORK REGISTER
R5       EQU   5                  WORK REGISTER
R6       EQU   6                  WORK REGISTER             *HMD 07/81*
R7       EQU   7                  WORK REGISTER             *HMD 07/81*
R8       EQU   8                  WORK REGISTER             *HMD 07/81*
R9       EQU   9                  WORK REGISTER             *HMD 07/81*
R10      EQU   10                 PARAMETER LIST ADDRESS REGISTER
R11      EQU   11                 SUBROUTINE LINKAGE REGISTER
R12      EQU   12                 BASE REGISTER
R13      EQU   13                 SAVE AREA ADDRESS REGISTER
R14      EQU   14                 REGISTER 14
R15      EQU   15                 REGISTER 15
         EJECT
         SAVE  (14,12)            SAVE CALLER'S REGISTERS
         LR    R12,R15            ESTABLISH
         USING COMMAND,R12        ADDRESSABILITY
         LA    R3,SAVEAREA        GET OUR SAVEAREA ADDRESS
         ST    R13,SAVEAREA+4     ESTABLISH BACK
         ST    R3,8(R13)          AND FORWARD SAVEAREA POINTERS
         LR    R13,R3             ESTABLISH OUR SAVEAREA ADDRESS
         LR    R10,R1             SAVE PARAMETER REGISTER
         SPACE 2
*********************************************************** *CKO 07/92*
* Determine whether user is authorized to the application   *CKO 07/92*
*********************************************************** *CKO 07/92*
RACHK    EQU  *                                             *CKO 07/92*
         RACHECK ENTITY=(CMDENT),CLASS=CMDCLS,ATTR=READ     *CKO 07/92*
         LTR  R15,R15             Authorized to this prog?  *CKO 07/92*
         BNZ  NOTAUTH             Nope.                     *CKO 07/92*
         SPACE 2                                            *CKO 07/92*
         L     R2,CVTPTR          R2 = ADDR OF CVT
         USING CVT,R2
         L     R3,CVTTCBP         R3 = ADDR OF MAGIC QUADWORD
         L     R4,12(R3)          R4 = ADDR OF OUR ASCB
         USING ASCB,R4
         MVC   ASID,ASCBASID      SAVE OUR ASID
         DROP  R4
         L     R4,CVTCUCB         ADDR OF 'CUCB' (UCM BASE) *HMD 07/81*
         DROP  R2                 NO NEED FOR CVT BASE NOW  *HMD 07/81*
         USING UCM,R4             ADDRESS THE UCM           *HMD 07/81*
         LR    R2,R4              R2 = R4                   *HMD 07/81*
         S     R2,=F'4'           R2 = ADDR OF ADDR OF UCMP *HMD 07/81*
         L     R2,0(R2)           R2 = ADDR OF UCM PREFIX   *HMD 07/81*
         USING UCMPRFX,R2         ADDRESS THE PREFIX        *HMD 07/81*
         L     R5,UCMVEA          R5 = ADDR OF 1ST UCM ENTRY*HMD 07/81*
         L     R6,UCMVEZ          R6 = LNGTH OF EACH ENTRY  *HMD 07/81*
         L     R7,UCMVEL          R7 = ADDR OF LAST UCM ENT.*HMD 07/81*
         SLR   R8,R8              R8 = CONSOLE COUNTER      *HMD 07/81*
UCMLOOP  LA    R8,1(R8)           R8 = CONSOLE NUMBER       *HMD 07/81*
         C     R5,UCM_DNR_RSV02   IS THIS THE MASTER CON    *HMD 07/81*
         BNE   UCMNEXT            NO, CONTINUE LOOKING      *HMD 07/81*
         ST    R8,R0MASK          SAVE MSTR CONSOLE NUMBER  *HMD 07/81*
         B     INITDONE           DONE WITH THIS NOW        *HMD 07/81*
UCMNEXT  AR    R5,R6              BUMP TO NEXT UCM ENTRY    *HMD 07/81*
         CR    R5,R7              END OF UCM'S?             *HMD 07/81*
         BL    UCMLOOP            NO, CONTINUE              *HMD 07/81*
         DROP  R2,R4              GET RID OF BASES          *HMD 07/81*
         SPACE 3
INITDONE DS    0H                 CHECK OUT INPUT PARM
         MVI   CARD,C' '          CLEAR OUT COMMAND AREA    *HMD 07/81*
         MVC   CARD+1(L'CARD-1),CARD                        *HMD 07/81*
         TM    0(R10),X'80'       IS FIRST THE ONLY PARM?
         BO    ONEPARM            YES; ONLY PARM
         TM    4(R10),X'80'       IS SECOND THE LAST PARM?
         BO    TWOPARMS           YES; TWO PARMS (CALLED WITH CNXX)
***********************************************************************
*                                                                     *
*     A X'80' WAS NOT FOUND IN THE HIGH ORDER BYTE OF THE FIRST       *
*     TWO PARMS, SO WE CAN ASSUME COMMAND IS BEING CALLED AS A CP.    *
*     PLACE OUR ASID IN THE R0 MASK AND CONTINUE.                     *
*                                                                     *
***********************************************************************
         XR    R2,R2              CLEAR R2
         ICM   R2,B'0011',ASID    R2 = ASID OF CALLER
         O     R2,=XL4'00008000'  TELL SVC34 ITS AN ASID
         ST    R2,R0MASK          AND OVERRIDE THE R0 MASK
         L     R3,0(R10)          R3 = ADDR OF INPUT LINE
         LA    R4,4(R3)           R4 = ADDR OF FIRST CHAR OF INPUT
         AH    R4,2(R3)           R4 = ADDR OF FIRST CHAR PAST COMMAND
         LH    R2,0(R3)           R2 = TOTAL LENGTH OF STRING
         SH    R2,=H'4'           R2 = LENGTH MINUS HEADER  *HMD 07/81*
         SH    R2,2(R3)           R2 = LENGTH OF OPER CMD   *HMD 07/81*
         BNP   EOJ                IS NO COMMAND GOTO EOJ    *HMD 07/81*
         CH    R2,=H'100'         IS LENGTH TOO LONG?       *HMD 07/81*
         BNH   LENOK              LENGTH IS OK              *HMD 07/81*
         LA    R2,100             ONLY 1ST 100 BYTES        *HMD 07/81*
LENOK    BCTR  R2,0               R2 = R2 - 1 FOR EX MVC
         EX    R2,MOVE1           MOVE CMD INTO CARD
*************************************************************HMD 07/82*
** THE FOLLOWING CODE IS NECESSARY THE ENABLE THIS COMMAND  *HMD 07/82*
** TO WORK UNDER MVS/SP RELEASE 3. THIS IS DUE TO A CHANGE  *HMD 07/82*
** IN THE COMMAND SCHEDULER CSCB CREATION MODULE IEE0803D.  *HMD 07/82*
**                                                          *HMD 07/82*
** IN MVS/SP 3, IF AN ASID IS PRESENT IN THE XSA, THEN THE  *HMD 07/82*
** COMMAND SCHEDULER MOVES YOUR TSO USERID INTO THE NEWLY   *HMD 07/82*
** CREATED CSCB. WHY THIS IS DONE, WHO KNOWS. IT CAUSES,    *HMD 07/82*
** HOWEVER, THE STC INITIALIZATION ROUTINE IEEPRWI2 TO      *HMD 07/82*
** THINK THAT A 'SYSTEM' ADDRESS SPACE IS BEING CREATED     *HMD 07/82*
** DUE TO THE CHKEY FIELD OF THE CSCB CONTAINING YOUR       *HMD 07/82*
** USERID INSTEAD OF ZERO. BECAUSE THIS ADDRESS SPACE       *HMD 07/82*
** INITIALIZATION ROUTINE NAME FOR SYSTEM ADDRESS SPACES    *HMD 07/82*
** IS CONTAINED IN THE CHKEY FIELD, IEEPRWI2 ATTEMPT TO     *HMD 07/82*
** LINK TO YOUR TSO USERID TO INITIALIZE THE STARTED        *HMD 07/82*
** ADDRESS SPACE. THUS AN ABEND806-4 AND A RESULTING SVC    *HMD 07/82*
** DUMP.                                                    *HMD 07/82*
**                                                          *HMD 07/82*
** SINCE RESPONSE AT THE TERMINAL IS NOT REQUIRED FOR       *HMD 07/82*
** START AND MOUNT COMMANDS (AND THAT IS THE ONLY PLACE     *HMD 07/82*
** THIS CRAZY THING HAPPENS) WE WILL ISSUE THOSE COMMANDS   *HMD 07/82*
** WITH REGISTER ZERO EQUAL TO ZERO.                        *HMD 07/82*
*************************************************************HMD 07/82*
         CLC   =C'LOGON ',CARD    LOGON COMMAND?            *HMD 07/82*
         BE    EOJ                DON'T BE SILLY            *HMD 07/82*
         CLC   =C'logon ',CARD    LOGON COMMAND?            *HMD 07/82*
         BE    EOJ                DON'T BE SILLY            *HMD 07/82*
         CLC   =C'START ',CARD    IS IT A START COMMAND?    *HMD 07/82*
         BE    STARTM             YES..CLEAR R0MASK         *HMD 07/82*
         CLC   =C'S ',CARD        START COMMAND?            *HMD 07/82*
         BE    STARTM             YES, CLEAR R0MASK         *HMD 07/82*
         CLC   =C'MOUNT ',CARD    MOUNT COMMAND?            *HMD 07/82*
         BE    STARTM             YES, CLEAR R0MASK         *HMD 07/82*
         CLC   =C'M ',CARD        MOUNT COMMAND?            *HMD 07/82*
         BE    STARTM             NO COMTINUE WITH COMMANDS *HMD 07/82*
         CLC   =C'start ',CARD    L         C               *HMD 07/82*
         BE    STARTM               O          A            *HMD 07/82*
         CLC   =C's ',CARD            W            S        *HMD 07/82*
         BE    STARTM                   E             E     *HMD 07/82*
         CLC   =C'mount ',CARD            R                 *HMD 07/82*
         BE    STARTM                                       *HMD 07/82*
         CLC   =C'm ',CARD                                  *HMD 07/82*
         BNE   DOCMD              NO COMTINUE WITH COMMANDS *HMD 07/82*
STARTM   XC    R0MASK,R0MASK      CLEAR REGISTER 0 MASK     *HMD 07/82*
DOCMD    B     DOSVC34            GO DO THE COMMAND
***********************************************************************
*                                                                     *
*     X'80' WAS FOUND IN THE HIGH ORDER BYTE OF THE SECOND PARM,      *
*     SO WE HAVE BEEN CALLED AS A SUBROUTINE (MODE 3). THE SECOND     *
*     PARM CONTAINS THE CONSOLE ID WHERE THE COMMAND IS TO 'COME      *
*     FROM', SO USE THAT FOR THE R0 MASK.                             *
*                                                                     *
***********************************************************************
TWOPARMS L     R3,4(R10)          R3 = ADDR OF R0 MASK FOR SVC34
         MVC   R0MASK(4),0(R3)    SAVE R0 MASK FOR SVC34
***********************************************************************
*                                                                     *
*     ONLY ONE PARM WAS PASSED, SO WE ARE BEING CALLED IN MODE 1.     *
*     JUST ISSUE THE COMMAND FROM THE PARM STRING.                    *
*                                                                     *
***********************************************************************
ONEPARM  L     R10,0(R10)         GET PARAMETER ADDRESS
         SLR   R3,R3              CLEAR FOR ICM             *HMD 07/81*
         ICM   R3,B'0011',0(R10)  GET PARAMETER TEXT LENGTH
         BZ    USESYSIN           NO - GO GET COMMANDS FROM SYSIN
         CH    R3,=H'100'         COMMAND TOO LONG?         *HMD 07/81*
         BNH   CMDOK              NO, IS OK                 *HMD 07/81*
         LA    R3,100             ONLY DO 1ST 100 BYTES     *HMD 07/81*
CMDOK    BCTR  R3,R0              DECREMENT R3 FOR USE IN EXECUTE
         EX    R3,MOVE            EXECUTE MVC
DOSVC34  LA    R11,EOJ            GET ADDRESS FOR RETURN FROM SVC34
         B     SVC34              GO ISSUE COMMAND
         SPACE 3
***********************************************************************
*                                                                     *
*     NO PARM FIELD FOUND, SO LOOK AT SYSIN FOR INPUT                 *
*                                                                     *
***********************************************************************
USESYSIN OPEN  (SYSIN,INPUT)      OPEN SYSIN
         TM    SYSIN+DCBOFLGS-IHADCB,DCBOFOPN               *HMD 07/81*
         BZ    EOJ                IF BAD OPEN; END OF PGM   *HMD 07/81*
GETSYSIN GET   SYSIN,CARD         GET A SYSIN RECORD INTO SVC34 LIST
         MVC   CARD+72(8),CARD+80 BLANK OUT SEQUENCE FIELD IN 73-80
         CLI   CARD,C'*'          IS THIS A COMMENT?
         BE    GETSYSIN           YES;GO GET ANOTHER CARD
         LA    R11,GETSYSIN       GET ADDRESS FOR RETURN FROM SVC34
         B     SVC34              GO ISSUE COMMAND
         SPACE 3
EODSYSIN CLOSE (SYSIN)            CLOSE SYSIN
         SPACE 3
EOJ      L     R13,SAVEAREA+4     GET ADDRESS OF CALLER'S SAVEAREA
         RETURN (14,12),RC=0      RETURN TO CALLER
         SPACE 3                                            *CKO 07/92*
BADEOJ   L     R13,SAVEAREA+4     GET ADDRESS OF CALLER'S   *CKO 07/92*
         RETURN (14,12),RC=8      SAVE AREA & RETURN        *CKO 07/92*
         EJECT
***********************************************************************
*                                                                     *
*     THIS ROUTINE ACTUALLY ISSUES THE SVC 34. IT EITHER RETURNS      *
*     TO THE SYSIN-READ LOOP OR EOJ DEPENDING ON THE VALUE OF R11     *
*                                                                     *
***********************************************************************
SVC34    DS    0H
         LA    R3,CARD+L'CARD-1   POINT TO END OF TEXT      *HMD 07/81*
         LA    R4,CARD-1          POINT TO START OF TEXT    *HMD 07/81*
FINDTEXT DS    0H                 FIND LAST TEXT CHARACTER
         CR    R3,R4              ALL BLANK?
         BNH   SVC34END           YES - IGNORE IT
         CLI   0(R3),C' '         BLANK CHARACTER?
         BNE   GOTTEXT            NO - FOUND END OF TEXT
         BCT   R3,FINDTEXT        KEEP ON LOOKING
         SPACE
GOTTEXT  DS    0H                 BUILD PARAMETER LIST LENGTHS
         SR    R3,R4              COMPUTE LENGTH OF COMMAND *HMD 07/81*
         BNP   SVC34END           INVALID COMMAND           *HMD 07/81*
         LA    R3,5(R3)           TEXT AND LIST PREFIX
         STH   R3,CMDLIST         SET SVC 34 LIST LENGTH
         TESTAUTH FCTN=1          SEE IF WE ARE AUTHORIZED  *HMD 07/82*
         LTR   R15,R15            WELL, ARE WE?             *HMD 07/82*
         BZ    MODEOK             YES..JUST DO MODESET      *HMD 07/82*
         MVI   AUTHFLG,AUTHUS     INDICATE WE TURNED ON     *HMD 07/82*
* INSERT YOUR USER SVC HERE TO TURN ON APF AUTHORIZATION. A SAMPLE
* OF SUCH AN SVC IS ON THE LA MVS USER GROUP TAPE. THIS WILL ALLOW
* 'COMMAND' TO BE USED UNDER SPF OPTION 6 OR VIA THE 'CALL' COMMAND.
* ALSO, YOU WILL AVOID THE MESSY JOB OF UPDATING TABLES IN IKJEFT02.
         LTR   R15,R15            SYSTEM PROGRAMMER?        *HMD 07/82*
         BNZ   SVC34END           NOPE..DO NOT WASTE TIME   *HMD 07/82*
MODEOK   DS    0H                                           *HMD 07/82*
*        LA    R0,MSG1            ISSUE MESSAGE FOR COMMAND *BAC 05/90*
*        WTO   MF=(E,(R0))                                  *BAC 05/90*
         MVC   WTOCMD(101),CARD   MOVE IN COMMAND           *BAC 05/90*
         LA    R0,MSG2            ISSUE MESSAGE FOR COMMAND *BAC 05/90*
         WTO   MF=(E,(R0))                                  *BAC 05/90*
         MODESET KEY=ZERO         INDICATE KEY=ZERO
         SYSEVENT DONTSWAP        DONT GET SWAPPED          *HMD 07/81*
         L     R0,R0MASK          LOAD R0 FOR SVC34         *HMD 07/81*
         MGCR  CMDLIST            ISSUE OPERATOR COMMAND    *HMD 07/81*
         TM    SYSIN+DCBOFLGS-IHADCB,DCBOFOPN               *HMD 07/81*
*                                 ARE WE USING SYSIN?       *HMD 07/81*
         BZ    NOSTIMR            NO, DO NOT DELAY          *HMD 07/81*
         STIMER  WAIT,BINTVL=HOLD WAIT FOR A COMPLETION     *HMD 07/81*
NOSTIMR  SYSEVENT OKSWAP          OK TO GET SWAPPED NOW     *HMD 07/81*
         MODESET KEY=NZERO        GO BACK TO USER KEY
         CLI   AUTHFLG,AUTHUS     DID WE TURN ON AUTH?      *HMD 07/82*
         BNE   SVC34END           NO..JUST RETURN           *HMD 07/82*
* INSERT YOUR USER SVC HERE TO TURN OFF APF AUTHORIZATION, AS WE ARE
* DONE ISSUING COMMANDS.
         SPACE
SVC34END DS    0H                 END OF COMMAND ROUTINE
         BR    R11                RETURN TO MAINLINE
         SPACE 2                                            *CKO 07/92*
NOTAUTH  EQU  *                                             *CKO 07/92*
         TPUT  =CL60'Authorization failed for executing COMMAND',60
         B     BADEOJ                     Exit              *CKO 07/92*
         EJECT
SAVEAREA DC    18F'0'             OUR SAVEAREA
HOLD     DC    F'200'             WAIT FOR 2 SECONDS        *HMD 07/81*
R0MASK   DC    A(0)               R0 MASK FOR SVC34
AUTHFLG  DC    X'00'              AUTHORIZATION FLAG        *HMD 07/82*
AUTHUS   EQU   X'FF'              WE AUTHORIZED FOR SVC34   *HMD 07/82*
MOREFLG  DC    X'00'              EXTRA FILLER              *HMD 07/82*
ASID     DC    H'00'              OUR ASID
* Parms for RACHECK                                         *CKO 07/92*
CMDENT   DC    CL8'COMMAND'                                 *CKO 07/92*
CMDCLS   DC    AL1(4),C'APPL'                               *CKO 07/92*
         SPACE
         CNOP  4,8                ALIGN TO MIDDLE OF DOUBLE WORD
CMDLIST  DC    AL2(*-*,0)         SVC 34 LIST
CARD     DC    CL101' '           COMMAND TEXT
         SPACE 3
MOVE     MVC   CARD(*-*),2(R10)   MOVE PARM TEXT INTO SVC 34 LIST
MOVE1    MVC   CARD(*-*),0(R4)    MOVE PARM TEXT INTO SVC 34 LIST
         EJECT
SYSIN    DCB   DDNAME=SYSIN,DSORG=PS,LRECL=80,MACRF=(GM),RECFM=FB,     *
               EODAD=EODSYSIN
MSG1     WTO 'SYSTEMS PROGRAMMER BRIAN COURT ISSUES THE FOLLOWING COMMAX
               ND:',MF=L
MSG2     WTO '                                                         X
                                                          ',MF=L
WTOCMD   EQU MSG2+4
         EJECT
         LTORG                    BEGIN LITERAL POOL
         EJECT
***********************************************************************
*                                                                     *
*                SYSTEM CONTROL BLOCK MAPPING DSECTS                  *
*                                                                     *
*      ALL THESE MACROS CAN BE FOUND IN THE 'SYS1.AMODGEN' MACLIB     *
*                                                                     *
***********************************************************************
         CVT   DSECT=YES,LIST=YES COMMUNICATIONS VECTOR TABLE
         EJECT
         IHAASCB                  ADDRESS SPACE CONTROL BLOCK
         EJECT
         IEECUCM  FORMAT=NEW      UNIT CONTROL MODULE       *HMD 07/81*
         EJECT                                              *HMD 07/81*
         DCBD  DSORG=PS,DEVD=DA   DCB SYMBOLIC DEFN         *HMD 07/81*
         END
//L.SYSLMOD DD  DSN=SYS2.LINKLIB(COMMAND),DISP=SHR
./ ADD NAME=CONSOL00
INIT     CMDDELIM(")
         MLIM(1500)
         MONITOR(DSNAME)
         MMS(NO)
         PFK(00)
         RLIM(10)
         UEXIT(N)
DEFAULT ROUTCODE(ALL)
/********************************************************************/
/*                                                                  */
/* MASTER AND ALTERNATE CONSOLES                                    */
/*                                                                  */
/********************************************************************/
/* LIB: SYS1.PARMLIB(CONSOL00)                                       */
/* GDE: CBIPO MVS CUSTOMIZATION                                      */
/* DOC: THIS MEMBER CONTAINS THE MVS CUSTOM-BUILT IPO                */
/*      SUPPLIED CONSOLE DEFINITIONS FOR THE MASTER                  */
/*      CONSOLE AND THE ALTERNATE CONSOLES                           */
/*                                                                   */
CONSOLE DEVNUM(SYSCONS) ROUTCODE(ALL)
        MONITOR(JOBNAMES-T)
/*                                                                  */
CONSOLE DEVNUM(0A0) ROUTCODE(ALL)
        NAME(CON1)
        PFKTAB(PFKTAB1)
        AUTH(MASTER)
        UNIT(3270-X)
        MONITOR(JOBNAMES-T)
        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)
/*                                                                  */
CONSOLE DEVNUM(0A8) ROUTCODE(ALL)
        NAME(CON2)
        PFKTAB(PFKTAB1)
        AUTH(MASTER)
        UNIT(3270-X)
        MONITOR(JOBNAMES-T)
        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)
/*                                                                  */
CONSOLE DEVNUM(0B0) ROUTCODE(ALL)
        NAME(CON3)
        PFKTAB(PFKTAB1)
        AUTH(MASTER)
        UNIT(3270-X)
        MONITOR(JOBNAMES-T)
        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)
/*                                                                  */
CONSOLE DEVNUM(0B8) ROUTCODE(ALL)
        NAME(CON4)
        PFKTAB(PFKTAB1)
        AUTH(MASTER)
        UNIT(3270-X)
        MONITOR(JOBNAMES-T)
        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)
/*                                                                  */
CONSOLE DEVNUM(120) ROUTCODE(ALL)
        NAME(CON5)
        PFKTAB(PFKTAB1)
        AUTH(MASTER)
        UNIT(3270-X)
        MONITOR(JOBNAMES-T)
        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)
/*                                                                  */
CONSOLE DEVNUM(128) ROUTCODE(ALL)
        NAME(CON6)
        PFKTAB(PFKTAB1)
        AUTH(MASTER)
        UNIT(3270-X)
        MONITOR(JOBNAMES-T)
        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)
/*                                                                  */
CONSOLE DEVNUM(130) ROUTCODE(ALL)
        NAME(CON7)
        PFKTAB(PFKTAB1)
        AUTH(MASTER)
        UNIT(3270-X)
        MONITOR(JOBNAMES-T)
        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)
/*                                                                  */
CONSOLE DEVNUM(138) ROUTCODE(ALL)
        NAME(CON8)
        PFKTAB(PFKTAB1)
        AUTH(MASTER)
        UNIT(3270-X)
        MONITOR(JOBNAMES-T)
        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)
/*                                                                  */
/*                                                                  */
/********************************************************************/
/*                                                                  */
/* END OF CONSOLE DEFINITIONS                                       */
/*                                                                  */
/********************************************************************/
./ ADD NAME=LOAD10
*---------------------------------------------------------------------
* Load parameters for TEST
*---------------------------------------------------------------------
LPARNAME TEST
IODF     00 SYS1     TEST
IEASYM   (00,L)
NUCLEUS  1
SYSCAT   ZOSCAT113CCATALOG.MASTER
INITSQA  0000M 0001M
*UCLST   00 N
SYSPLEX  LOCAL
PARMLIB  SYS1.PARMLIB                                 ZOSRS1
PARMLIB  CPAC.PARMLIB                                 ZOSRS1
PARMLIB  SYS1.IBM.PARMLIB                             ZOSRS1
*---------------------------------------------------------------------
* Load parameters for PROD1
*---------------------------------------------------------------------
LPARNAME PROD1
IODF     00 SYS1     PROD1
IEASYM   (00,L)
NUCLEUS  1
SYSCAT   ZOSCAT113CCATALOG.MASTER
INITSQA  0000M 0001M
NUCLST   00 N
SYSPLEX  LOCAL
PARMLIB  SYS1.PARMLIB                                 ZOSRS1
PARMLIB  CPAC.PARMLIB                                 ZOSRS1
PARMLIB  SYS1.IBM.PARMLIB                             ZOSRS1
*---------------------------------------------------------------------
* Load parameters for PROD2
*---------------------------------------------------------------------
LPARNAME PROD2
IODF     00 SYS1     PROD2
IEASYM   (00,L)
NUCLEUS  1
SYSCAT   ZOSCAT113CCATALOG.MASTER
INITSQA  0000M 0001M
NUCLST   00 N
SYSPLEX  LOCAL
PARMLIB  SYS1.PARMLIB                                 ZOSRS1
PARMLIB  CPAC.PARMLIB                                 ZOSRS1
PARMLIB  SYS1.IBM.PARMLIB                             ZOSRS1
*---------------------------------------------------------------------
* Load parameters for SYSTEMS
*---------------------------------------------------------------------
LPARNAME SYSTEMS
IODF     00 SYS1     SYSTEMS
IEASYM   (00,L)
NUCLEUS  1
SYSCAT   ZOSCAT113CCATALOG.MASTER
INITSQA  0000M 0001M
NUCLST   00 N
SYSPLEX  LOCAL
PARMLIB  SYS1.PARMLIB                                 ZOSRS1
PARMLIB  CPAC.PARMLIB                                 ZOSRS1
PARMLIB  SYS1.IBM.PARMLIB                             ZOSRS1
./ ADD NAME=PARSED
/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
call setinp pds,'@DATASET','D.'
DO ###xx = 1 TO 5
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN DO
      zcontin = 1
      zrest = STRIP(zrest,"T")
      zrest = STRIP(zrest,"T","-")
   END
   ELSE zcontin = 0
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

./ ADD NAME=RESCUE
/*---------------------------------------------------Rexx--*/
/*         M A I N    R E S C U E    E X E C               */
/*---------------------------------------------------------*/
/* RESCUE  - Build JCL and other elements for a single     */
/*           volume rescue system.                         */
/*---------------------------------------------------------*/
/* Read the $$$DOC member for more information on using    */
/* the RESCUE execs.                                       */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2001 John C. Miller                        */
/*---------------------------------------------------------*/
/*---------------------------------------------------------*/
/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */
/*---------------------------------------------------------*/

/*---------------------------------------------------------*/
/* Get PDS name, initialize variables, and reset job char. */
/*---------------------------------------------------------*/
pds  = ##pds()        /* Get PDS name.                     */
call varinit          /* Read and validate @parms          */
call ##jobchr reset   /* Reset job char file.              */

/*---------------------------------------------------------*/
/* Be sure all datasets are present; if not, exit.         */
/*---------------------------------------------------------*/
if  \dscheck() THEN DO
   SAY 'One or more datasets missing.  Processing terminated.'
   exit
end

/*---------------------------------------------------------*/
/* Call routines to build various JCL members.             */
/*---------------------------------------------------------*/
call #initvol         /* Init volume.                      */
call #defmcat         /* Define mastercat.                 */
call #defvsam         /* Define PAGE, MANx, etc.           */
call #defnvsm         /* Define NONVSAM catalog entries.   */
call #alcnvsm         /* Allocate non-VSAM datasets.       */
call #copyds          /* Copy datasets.                    */
call #altnvsm         /* Alter NONVSAM entries.            */
call #rfdsnt          /* Create RACF dataset name table.   */
call #rfstc           /* Create RACF started task table.   */
call #rfcopy          /* Create copy of RF dataset.        */
call #members         /* Build various members. (External) */
call #copymem         /* Copy members.                     */
call #delssa          /* Delete the System Specific Alias. */
call #misc            /* Last minute assorted stuff.       */

exit

/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.            */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
IF VALUE("DSNS.0") = "DSNS.0" THEN DO
   SAY 'Need to call varinit before using this function.'
   RETURN 0
END
###dslst = ""
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   IF pos(##prm,zzparm) > 0 THEN DO
      ###dslst = ###dslst" "zzdsn1
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.            */
/*---------------------------------------------------------*/
xdsthere:
ARG ##prm .
IF VALUE("DSNS.0") = "DSNS.0" THEN DO
   SAY 'Need to call varinit before using this function.'
   RETURN 0
END

do ##xxx = 1 TO DSNS.0
   IF POS(##prm,DSNS.##xxx) > 0 THEN RETURN 1
END
RETURN 0

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   say VALUE("JOBCARD"##x8)
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions -----------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*-------------------------------------------*/
/* Read and validate @PARMS member, and      */
/* assign variable values.                   */
/*-------------------------------------------*/
varinit:
parse source a b exn .
IF SYSDSN("'"pds"'") /= OK THEN DO
   SAY " "
   SAY "Error allocating '"pds"'.  You may need to change the 'pds='"
   SAY "statement in the ##PDS member of the RESCUE PDS to the name of"
   SAY "the PDS that contains the RESCUE system execs and parameter"
   SAY "members.  If running in batch, be sure the RESCUE PDS is NOT in"
   SAY "use or allocated in any way by any other JOBS or TSO users."
   SAY " "
   SAY "This exec will exit now."
   EXIT
END

call setinp pds,'@PARMS','PARMS.'
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   PARSE VAR data data '/* ' .      /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   INTERPRET q '= "'r'"'
END
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Now we have all the @PARMS read in, so we */
/* will check them now.                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/

RETURN

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget: procedure
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget: procedure
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
trace off
"EXECIO * DISKW output (FINIS STEM "##stem5
trace off
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output) DA('"##ds5"("##mem5")')"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(output) DA('"ds"("mem")')"
x = MSG(x)
RETURN 1

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(pds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(pds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str WITH xx$hlq '.' junk
RETURN xx$hlq

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*---------------------------------------------------------*/
/* Check for presence of all datasets.  If copy mode is    */
/* "N" meaning the DS is not copied bu just created, then  */
/* assume it is ok.                                        */
/*---------------------------------------------------------*/
dscheck:
Say "Checking datasets in @DATASET member."
/* Read @dataset member into DSNS. stem variable.           */
call setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */
##ok = 1
do ##xxx = 1 TO DSNS.0
   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE
   PARSE VAR DSNS.##xxx,
   zzunit ',' zzvolnum ',' zzpri ',' zzsec ',' zzdir ',',
   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .
   zzdsn1 = strip(zzdsn1,'B')
   zzdsn2 = strip(zzdsn2,'B')
   IF zzdsn1 = "" THEN ITERATE
   /*--------------------------------------------------*/
   /* If a model is specified, then check only for the */
   /* existence of the model ds.                       */
   /*--------------------------------------------------*/
   stat = SYSDSN("'"zzdsn1"'")
   IF stat /= 'OK' THEN DO
      SAY 'Dataset not found: 'zzdsn1
      ##ok = 0
   END
END
RETURN ##ok

./ ADD NAME=WAIT
//COMPJMA JOB (990030,135,60,100),JMILLER,CLASS=A,
//        NOTIFY=&SYSUID,MSGCLASS=X,REGION=6M
//  JCLLIB ORDER=('CPAC.PROCLIB')
//ASMACL   EXEC  ASMACL,PARM.L='MAP,LET,LIST,NCAL'
//C.SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//           DD  DSN=SYS1.MODGEN,DISP=SHR
//C.SYSIN    DD  *
PRC      TITLE 'WAIT - WAIT A LITTLE BIT.'
********************************************************************
*                                                                  *
* NAME - WAIT.                                                     *
*                                                                  *
* DESCRIPTION -                                                    *
*                                                                  *
*   THIS MODULE WILL WAIT THE REQUESTED NUMBER OF SECONDS.         *
*                                                                  *
* TO USE -                                                         *
*                                                                  *
*   PARM='NNNN', WHERE 0 < NNNN <= 9999, THE NUMBER OF SECONDS TO  *
*     WAIT. DEFAULT IS 10 SECONDS.                                 *
*                                                                  *
* RETURN CODES -                                                   *
*                                                                  *
*   R15 = 20, BAD PARM FIELD.                                      *
*                                                                  *
* LOG -                                                            *
*   05/30/86 L01 PTW IMPLEMENTED                                   *L01
*   09/27/88 L02 PTW IMPLEMENTED                                   *L02
*                                                                  *
********************************************************************
         LCLC  &CSECT
&CSECT   SETC  'WAIT'
&CSECT   CSECT
********************************************************************
*                                                                  *
*        I N I T I A L I Z E                                       *
*                                                                  *
********************************************************************
         PRINT NOGEN
         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME
         LR    R12,R15            ESTABLISH BASE.
         USING &CSECT,R12
         GETMAIN RU,LV=DYNLEN
         LR    R2,R13
         LR    R13,R1
         USING DYNAMIC,R13
         LR    R0,R1
         LA    R14,DYNLEN
         LA    R1,R1
         SLR   R15,R15
         MVCL  R0,R14             ZERO STORAGE.
         ST    R2,4(,R13)         BACK CHAIN.
         ST    R13,8(,R2)         FORWARD CHAIN.
         XC    RC,RC
********************************************************************
*                                                                  *
*        P A R M   P R O C E S S I N G                             *
*                                                                  *
********************************************************************
         MVC   SECONDS,=F'10'     DEFAULT.
         L     R2,4(,R13)         A(PREVIOUS SAVEAREA).
         L     R2,24(,R2)         A(A(PARM)).
         LTR   R2,R2              CHECK FOR NULL PARM.
         BZ    DOTIME
         L     R2,0(,R2)          A(PARM).
         LH    R3,0(,R2)          L'PARM.
         LTR   R3,R3              IF ZEROS +
         BZ    DOTIME               THEN EXIT.
         CH    R3,=H'4'           IF LENGTH NGT '4' +
         BH    BADTIME            FORGET NEXT.
         LA    R4,2(,R2)
VERNUM   DS    0H
         CLI   0(R4),C'0'         SCAN
         BL    BADTIME             FORWARD
         CLI   0(R4),C'9'         SCAN
         BH    BADTIME             FORWARD
         LA    R4,1(,R4)            TO FIRST
         BCT   R3,VERNUM
         LH    R3,0(,R2)
         BCTR  R3,0               MACHINE LENGTH.
         EX    R3,PACKSEC         PACK SECONDS.
         CVB   R3,DOUBLE          CONVERT TO BINARY.
         CH    R3,=H'1'           TEST SECONDS
         BL    BADTIME             FOR LIMITS.
         CH    R3,=H'9999'
         BH    BADTIME
         ST    R3,SECONDS          AND STORE.
PACKSEC  PACK  DOUBLE,2(*-*,R2)
********************************************************************
*                                                                  *
*        W A I T                                                   *
*                                                                  *
********************************************************************
DOTIME   DS    0H
         L     R2,SECONDS
         MH    R2,=H'100'
         ST    R2,SECONDS
         STIMER WAIT,BINTVL=SECONDS
         XC    RC,RC
********************************************************************
*                                                                  *
*        R E T U R N                                               *
*                                                                  *
********************************************************************
RETURN   DS    0H
         L     R2,RC                  R2 = RC.
         LR    R1,R13              PREPARE
         L     R13,4(,R13)         FOR FREEMAIN.
         FREEMAIN RU,LV=DYNLEN,A=(1)
         LR    R15,R2              AND RETURN
         RETURN (14,12),RC=(15)      WITH R15 = RC.
********************************************************************
*                                                                  *
*        E R R O R S                                               *
*                                                                  *
********************************************************************
BADTIME  DS    0H
         WTO   'WAIT: BAD PARM - SPECIFY NNNN (1-9999 SECONDS).',      X
               ROUTCDE=11,MCSFLAG=HRDCPY
         MVC   RC,=F'20'
         B     RETURN
********************************************************************
*                                                                  *
*        S T A T I C   A R E A                                     *
*                                                                  *
********************************************************************
SRCLEVEL DC    C'                                        '
         LTORG *
********************************************************************
*                                                                  *
*        D Y N A M I C   A R E A                                   *
*                                                                  *
********************************************************************
DYNAMIC  DSECT
SAVE     DS    18F .
DOUBLE   DS    D
RC       DS    F
SECONDS  DS    F
DYNLEN   EQU   *-DYNAMIC
         PRINT OFF
R0       EQU   00
R1       EQU   01
R2       EQU   02
R3       EQU   03
R4       EQU   04
R5       EQU   05
R6       EQU   06
R7       EQU   07
R8       EQU   08
R9       EQU   09
R10      EQU   10
R11      EQU   11
R12      EQU   12                 PROGRAM BASE.
R13      EQU   13                 A(SAVE AREA).
R14      EQU   14
R15      EQU   15
         PRINT ON
         END   &CSECT
//L.SYSLMOD DD  DSN=SYS2.LINKLIB(WAIT),DISP=SHR,UNIT=
./ ADD NAME=ZBPXPRM
FILESYSTYPE TYPE(HFS)
            ENTRYPOINT(GFUAINIT)
            PARM(' ')

FILESYSTYPE TYPE(TFS)
            ENTRYPOINT(BPXTFS)

   MAXPROCSYS(900)
   MAXPROCUSER(100)
   MAXUIDS(200)
   MAXFILEPROC(2000)
   MAXPTYS(800)
   CTRACE(CTIBPX00)
   FILESYSTYPE TYPE(UDS) ENTRYPOINT(BPXTUINT)
   NETWORK DOMAINNAME(AF_UNIX)
           DOMAINNUMBER(1)
           MAXSOCKETS(2000)
           TYPE(UDS)
   FILESYSTYPE TYPE(INET) ENTRYPOINT(EZBPFINI)
   NETWORK DOMAINNAME(AF_INET)
           DOMAINNUMBER(2)
           MAXSOCKETS(64000)
           TYPE(INET)
   MAXTHREADTASKS(1000)
   MAXTHREADS(500)
   IPCMSGNIDS    (500)
   IPCMSGQBYTES  (2147483647)
   IPCMSGQMNUM   (10000)
   IPCSHMNIDS    (500)
   IPCSHMSPAGES  (262144)
   IPCSHMMPAGES  (25600)
   IPCSHMNSEGS   (500)
   IPCSEMNIDS    (500)
   IPCSEMNSEMS   (1000)
   IPCSEMNOPS    (25)
   MAXMMAPAREA(40960)
   MAXCORESIZE(4194304)
   MAXASSIZE(209715200)
   MAXCPUTIME(1000)
   MAXSHAREPAGES(131072)
   FORKCOPY(COW)
   SUPERUSER(BPXROOT)
   TTYGROUP(TTY)
   STARTUP_PROC(OMVS)
   SYSCALL_COUNTS(NO)
   MAXQUEUEDSIGS(1000)
   SYSPLEX(NO)
   SHRLIBRGNSIZE(67108864)
   SHRLIBMAXPAGES(4096)
./ ADD NAME=ZCLONE
/*---------------------------------------------------Rexx--*/
/*         M A I N    Z C L O N E    E X E C               */
/*---------------------------------------------------------*/
/* ZCLONE  - Build JCL and other elements to clone a       */
/*           zOS system.                                   */
/*---------------------------------------------------------*/
/* Read the $$$DOC member for more information on using    */
/* the ZCLONE execs.                                       */
/*---------------------------------------------------------*/
/* V2.0 - 03/08/2007 John C. Miller                        */
/*---------------------------------------------------------*/
PARSE ARG args

/*---------------------------------------------------------*/
/* Get PDS name, initialize variables, and reset job char. */
/*---------------------------------------------------------*/
ipds   = kget('INPDS','COMPJM.ZCLONE')
opds   = kget('OUTPDS','COMPJM.CJOBS')
zzprms = kget('PARMS','@PARMS') /* PARMS member of INPDS.    */

/*---------------------------------------------------------*/
/* Be sure all datasets coded in the @DATASET mem exist.   */
/*---------------------------------------------------------*/
sarg = ipds" "opds" "zzprms

IF #validat(sarg) THEN DO
   SAY 'Exiting due to errors.'
   exit
END

call varinit          /* Read and validate @parms          */

/*---------------------------------------------------------*/
/* Call routines to build various JCL members.             */
/* Pass each routine some parms that they will need.       */
/*---------------------------------------------------------*/
call #initvol jchr() sarg /* Init volumes.                 */
call #defcat  jchr() sarg /* Define catalogs.              */
call #alcnvsm jchr() sarg /* Allocate non-VSAM datasets.   */
call #defvsam jchr() sarg /* Define PAGE, MANx, etc.       */
call #copyds  jchr() sarg /* Copy datasets.                */
call #misc    jchr() sarg /* Assorted minutiae             */
call #defnvsm jchr() sarg /* Define NONVSAM catalog entr.  */
call #rfdsnt  jchr() sarg /* Create RACF dataset name tab. */
call #rfstc   jchr() sarg /* Create RACF started task tab. */
call #alterjc jchr() sarg /* Alter catalog entries.        */
call #copymem jchr() sarg /* Copy members.                 */
call #members        sarg /* Build various members.        */
exit

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*---------------------------------------------------------*/
/* jchr -   Return the next job character.                 */
/*---------------------------------------------------------*/
jchr:
ARG options .
##JOBCHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789"

/* Reset xxjobnum to 0 if this is the first call.          */
IF SYMBOL('zzjnum') = 'LIT' THEN zzjnum = 0

zzjnum = zzjnum + 1
if zzjnum > length(##JOBCHARS) THEN zzjnum = 1
RETURN SUBSTR(##JOBCHARS,zzjnum,1)

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- low level functions - v3.8 ----------*/
/*-------------------------------------------*/
/*-------------------------------------------*/

/*---------------------------------------------------------*/
/* Parse the @DATASET member, and store the data in a      */
/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */
/*---------------------------------------------------------*/
parse_dataset:
DROP DS.
dsidx=0
IF isblank('@DATASET') THEN zzdsmem = '@DATASET'
ELSE zzdsmem = @DATASET
call setinp ipds,zzdsmem,'D.'
DO ###xx = 1 TO D.0
   IF LEFT(D.###xx,1) = "*" THEN ITERATE
   IF D.###xx = ""          THEN ITERATE
   D.###xx = SUBSTR(D.###xx,1,72)
   PARSE VAR D.###xx zverb zrest
   IF contin(D.###xx) THEN zcontin = 1
   ELSE zcontin = 0
   zrest = STRIP(zrest,"T")
   zrest = STRIP(zrest,"T","-")
   zrest = STRIP(zrest,"T","+")
   /* Valid statement found, parse it. */
   dsidx = dsidx + 1
   DS.0 = dsidx

   DS.dsidx.verb = zverb

   /* If DATASET then get option (2nd word in line) */
   IF zverb = 'DATASET' THEN DO
      PARSE VAR zrest zoption zrest
      DS.dsidx.option = zoption /* Save option in stem. */
   END
   DO WHILE zrest /= ""
      zrest = STRIP(zrest,"B")" "
      PARSE VAR zrest zparm '(' zvalue ') ' zrest
      zvalue = STRIP(zvalue,"B")
      zvalue = varsub(zvalue)  /* Do symbolic substitution. */
      IF zparm = 'VOLUME' THEN zparm = 'VOL'
      IF zparm = 'DATASET' THEN zparm = 'DSN'
      INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
   END
   DO WHILE zcontin
      ###xx = ###xx + 1
      IF LEFT(D.###xx,1) = "*" THEN ITERATE
      IF D.###xx = ""          THEN ITERATE
      IF ###xx > D.0 THEN SIGNAL dsparmsdone
      D.###xx = SUBSTR(D.###xx,1,72)
      zrest = D.###xx
      IF contin(D.###xx) THEN DO
         zcontin = 1
         zrest = STRIP(zrest,"T")
         zrest = STRIP(zrest,"T","-")
      END
      ELSE zcontin = 0
      DO WHILE zrest /= ""
         zrest = STRIP(zrest,"B")" "
         PARSE VAR zrest zparm '(' zvalue ') ' zrest
         zvalue = STRIP(zvalue,"B")
         zvalue = varsub(zvalue)  /* Do symbolic substitution. */
         IF zparm = 'VOLUME' THEN zparm = 'VOL'
         IF zparm = 'DATASET' THEN zparm = 'DSN'
         INTERPRET 'DS.dsidx.'zparm' = "'zvalue'"'
      END
   END
   /* Assign default values if needed. */
   IF symbol("DS."dsidx".VOL") /= "VAR" THEN DS.dsidx.VOL = VOLSER1
   IF zverb = "DATASET" & zoption = "COPY" THEN,
   IF symbol("DS."dsidx".MODE") /= "VAR" THEN DS.dsidx.MODE = "DFDSS"
END
dsparmsdone:
RETURN

/* SUBR */
contin: ARG ###d, ###contchar
IF ###contchar = "" THEN ###contchar = '-'
###d = STRIP(###d,"T")
IF RIGHT(###d,1) = ###contchar THEN RETURN 1
RETURN 0
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* End of parse_dataset                                    */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*---------------------------------------------------------*/
/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */
/*---------------------------------------------------------*/
dsdefined:
ARG #x##dsn2
DO #x#x2 = 1 TO DS.0
   IF DS.#x#x2.verb /= "DATASET" THEN ITERATE
   IF SYMBOL("DS."#x#x2".NEWNAME") = "VAR" THEN,
      #x##dsn = DS.#x#x2.NEWNAME
   ELSE #x##dsn = DS.#x#x2.DSN
   IF #x##dsn2 = #x##dsn THEN RETURN 1
END
RETURN 0


/*---------------------------------------------------------*/
/* Extract list of datasets depending on parms.  The list  */
/* returned is a space delimited list of dsn+volume pairs, */
/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */
/* The parse_dataset routine must have already be run for  */
/* this routine to work.                                   */
/*---------------------------------------------------------*/
xdslist:
ARG ##prm
###dslst = ""
do ###xx = 1 TO DS.0
   IF DS.###xx.verb /= "DATASET" THEN ITERATE
   IF attrib(##prm,DS.###xx.PARM) THEN DO
      IF SYMBOL("DS."###xx".NEWNAME") = "VAR" THEN,
      ###dslst = ###dslst" "DS.###xx.NEWNAME DS.###xx.VOL
      ELSE,
      ###dslst = ###dslst" "DS.###xx.DSN DS.###xx.VOL
   END
END
RETURN ###dslst

/*---------------------------------------------------------*/
/* dstype - Return dataset type.                           */
/*---------------------------------------------------------*/
dstype:
ARG ##ds
##x = OUTTRAP('##y.',25)
"LISTD '"##ds"'"
##rc = rc
##x = OUTTRAP('OFF')
IF ##rc > 0 THEN RETURN "ERROR"
ELSE RETURN WORD(##y.3,WORDS(##y.3))

/*---------------------------------------------------------*/
/* Write a jobcard.                                        */
/*---------------------------------------------------------*/
jobcard:
ARG ##jobnum
##jc1 = VALUE("JOBCARD1")
IF ##jc1 = "JOBCARD1" THEN RETURN  /* JOBCARD1 not coded in parms. */
PARSE VAR ##jc1 ##jc1a ##jc1b
##jc1 = STRIP(##jc1a,"B")""##jobnum" "##jc1b
call jcl ##jc1

DO ##x8 = 2 TO 10
   IF VALUE("JOBCARD"##x8) = "JOBCARD"##x8 THEN RETURN
   call jcl VALUE("JOBCARD"##x8)
END
RETURN

##c = "//"jobpref""##jobnum" JOB (0),ZCLONE,MSGCLASS=X,"
call jcl ##c
##c = "//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD"
call jcl ##c
RETURN

/*-------------------------------------------*/
/* Write to a stem variable.                 */
/* Use INTERPRET so we can pass              */
/* a stem variable name.                     */
/*-------------------------------------------*/
jcl:
PARSE ARG ##txt7, ##stem7
IF ##stem7 = "" THEN ##stem7 = 'OUTPUT.'
IF VALUE(##stem7"0") = ##STEM7"0" THEN DO
  INTERPRET ##stem7"0 = 0"
END
if ##x7 > 1000 THEN TRACE off
INTERPRET "##x7 = "##stem7"0"
INTERPRET "##x7 = ##x7 + 1"
INTERPRET ##stem7"0 = ##x7"
INTERPRET ##stem7""##x7" = ##txt7"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment block.                              */
/*---------------------------------------------------------*/
jcc:
PARSE ARG ##str,##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//* "##str,##len)"*"
RETURN

/*---------------------------------------------------------*/
/* Write a jcl comment line.                               */
/*---------------------------------------------------------*/
jcd:
PARSE ARG ##len
IF DATATYPE(##len) /= 'NUM' THEN ##len = 68
call jcl left("//*",##len,"-")"*"
RETURN

/*-------------------------------------------*/
/* Read parm file and assign variables.      */
/*-------------------------------------------*/
varinit:
IF \setinp(ipds,zzprms,'PARMS.') THEN DO
   SAY "Error: Unable to allocate parms member:"ipds"("zzprms")."
   RETURN 0
END
DO x = 1 TO PARMS.0
   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */
   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */
   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,
   PARSE VAR data data '/* ' .     /* Axe inline comments  */
   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */
   PARSE VAR data q '=' r          /* Get parms and data   */
   q = strip(q,'B');r = strip(r,'B')
   IF q = "" THEN ITERATE
/* IF r = "" THEN ITERATE */
   r = varsub(r)
   INTERPRET q '= "'r'"'
END
RETURN 1

/*-------------------------------------------*/
/* Get keyword value parameter               */
/*-------------------------------------------*/
kget:
ARG var, default
kargs = args
PARSE UPPER VAR kargs (var)"(" var ")" junk
IF var = '' THEN var = default
RETURN var

/*-------------------------------------------*/
/* Get keyword intrinsic parameter           */
/*-------------------------------------------*/
iget:
ARG var
pstr = " "var" "
IF POS(" "var" "," "args" ") = 0 THEN RETURN 0
ELSE RETURN 1

/*-----------------------------------------------------*/
/* Allocate output member                              */
/*-----------------------------------------------------*/
setout:
ARG ##ds, ##mem, ##stem
IF ##stem = "" THEN ##stem = 'OUTPUT.'
INTERPRET "DROP "##stem
##x = MSG('OFF')
"FREE  FI(output)"
##x = MSG(##x)
"ALLOC FI(output) DA('"##ds"("##mem")') SHR"
IF RC = 0 THEN RETURN 1
ELSE DO
   SAY 'Error allocating '##ds'('##mem')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsout:
ARG ##ds5, ##mem5, ##stem5

IF ##stem5 = "" THEN ##stem5 = 'OUTPUT.'
"EXECIO * DISKW output (FINIS STEM "##stem5
rcde = RC
##x5 = MSG('OFF')
"FREE  FI(output)"
##x5 = MSG(##x5)
IF rcde = 0 THEN RETURN 1
ELSE DO
   SAY 'Error closing '##ds5'('##mem5')'
   RETURN 0
END

"FREE  FI(output) DA('"##ds5"("##mem5")')"

/*-----------------------------------------------------*/
/* Allocate input member                               */
/*-----------------------------------------------------*/
setinp:
ARG ##ds2, ##mem2, ##stem2
IF ##stem2 = "" THEN ##stem2 = 'INPUT.'
IF SYSDSN("'"##ds2"("##mem2")'") /= "OK" THEN RETURN 0
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
"ALLOC FI(input) DA('"##ds2"("##mem2")') SHR"
IF RC = 0 THEN DO
   "EXECIO * DISKR input (FINIS STEM "##stem2
   x = MSG('OFF')
   "FREE  FI(input)"
   x = MSG(x)
   RETURN 1
END
ELSE DO
   SAY 'Error allocating '##ds2'('##mem2')'
   RETURN 0
END

/*-----------------------------------------------------*/
/* Close output member                                 */
/*-----------------------------------------------------*/
clsinp:
ARG ds, mem
x = MSG('OFF')
"FREE  FI(input)"
x = MSG(x)
RETURN 1

"FREE  FI(input) DA('"ds"("mem")')"

/*-------------------------------------------*/
/* Write an status message.                  */
/* If a null line is specified as the text   */
/* then close the output file.               */
/*-------------------------------------------*/
mmsg: procedure
PARSE ARG ##msg
IF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0

/*-------------------------------------------*/
/* Queue the passed msg to the stem var.     */
/*-------------------------------------------*/
IF length(##msg) = 0 THEN signal wmsg
##msgq.0 = ##msgq.0 + 1
##x = ##msgq.0
##msgq.##x = ##msg
RETURN 1

/*-------------------------------------------*/
/* Write error messages to the PDS.          */
/*-------------------------------------------*/
wmsg:
##x = setout(opds,mstatus)
"EXECIO * DISKW output (STEM ##msgq. FINIS"
##x = clsout(opds,mstatus) THEN SIGNAL ext
RETURN 1

/*-------------------------------------------*/
/* ASTRIP - Strip spaces and dashes          */
/*-------------------------------------------*/
/* This low level function strips both blanks*/
/* and dashes from the passed string.        */
/*-------------------------------------------*/
astrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))

/*-------------------------------------------*/
/* XXHLQ  - get hlq.                         */
/*-------------------------------------------*/
hlq: procedure
ARG ##str
PARSE UPPER VAR ##str ##str2 '.' .
RETURN ##str2

/*-------------------------------------------*/
/* XXLLQ  - get hlq.                         */
/*-------------------------------------------*/
llq: procedure
ARG ##str
##x = lastpos(".",##str)
##llq = substr(##str,##x+1)
RETURN ##llq

/*-------------------------------------------*/
/* Get date in format: 01/01/2001            */
/*-------------------------------------------*/
mydate: procedure
return substr(date('u'),1,6)""word(date('n'),3)

/*-------------------------------------------*/
/* Get number of occurences of one string    */
/* in another.                               */
/*-------------------------------------------*/
numof: procedure
ARG ##str,##tgt
##ctr = 0
DO WHILE ##str /= ""
   ##ctr = ##ctr + 1
   parse var ##str (##tgt) ##str
END
RETURN ##ctr-1

/*-------------------------------------------*/
/* Get next sequential integer fro job num.  */
/*-------------------------------------------*/
nextjob:
IF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0
##JOBCHARS = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##jobnum = ##jobnum + 1
RETURN substr(##jobchars,##jobnum,1)

/*-------------------------------------------*/
/* Check to see if a parm is found in a parm */
/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */
/* ##httrib might be LNK., e.g.              */
/*-------------------------------------------*/
attrib:
ARG ##attrib, ##parms
/* Change parens, dots and commas to blanks */
##parms = " "translate(##parms,"    ","(),.")" "
IF POS(" "##attrib" ",##parms) > 0 THEN RETURN 1
ELSE RETURN 0

/*-------------------------------------------*/
/* Translate to lower case.                  */
/*-------------------------------------------*/
lower: procedure
ARG string
lower = 'abcdefghijklmnopqrstuvwxyz'
upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RETURN translate(string,lower,upper)

/*---------------------------------------------------------*/
/* nonblank - Determine if a variable is blank or undef.   */
/*---------------------------------------------------------*/
isblank:
PARSE ARG #prm
IF VALUE(#prm) = "" THEN RETURN 1
IF SYMBOL(#prm) = = "LIT" THEN RETURN 1
RETURN 0

/*-------------------------------------------*/
/* Variable substitution.  Return a string   */
/* with all variables interpolated.  Vars    */
/* either be vars coded in the rexx exec     */
/* itself, or parms coded in the @PARMS file.*/
/*-------------------------------------------*/
varsub:
PARSE ARG ####str
####i = POS("&",####str)
DO WHILE ####i > 0
   ####str0 = SUBSTR(####str,1,####i-1)
   ####str2 = SUBSTR(####str,####i)
   ####str2 = TRANSLATE(####str2,"               "," &./()*&%$#@:<>")
   ####str2 = WORD(####str2,1)
   ####l = LENGTH(####str2)+1
   ####str3 = SUBSTR(####str,####i+####l)
   IF ####str2 = ZCLONE THEN ####str2 = ipds
   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)
   ####str = ####str0""####str2""####str3
   ####i = POS("&",####str)
END
RETURN ####str

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Add a text line to a queue.  (actually a  */
/* stem variable.)  This allows us to manage */
/* the output from various processes and     */
/* give the user a more orderly output.      */
/* The "queue" names must be numbers, due to */
/* the vagaries of the rexx interpreter.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* To store a line in queue #1:              */
/*   call qu 1,'Hello World!!'               */
/* To print all lines from queue #1:         */
/*   DO x = 1 TO q.1.0                       */
/*      SAY q.1.x                            */
/*   END                                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qu:
PARSE ARG #q,#data
#ctr = VALUE(q.#q.0)
IF DATATYPE(#ctr) /= 'NUM' THEN DO
   q.#q.0 = 0
   #ctr = 0
END
#ctr=#ctr+1; q.#q.0=#ctr
q.#q.#ctr = #data
return
/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Print out all lines of a queue.           */
/* #q   = Queue number to print (1..n)       */
/* #box = 1 -> print line within box chars.  */
/* #box = 0 -> print line w/no box chars.    */
/*- - - - - - - - - - - - - - - - - - - - - -*/
qup:
PARSE ARG #q,#box
IF #box /= 1 THEN #box = 0
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN
DO ##x = 1 TO q.#q.0
   IF #box THEN say box(q.#q.##x)
   ELSE            say q.#q.##x
END
RETURN

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Queue has lines: 0|1                      */
/*- - - - - - - - - - - - - - - - - - - - - -*/
quhaslines:
PARSE ARG #q
IF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0
ELSE RETURN 1

/*-------------------------------------------*/
/* See if we have RACF SPECIAL.              */
/*-------------------------------------------*/
racfspec: procedure
x = outtrap('list.',15)
"LISTUSER" USERID()
x = outtrap('OFF')
DO x = 1 TO list.0
   PARSE VAR list.x 'ATTRIBUTES=' attr
   IF POS('SPECIAL',attr) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* Get volume for a given dataset.           */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getvol:
PARSE ARG ####d
DO ####x=1 TO DS.0
   IF \isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME
   ELSE                               ####d2 = DS.####x.DSN
   IF ####d = ####d2 THEN RETURN DS.####x.VOL
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* InsertIntoMember:  Insert some text into  */
/* a member, but only if a search string is  */
/* found/not found.  If ##negative is set to */
/* 1, then only insert if the search string  */
/* is not found.  Otherwise, only insert the */
/* string if the search string IS found.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
insertIntoMember:
PARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative

IF setinp(##ds, ##mem) THEN DO
   ##foun=0
   DO ##xx = 1 TO INPUT.0
      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1
   END
   IF ##negative  = 1 &  ##foun THEN RETURN 0
   IF ##negative /= 1 & \##foun THEN RETURN 0
   call setout ##ods, ##omem
   DO ##xx = 1 TO INPUT.0
      call jcl INPUT.##xx
   END
END
ELSE DO
   call setout ##ods, ##omem
END
call jcl ##txt
call clsout ##ds, ##mem
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* hasParms - True if any of the coded parms */
/* are present for a dataset.                */
/*- - - - - - - - - - - - - - - - - - - - - -*/
hasParms:
PARSE ARG ##prms, ##dsprms
##dsprms = TRANSLATE(##dsprms,' ',',')
DO ####hp = 1 TO WORDS(##prms)
   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1
END
RETURN 0

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* vsam_part:  Return name of DATA or INDEX  */
/* component of a VSAM file.                 */
/*- - - - - - - - - - - - - - - - - - - - - -*/
vsam_part:
ARG ##part,##ds
##x = OUTTRAP('##y.',25)
"LISTC ENT('"ds"')"
##rc = rc
##x = OUTTRAP('OFF')
DO ##x = 1 TO ##y.0
   say ##y.##x
   PARSE VAR ##y.##x (##part) "------- " zzdsn .
   IF zzdsn /= "" THEN RETURN zzdsn
END
RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* volsym:  If USESYM=YES in @PARMS, then    */
/* substitute "&SYSRn" for the volser passed.*/
/* Otherwise, just spit back the volser.     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
volsym:
PARSE ARG ##volser
IF isblank("USESYM") THEN RETURN ##volser
IF USESYM /= "YES" & USERSYM /= "1" THEN RETURN ##volser

DO ##zz = 1 TO 99
   IF \isblank("VOLSER"##zz) & \isblank("ADDR"##zz) THEN DO
      ###zvolser = VALUE("VOLSER"##zz)
      IF ##volser = ###zvolser THEN RETURN "&SYSR"##zz
   END
END

RETURN ""

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getssa: Return the appropriate SSA for a  */
/* dataset.  If usercat is defined and an    */
/* alias to the usercat would be applied to  */
/* this dataset, then return the SSAU value. */
/* Else, return the SSA value (for the mcat).*/
/*- - - - - - - - - - - - - - - - - - - - - -*/
getssa:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN SSA

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) & \isblank("NEWUCAT") THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN SSAU
   END
END

RETURN SSA

/*- - - - - - - - - - - - - - - - - - - - - -*/
/* getcat: Return the appropriate catalog in */
/* which to catalog a dataset--either the    */
/* mastercat or usercat.                     */
/*- - - - - - - - - - - - - - - - - - - - - -*/
getcat:
PARSE ARG ##ds
IF isblank("NEWUCAT") THEN RETURN NEWMCAT

DO ##zz = 1 TO 99
   IF \isblank("UCATALIAS"##zz) THEN DO
      ##zalias = VALUE("UCATALIAS"##zz);
      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT
   END
END

RETURN NEWMCAT

/*-------------------------------------------*/
/*-------------------------------------------*/
/*----- end low level functions -------------*/
/*-------------------------------------------*/
/*-------------------------------------------*/
./ ADD NAME=ZCOMMND
COM='CD SET,SDUMP,NODUMP'
COM='S VLF,SUB=MSTR'
COM='S DLF,SUB=MSTR'
COM='S TSSO,SUB=MSTR'
COM='S IRRDPTAB'
COM='S SDSF'
COM='S VTAM,,,(LIST=00)'
COM='S TSO'
COM='S TCPIP'
COM='S TN3270'
./ ADD NAME=ZCOUPLE
/*-------------------------------------------------------*/
/* COUPLE00                                              */
/* SYSPLEX-LOCAL MODE.                                   */
/*-------------------------------------------------------*/
COUPLE SYSPLEX(LOCAL)
./ ADD NAME=ZIEALPA
./ ADD NAME=ZIEASYM
SYSDEF SYSPARM(00,L)
   SYMDEF(&SSALIAS='SYSZC.')
SYSDEF LPARNAME(PROD1)
       SYSNAME(PROD1)
       SYSCLONE(P1)
SYSDEF LPARNAME(PROD2)
       SYSNAME(PROD2)
       SYSCLONE(P2)
SYSDEF LPARNAME(TEST)
       SYSNAME(TEST)
       SYSCLONE(TS)
SYSDEF LPARNAME(SYSTEMS)
       SYSNAME(SYST)
       SYSCLONE(SY)
./ ADD NAME=ZIEASYS
APG=07,                       *---------------------------------------
CLOCK=00,                     * ZCLONE - IEASYS00 STARTER MEMBER.
CLPA,                         * ZCLONE EXECS USE THIS AS THE START
CMB=(UNITR,COMM,GRAPH,CHRDR), * POINT FOR BUILDING IEASYS00.
CMD=(00,01),                  *---------------------------------------
CON=00,                       SELECT CONSOL00
COUPLE=00,                    SELECT COUPLE00
CSA=(3M,150M),                CSA RANGE
DUMP=DASD,                    PLACE SVC DUMPS ON DASD DEVICES
GRS=NONE,                     NO COORDINATION OF GRS REQUESTS
ICS=00,                       SELECT IEAICS00, CNTL SPECS FOR SRM
IPS=00,                       SELECT IEAIPS00, PERF SPECS FOR SRM
LNKAUTH=LNKLST,               AUTHORIZE LNKLST00, APFTAB IS ALTERNATE
LOGCLS=L,                     WILL NOT BE PRINTED BY DEFAULT
LOGLMT=999999,                MAX WTL MESSAGES QUEUED, MUST BE 6 DIGITS
LPA=00,                       SELECT LPALST00
MAXUSER=250,                  SYS TASKS PLUS INITS PLUS TSOUSERS
MLPA=00,                      SELECT IEALPA00, MLPA PARAMETERS
MSTRJCL=01,                   SELECT MSTJCL01, MASTER JCL
OMVS=(00),                    SELECT BPXPRM00
OPI=YES,                      ALLOW OPERATOR OVERRIDE TO IEASYS00
PAK=00,                       SELECT IEAPAK00
PLEXCFG=MONOPLEX,             MONOPLEX
PROG=(L0,A0),                 SELECT PROGL0 AND A0 (LINKLST AND APF)
REAL=128,                     ALLOWS 2 64K OR 1 128K JOB TO RUN V=R
RSU=0,                        NO RECONFIG STORAGE UNITS
RSVNONR=5,                    RESERVED ASVT ENTRIES
RSVSTRT=5,                    RESERVED ASVT ENTRIES
SCH=00,                       SELECT SCHED00
SMF=00,                       SELECT SMFPRM00, SMF PARAMETERS
SMS=00,                       SMS PARAMETERS
SQA=(15,64),                  SQA SIZE APPROX 640K
SSN=00,                       SELECT IEFSSN00, SUBSYSTEM NAMES
PROD=00,                      SELECT IFAPRD01
SVC=00,                       SELECT IEASVC00, USER SVCS
VAL=00,                       SELECT VATLST00
VIODSN=SYS1.STGINDEX,         VIO DS
VRREGN=64,                    DEFAULT REAL-STORAGE REGION SIZE
./ ADD NAME=ZIEFSSN
SUBSYS SUBNAME(SMS)
   INITRTN(IGDSSIIN)
   INITPARM('ID=02,PROMPT=DISPLAY')
SUBSYS SUBNAME(JES2) PRIMARY(YES) START(YES)
SUBSYS SUBNAME(IRLM)
SUBSYS SUBNAME(JRLM)
SUBSYS SUBNAME(FFST)
SUBSYS SUBNAME(SOM)  INITRTN(GOSAMSSI)
SUBSYS SUBNAME(TNF)
SUBSYS SUBNAME(VMCF)
SUBSYS SUBNAME(CICS) INITRTN(DFHSSIN)
SUBSYS SUBNAME(TSSO) INITRTN(TSSOINIT)
./ ADD NAME=ZIGDSMS
    INTERVAL(15)
    DINTERVAL(150)
    REVERIFY(NO)
    ACSDEFAULTS(NO)
    TRACE(ON)
    SIZE(128K)
    TYPE(ALL)
    JOBNAME(*)
    ASID(*)
    SELECT(ALL)
./ ADD NAME=ZISPALOC
/*-------------------------------------------------------rexx--------*/
/* TSO Allocation EXEC.                                              */
/* Rescue System.                                                    */
/*                                                                   */
/* 03/17/2001 John C. Miller                                         */
/*-------------------------------------------------------------------*/

/*-------------------------------------------------------------------*/
/* Allocate ISPPROF dataset                                          */
/*-------------------------------------------------------------------*/
ispprof = USERID()".ISPF.ISPPROF"
if \alc('ISPPROF', "'"ispprof"'") THEN DO
   "alloc da('"ispprof"') f(ISPPROF) new",
   "space(1 1) cyl lrecl(80) blksize(6160) recfm(f b) dir(15)"
   cc = RC
   IF cc /= 0 THEN DO
      SAY "Unable to allocate ISPF profile dataset "ispprof";"
      SAY "Please contact systems support for assistance."
      SAY "Return code: "cc
   END
END

/*-------------------------------------------------------------------*/
/* Execute user CLIST/Exec if present (Pre-allocation)               */
/*-------------------------------------------------------------------*/
IF SYSDSN("'"ispprof"(PRE)'") = "OK" THEN DO
   "EXEC '"ispprof"(PRE)'"
   cc = RC
   IF cc /= 0 THEN exit
END

"PDF"
exit

/*--------- Allocate the concatenation ------------*/
alc:
PARSE UPPER ARG ddname, dsname
mg = MSG('OFF')                          /* Turn msg off             */
"FREE  FI("ddname")"                     /* Free the DDNAME          */
mg = MSG(mg)                             /* Restore msg level        */
"ALLOC FI("ddname") DA("dsname") SHR"    /* Allocate the files       */
cc = RC                                  /* Save return code         */
RETURN cc <= 4                           /* Return 1 if OK           */

./ ADD NAME=ZJES2PRM
/*-------------------------------------------------------*/
/* The parms below were copied from ZJES2PRM in          */
/* the RESCUE build PDS. It is recommended that you not  */
/* modify these parameters directly, but rather make any */
/* changes to the ZJES2PRM source, and rebuild the       */
/* RESCUE members.  Note that this JES2 PARM desk is not */
/* complete, in that it does not have SPOOLDEF or CKPT   */
/* definitions.  These are built dynamically by the      */
/* RESCUE build process.                                 */
/* 07/10/2007 John C. Miller                             */
/*-------------------------------------------------------*/
OPTSDEF LOG=YES
/*                                                                   */
LOGON(1) APPLID=JES2
/*                                                                   */
BUFDEF   BELOWBUF=(LIMIT=114,WARN=80)
/*                                                                   */
CONDEF   AUTOCMD=50,
         BUFNUM=950,
         BUFWARN=80,
         CONCHAR=$,
         DISPLEN=65,
         DISPMAX=100,
         MASMSG=200,
         RDRCHAR=$
DEBUG    =NO
COMPACT  NAME=JESDATA,
         NUMBER=10,
         CHARS=(16,
           F1,F2,F3,F4,F5,F6,
           F7,F8,F9,A,E,I,D6,
           E4,40,X)
ESTBYTE  NUM=99999,
         INT=99999,
         OPT=0
ESTIME   NUM=2,
         INT=1,
         OPT=NO
ESTLNCT  NUM=5,
         INT=6000,
         OPT=0
ESTPAGE  NUM=100,
         INT=10,
         OPT=0
ESTPUN   NUM=100,
         INT=2000,
         OPT=0
FSSDEF(PRINTOFF)
INIT(1) NAME=1,CLASS=A,START=YES
INIT(2) NAME=1,CLASS=A,START=YES
INIT(3) NAME=1,CLASS=A,START=YES
INIT(4) NAME=1,CLASS=A,START=YES
INIT(5) NAME=1,CLASS=A,START=YES
INIT(6) NAME=1,CLASS=A,START=YES
INIT(7) NAME=1,CLASS=A,START=YES
INIT(8) NAME=1,CLASS=A,START=YES
INITDEF  PARTNUM=8
/*                                                                  */
INTRDR   AUTH=(JOB=YES,DEVICE=NO,SYSTEM=YES),BATCH=YES,CLASS=A,
         HOLD=NO,PRTYINC=0,PRTYLIM=15,RDINUM=20
/*                                                                   */
JOBCLASS(A) ACCT=NO,         /* ACCT# NOT REQ   B................... */
         PGMRNAME=NO,        /* PGMRNM NOT RQ   B................... */
         TIME=(0030,00),     /* JOB STEP TIME   ...MMMMSS........... */
         REGION=4096K,       /* REGION SIZE     .........CCC........ */
         COMMAND=VERIFY,     /* VERIFY CMDS     ............R....... */
         BLP=YES,            /* IGNORE BLP      .............L...... */
         AUTH=ALL,           /* ALLOW ALL CMD   ..............AAAA.. */
         MSGLEVEL=(1,1),     /* JOB, ALL MSGS   ..................EF */
         COPY=NO,            /* NOT TYPRUN=COPY                 DHWNC*/
         HOLD=NO,            /* NOT TYPRUN=HOLD                 DHWNC*/
         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT         DHWNC*/
         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT         DHWNC*/
         JOURNAL=NO,         /* JOURNAL THIS JOB CLASS          DHWNC*/
         LOG=YES,            /* PRINT JES2 JOB LOG              DHWNC*/
         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB          DHWNC*/
         PERFORM=000,        /* SRM PERFORMANCE GROUP 0         DHWNC*/
         PROCLIB=00,         /* USE //PROC00 DD                 DHWNC*/
         RESTART=NO,         /* NO REQUEUE (XEQ) ON IPL         DHWNC*/
         SCAN=NO,            /* NOT TYPRUN=SCAN                 DHWNC*/
         SWA=BELOW,          /* SWA CBS BELOW 16M LINE          DHWNC*/
         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS           DHWNC*/
         TYPE26=YES          /* PRODUCE SMF 26 RECORDS          DHWNC*/
/*                                                                   */
/*                                                                   */
JOBDEF   ACCTFLD=OPTIONAL,   /* ACCOUNTING FIELD OPTIONAL      DOHWNC*/
         JCLERR=NO,          /* NO TERM. JOB W/JCL ERROR       DOHWNC*/
     /*  JOBNUM=1000,  */    /* JOB QUEUE SIZE                     DC*/
         JOBNUM=9999,        /* JOB QUEUE SIZE                  MAM2*/
         JOBWARN=80,         /* WARNING THRESHOLD % FOR JQES   DOHWNC*/
         NUMWARN=80,         /* WARN THRESHOLD % FOR JOB NUMB. DOHWNC*/
         PRTYHIGH=10,        /* UPPER LIMIT FOR AGING          DOHWNC*/
         PRTYJECL=YES,       /*PRIORITY JECL SUPPORTED         DOHWNC*/
         PRTYJOB=NO,         /* PRTY= ON JOB NOT SUP'D         DOHWNC*/
         PRTYLOW=5,          /* LOWER LIMIT FOR AGING          DOHWNC*/
         PRTYRATE=96,        /* PRTY AGING RATE X/DAY          DOHWNC*/
         RANGE=(1-9999)      /* LOCAL JOB NUMBER RANGE          DOWNC*/
/*                                                                   */
JOBPRTY(1) PRIORITY=9,       /* JOB PRTY=9 IF                  DOHWNC*/
          TIME=2             /*  < 2 MIN. EXEC. TIME           DOHWNC*/
                             /*                                      */
JOBPRTY(2) PRIORITY=8,       /* JOB PRTY=8 IF                        */
          TIME=5             /*  < 5 MIN. EXEC. TIME                 */
                             /*                                      */
JOBPRTY(3) PRIORITY=7,TIME=15 /*JOB PRTY=7 IF <15 MIN.  &RPRI2,...OC*/
                             /* ETC.                                 */
                             /*                                      */
JOBPRTY(4) PRIORITY=6,       /* JOB PRTY=6 IF NOLIM     &RPRI2,...OC*/
         TIME=1440           /* ETC.                                 */
                             /*                                      */
/*                            *--------------------------------------*
                              |    IDENTIFY JES2 APPLIDS TO VTAM     |
                              *--------------------------------------*
                                                                    */
MASDEF   SHARED=NOCHECK,     /* MULTI ACCESS SPOOL NOCHECK           */
         HOLD=100,           /* MINIMUM HOLD TIME                    */
         DORMANCY=(100,500), /* MINIMUM / MAXIMUM DORMANCY TIME      */
         LOCKOUT=1200        /* LOCK-OUT WARNING TIME                */
                             /*                                      */
/*                                                                  */
NJEDEF   DELAY=120,         /* MAX. MSG DELAY TIME            DOHWNC*/
         JRNUM=4,           /* NUM. OF JOB RECEIVERS           DHWNC*/
         JTNUM=4,           /* NUM. OF JOB XMITTERS            DHWNC*/
         LINENUM=1,         /* NUM. OF LINES FOR NJE           DHWNC*/
         NODENUM=2000,      /* MAX. NUMBER OF NJE NODES         MAM2*/
         OWNNODE=1,         /* THIS NODE'S NUMBER              MAM  */
         PATH=1,            /* NUM. OF PATHS/ALT'NATE          DHWNC*/
         RESTMAX=8000000,   /* MAX. RESISTANCE TOLERANCE       DHWNC*/
         RESTNODE=100,      /* THIS NODE'S RESISTANCE          DHWNC*/
         RESTTOL=0,         /* ALT. RESISTANCE TOLERANCE       DHWNC*/
         SRNUM=4,           /* NUM. OF SYSOUT RECEIVERS        DHWNC*/
         STNUM=4            /* NUM. OF SYSOUT TRANSMITTERS     DHWNC*/
/*                                                                  */
/*OFFLOAD(1) DSN=SYS1.OFFLOAD  /* DATA SET NAME           DSN       */
/*                           /* NO. OF DEVICES (UNITS)  UNITCT      */
                             /*                                      */
OFFLOAD(1) DSN=SYS3.SPOOL.OFFLOAD,LABEL=SL,RETPD=7,UNIT=CART
OFF(1).JR CLASS=,           /* RELOAD ALL CLASSES             DOHWNC*/
         HOLD=,             /* RELOAD HELD - NON-HELD         DOHWNC*/
         JOBNAME=,          /* RELOAD ANY JOB NAME            DOHWNC*/
                            /* MODIFY JOBS ON RELOAD                */
         MOD=(CLASS=,       /* - DON'T CHANGE CLASS           DOHWNC*/
              HOLD=,        /* - DON'T CHANGE HOLD            DOHWNC*/
              ROUTECDE=,    /* - DON'T CHANGE DEST'N          DOHWNC*/
              SYSAFF=),     /* - DON'T CHANGE SYSAFF.         DOHWNC*/
         NOTIFY=NO,         /* DON'T NOTIFY ON RELOAD         DOHWNC*/
         RANGE=J1-32767,    /* RELOAD ALL JOB NUMBERS         DOHWNC*/
         ROUTECDE=(),       /* RELOAD JOBS W/ANY DEST         DOHWNC*/
         START=YES,         /* ABORTED WITH $S OFFLOAD         DHWNC*/
         SYSAFF=(),         /* RELOAD JOBS WITH ANY AFF       DOHWNC*/
         WS=(/)             /* JOB SELECTION CRITERIA         DLT   */
/*                                                                  */
OFF(1).JT CLASS=,           /* SELECT NO CLASSES              DOHWNC*/
         DISP=DELETE,       /* PURGE AFTER OFFLOAD            DOHWNC*/
         HOLD=,             /* SELECT HELD - NON-HELD         DOHWNC*/
         JOBNAME=,          /* SELECT ANY JOB NAME            DOHWNC*/
         NOTIFY=NO,         /* DON'T NOTIFY ON OFFLD.         DOHWNC*/
         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS         DOHWNC*/
         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST         DOHWNC*/
         START=YES,         /* STARTED WITH $S OFFLOAD     DHWNC*/
         SYSAFF=(),         /* SELECT JOBS WITH ANY AFF       DOHWNC*/
         VOLUME=(),         /* SELECT ANY SPOOL VOLUME        DOHWNC*/
         WS=(/)             /* JOB SELECTION CRITERIA         DLT   */
/*                                                                  */
OFF(1).SR BURST=,         /* SELECT ANY BURST SETTING       DOHWNC*/
         OUTDISP=(HOLD,KEEP,LEAVE,WRITE),
         FCB=,              /* SELECT ANY FCB                 DOHWNC*/
         FLASH=,            /* SELECT ANY/NO FLASH            DOHWNC*/
         HOLD=,             /* SELCT HELD/NON-HLD JOBS        DOHWNC*/
         JOBNAME=,          /* SELECT ANY JOB NAME            DOHWNC*/
                            /* MODIFY FOLLOWING ON RELOAD     DOHWNC*/
         MOD=(BURST=,       /* - DON'T CHANGE BURST           DOHWNC*/
              OUTDISP=,     /* - DON'T CHANGE DSHOLD          DOHWNC*/
              FCB=,         /* - DON'T CHANGE FCB             DOHWNC*/
              FLASH=,       /* - DON'T CHANGE FLASH           DOHWNC*/
              FORMS=,       /* - DON'T CHANGE FORMS           DOHWNC*/
              HOLD=,        /* - DON'T CHANGE HOLD            DOHWNC*/
              PRMODE=,      /* - DON'T CHANGE PRMODE          DOHWNC*/
              QUEUE=,       /* - DON'T CHANGE CLASS           DOHWNC*/
              ROUTECDE=,    /* - DON'T CHANGE DESTN           DOHWNC*/
              UCS=,         /* - DON'T CHANGE UCS             DOHWNC*/
              WRITER=),     /* - DON'T CHANGE WRITER          DOHWNC*/
         NOTIFY=NO,         /* DON'T NOTIFY ON RELOAD         DOHWNC*/
         PRMODE=(),         /* SELECT ANY PRMODE              DOHWNC*/
         QUEUE=,            /* SELECT ANY SYSOUT CLASS        DOHWNC*/
         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS         DOHWNC*/
         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST         DOHWNC*/
         START=YES,         /* STARTED WITH $S OFFLOAD         DHWNC*/
         UCS=,              /* SELECT ANY UCS                 DOHWNC*/
         WRITER=,           /* SELECT ANY WRITER              DOHWNC*/
         WS=(/)             /* JOB SELECTION CRITERIA         DOHWNC*/
                            /* - CLASS ONLY                   DOHWNC*/
/*                                                                  */
OFF(1).ST BURST=,           /* SELECT ANY BURST SET'G         DOHWNC*/
         DISP=DELETE,       /* PURGE AFTER OFFLOAD            DOHWNC*/
         OUTDISP=(HOLD,KEEP,LEAVE,WRITE),
         FCB=,              /* SELECT ANY FCB                 DOHWNC*/
         FLASH=,            /* SELECT ANY/NO FLASH            DOHWNC*/
         HOLD=,             /* SELCT HELD-NON-HLD JOBS        DOHWNC*/
         JOBNAME=,          /* SELECT ANY JOB NAME            DOHWNC*/
         LIMIT=(0-*),       /* SELECT ANY # LINES             DOHWNC*/
         NOTIFY=NO,         /* DON'T NOTIFY ON OFFLD.         DOHWNC*/
         PLIM=(0-*),        /* SELECT ANY # PAGES             DOHWNC*/
         PRMODE=(),         /* SELECT ANY PRMODE              DOHWNC*/
         QUEUE=,            /* SELECT ANY SYSOUT CLASS        DOHWNC*/
         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS         DOHWNC*/
         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST         DOHWNC*/
         START=YES,         /* STARTED WITH $S OFFLOAD         DHWNC*/
         UCS=,              /* SELECT ANY UCS                 DOHWNC*/
         VOLUME=(),         /* SELECT ANY SPOOL VOLUME        DOHWNC*/
         WRITER=,           /* SELECT ANY WRITER              DOHWNC*/
         WS=(/)             /* JOB SELECTION CRITERIA         DLT   */
                            /* - CLASS ONLY                   DOHWNC*/
/*                                                                   */
/*********************************************************************/
OUTCLASS(A) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(B) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* NO TRACK-CELL                      WC*/
/*                                                                  */
OUTCLASS(C) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(D) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(H) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(HOLD,HOLD),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
/*                                                                  */
OUTCLASS(J) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=PRINT,      /* SPECIAL PRINT CLASS                WC*/
         TRKCELL=NO        /* NO TRACK-CELL                      WC*/
/*                                                                 */
OUTCLASS(K) BLNKTRNC=YES,  /* TRUNCATE TRAILING BLANKS             */
         OUTDISP=(HOLD,HOLD),                 /*               MAM */
         OUTPUT=PRINT,      /* PRINT CLASS                     MAM */
         TRKCELL=YES        /* TRACK-CELL THIS CLASS               */
/*                                                                 */
OUTCLASS(L) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(KEEP,KEEP),
         OUTPUT=PRINT,      /* PRINT CLASS FOR LWTR               WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(M) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                 */
OUTCLASS(O) BLNKTRNC=YES,  /* TRUNCATE TRAILING BLANKS             */
         OUTDISP=(HOLD,HOLD),                 /*               MAM */
         OUTPUT=PRINT,      /* PRINT CLASS                     MAM */
         TRKCELL=YES        /* TRACK-CELL THIS CLASS               */
/*                                                                 */
OUTCLASS(P) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(HOLD,HOLD),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(Q) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(T) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(HOLD,HOLD),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
/*                                                                  */
OUTCLASS(X) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(HOLD,HOLD),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(Y) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(HOLD,HOLD),
         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(Z) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(WRITE,WRITE),
         OUTPUT=DUMMY,      /* DUMMY PRINT CLASS                  WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTCLASS(5) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/
         OUTDISP=(PURGE,PURGE),
         OUTPUT=DUMMY,      /* DUMMY PRINT CLASS                  WC*/
         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/
/*                                                                  */
OUTDEF   BRODCAST=NO,       /* WHETHER SHARED BROADCASTING     DOWNC*/
         COPIES=255,        /* MAX. # OF COPIES ALLOWED       DOHWNC*/
         DMNDSET=NO,        /* NO DEMAND SETUP                  DWNC*/
         JOENUM=3000,       /* MAX. # OF JOES                   MAM2*/
         JOEWARN=80,        /* WARNING THRESHOLD %            DOHWNC*/
         PRTYHIGH=255,      /* CEILING FOR PRTY AGING         DOHWNC*/
         PRTYLOW=0,         /* FLOOR FOR PRTY AGING           DOHWNC*/
         PRTYOUT=NO,        /* NO PRTY= ON // OUTPUT          DOHWNC*/
         STDFORM=STD,       /* DEFAULT FORMS ID                 DWNC*/
         USERSET=NO         /* NO USER DEMAND-SETUP             DWNC*/
/*                                                                  */
OUTPRTY(1) PRIORITY=144,    /* OUTPUT PRTY IS 144 IF          DOHWNC*/
         RECORD=2000,       /*  < 2000 RECORDS (LINE)         DOHWNC*/
         PAGE=50            /*  OR < 50 PAGES (PAGE)          DOHWNC*/
/*                                                                  */
OUTPRTY(2) PRIORITY=128,    /* OUTPUT PRTY IS 128 IF          DOHWNC*/
         RECORD=5000,       /*  < 5000 RECORDS (LINE)         DOHWNC*/
         PAGE=100           /*  OR < 100 PAGES (PAGE)         DOHWNC*/
/*                                                                  */
OUTPRTY(3) PRIORITY=112,     /* OUTPUT PRTY IS 112 IF   &XPRI1    OC*/
           RECORD=15000,     /*  <15000 RECORDS (LINE)  &XLIN1    OC*/
           PAGE=300          /*  OR <300 PAGES (PAGE)   &XPAG1    OC*/
                             /* ETC.                               OC*/
OUTPRTY(4) PRIORITY=96,      /* OUTPUT PRTY IS  96 IF   &XPRI1    OC*/
           RECORD=16677215,  /*  < MAX  RECORDS (LINE)  &XLIN1    OC*/
           PAGE=16677215     /*  OR <MAX PAGES (PAGE)   &XPAG1    OC*/
                             /* ETC.                               OC*/
/*                                                                  */
PCEDEF   CNVTNUM=2,         /* NUMBER OF CONVERTER PCES        DHWNC*/
         OUTNUM=2,          /* NUMBER OF OUTPUT PCES           DHWNC*/
         PSONUM=2,          /* NUMBER OF PSO PCES              DHWNC*/
         PURGENUM=2         /* NUMBER OF PURGE PCES            DHWNC*/
/*                                                                   */
PRINTDEF CCWNUM=200,        /* # CCWS / PRINT BUFFER            DWNC*/
         DBLBUFR=YES,       /* DOUBLE BUFFER LCL PRTS           DWNC*/
         FCB=6,             /* INITIAL FCB LOADED               DWNC*/
         LINECT=61,         /* 61 LINES/PAGE                  DOHWNC*/
/*       NIFCB=8X8,    */   /* NO 3800 FCB LOADED               DWNC*/
/*       NIFLASH=****, */    /* NO 3800 FLASH LOADED             DWNC*/
                             /* NOTE: THE VALUES FOR NIFCB= AND      */
                             /*       NIFLASH=  CANNOT BE NULL OR    */
                             /*       ASTERISKS (AS SHOWN HERE).     */
                             /*       IF THE STATEMENTS ARE NOT      */
                             /*       CODED AT ALL, THEN THE DEFAULT */
                             /*       WILL BE ASTERISKS. THE         */
                             /*       STATEMENTS ARE SHOWN THIS WAY  */
                             /*       ONLY TO INCLUDE THE DEFAULT    */
                             /*       VALUES HERE.                   */
         NIUCS=0,            /* WAS GT15                         DWNC*/
         RDBLBUFR=NO,        /* SINGLE BUFFER RMT PRTS           DWNC*/
         SEPPAGE=(REMOTE=HALF,LOCAL=FULL),
         TRANS=NO,           /* PN-XLATE FOR 1403/RM.PR          DWNC*/
         UCS=0               /* BYPASS UCS-LOADING               DWNC*/
/*                                                                   */
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    LOCAL PRINTERS                    |
                              *--------------------------------------*
                                                                     */
                             /* ALTERNATE NAME FOR PRTN:             */
                             /*   PRINTERN                           */
/*                                                                   */
PUNCHDEF CCWNUM=200,         /* # CCWS / PUNCH BUFFER            DWNC*/
         DBLBUFR=YES,        /* SINGLE BUFFER LCL PUNS           DWNC*/
         RDBLBUFR=NO         /* SINGLE BUFFER RMT PUNS           DWNC*/
/*                                                                   */
PUN(1)  CKPTLINE=100,    /* NO. OF CARDS TO PUNCH PER PAGE DOHWNC*/
        CLASS=BK,    /*  OUTPUT CLASS PROCESSED BY PUN  DOHWNC*/
       WS=(W,R,Q,PRM,LIM/F,P)  /* WORK SELECTION CRITERION    DOHWNC*/
/*                                                                   */
PUN(2)  CKPTLINE=100,    /* NO. OF CARDS TO PUNCH PER PAGE DOHWNC*/
        CLASS=BK,    /*  OUTPUT CLASS PROCESSED BY PUN  DOHWNC*/
       WS=(W,R,Q,PRM,LIM/F,P)  /* WORK SELECTION CRITERION    DOHWNC*/
/*                                                                   */
RDR(1)  AUTO,            /* RDRNN COMES UP STARTED (DRAIN) DOHWNC*/
        CLASS=A,        /* DEFAULT JOB CLASS              DOHWNC*/
        NOHOLD,         /* JOBS NOT HELD AFTER CONV.(HOLD)DOHWNC*/
        MSGCLASS=A     /* DEFAULT MESSAGE CLASS          DOHWNC*/
                             /* ERRORS ARE COUNTED                   */
                             /*                                      */
/*                                                                   */
SMFDEF   BUFNUM=20,          /* NUMBER OF SMF BUFFERS            DWNC*/
         BUFWARN=80          /* WARNING THRESHOLD %            DOHWNC*/
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    SSI DEFINITIONS                   |
                              |    ADDED IN SP311                    |
                              *--------------------------------------*
                                                                     */
SSI(1)  TRACE=NO            /* SPECIFY WHICH SUBSYSTEM FUNCT  DOHWNC*/
                            /* WHETHER OR NOT TRACING IS      DOHWNC*/
                            /*  ACTIVE FOR THIS SSI FUNCTION        */
/*                                                                   */
STCCLASS TIME=(0010,00),     /* JOB STEP TIME   ...MMMMSS........... */
         REGION=0K,          /* REGION SIZE     .........CCC........ */
         COMMAND=EXECUTE,    /* EXECUTE COMMANDS............R....... */
         BLP=YES,            /* IGNORE BLP PARM .............L...... */
         AUTH=ALL,           /* ALLOW ALL CMDS  ..............AAAA.. */
         MSGLEVEL=(1,1),     /* JOB, ALL MSGS   ..................EF */
         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT         DHWNC*/
         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT         DHWNC*/
         OUTDISP=(HOLD,HOLD),      /* PURGE,HOLD TO HOLD,HOLD        */
         LOG=YES,            /* PRINT JES2 JOB LOG              DHWNC*/
         MSGCLASS=K,         /* DEFAULT MESSAGE CLASS           DHWNC*/
         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB          DHWNC*/
         PERFORM=000,        /* SRM PERFORMANCE GROUP 0         DHWNC*/
         PROCLIB=00,         /* USE //PROC00 DD                 DHWNC*/
         SWA=BELOW,          /* SWA CBS BELOW 16M LINE          DHWNC*/
                             /*     (ADDED BY APAR OY02574)          */
                             /*     (SUPERSEDED BY APAR OY03444)     */
         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS           DHWNC*/
         TYPE26=YES          /* PRODUCE SMF 26 RECORDS          DHWNC*/
/*                                                                   */
/*                             TP (NJE/RJE) CHARACTERISTICS          */
/*    TPDEF    BELOWBUF=(LIMIT=200,SIZE=1152,WARN=80),               */
TPDEF    BELOWBUF=(LIMIT=200,SIZE=3840,WARN=80),
         MBUFSIZE=3840,      /* MULTI-LEAVING BUFFER SIZE       DHWNC*/
         RMTMSG=100,         /* MAX. # MSGS QUEUED TO REMOTE   DOHWNC*/
         SESSION=20,         /* MAX. # SNA SESSIONS             DHWNC*/
         AUTOINTV=120
/*                                                                   */
/*********************************************************************/
TRACE(1)  START=NO           /* SPECIFY WHICH TRACE ID          DOWNC*/
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    $TRACE FACILITY                   |
                              *--------------------------------------*
                                                                     */
TRACEDEF TABLES=3,           /* NUMBER OF TRACE TABLES          DOWNC*/
         PAGES=2,            /* NUMBER OF 4K PAGES PER TABLE     DWNC*/
         TABWARN=80,         /* WARNING THRESHOLD %             DOWNC*/
         ACTIVE=NO,          /* WHETHER OR NOT TO START HE      DOWNC*/
                             /*  TRACE FACILITY                      */
         LOG=(START=NO,      /* WHETHER OR NOT TO FORMAT AND    DOWNC*/
                             /*  ADD DATA TO TRACE LOG DATASET       */
              SIZE=500,      /* MAX SIZE OF TRACE LOG DATASET   DOWNC*/
              CLASS=A)       /* TRACE LOG DATASET OUTPUT CLASS  DOWNC*/
/*                                                                   */
/*********************************************************************/
/*                            *--------------------------------------*
                              |    TSU DEFAULTS                      |
                              *--------------------------------------*
                                                                     */
TSUCLASS TIME=(1440,00),     /* JOB STEP TIME   ...MMMMSS..........  */
         REGION=0K,          /* REGION SIZE     .........CCC.......  */
         COMMAND=EXECUTE,    /* EXECUTE COMMANDS............R......  */
         BLP=NO,             /* IGNORE BLP PARM .............L.....  */
         AUTH=ALL,           /* ALLOW ALL CMDS  ..............AAAA.  */
         MSGLEVEL=(0,0),     /* JOB, ALL MSGS   ..................EF */
         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT         DHWNC*/
         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT         DHWNC*/
         OUTDISP=(PURGE,HOLD),     /* PURGE,HOLD                     */
         LOG=YES,            /* PRINT JES2 JOB LOG              DHWNC*/
         MSGCLASS=Z,         /* DEFAULT MESSAGE CLASS           DHWNC*/
         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB          DHWNC*/
         PERFORM=000,        /* SRM PERFORMANCE GROUP 0         DHWNC*/
         PROCLIB=00,         /* USE //PROC00 DD                 DHWNC*/
         SWA=BELOW,          /* SWA CBS BELOW 16M LINE          DHWNC*/
                             /*     (ADDED BY APAR OY02574)          */
                             /*     (SUPERSEDED BY APAR OY03444)     */
         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS           DHWNC*/
         TYPE26=YES          /* PRODUCE SMF 26 RECORDS          DHWNC*/
                             /*                                      */
./ ADD NAME=ZTSOKEY
USERMAX=10,                                                            +
RECONLIM=3,                                                            +
BUFRSIZE=132,                                                          +
HIBFREXT=6600,                                                         +
LOBFREXT=3300,                                                         +
CHNLEN=4,                                                              +
SCRSIZE=1920
